(function () { const l = document.createElement("link").relList; if (l && l.supports && l.supports("modulepreload")) return; for (const c of document.querySelectorAll('link[rel="modulepreload"]')) o(c); new MutationObserver(c => { for (const d of c) if (d.type === "childList") for (const h of d.addedNodes) h.tagName === "LINK" && h.rel === "modulepreload" && o(h) }).observe(document, { childList: !0, subtree: !0 }); function u(c) { const d = {}; return c.integrity && (d.integrity = c.integrity), c.referrerPolicy && (d.referrerPolicy = c.referrerPolicy), c.crossOrigin === "use-credentials" ? d.credentials = "include" : c.crossOrigin === "anonymous" ? d.credentials = "omit" : d.credentials = "same-origin", d } function o(c) { if (c.ep) return; c.ep = !0; const d = u(c); fetch(c.href, d) } })(); var br = { exports: {} }, ll = {};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jm; function u1() { if (jm) return ll; jm = 1; var i = Symbol.for("react.transitional.element"), l = Symbol.for("react.fragment"); function u(o, c, d) { var h = null; if (d !== void 0 && (h = "" + d), c.key !== void 0 && (h = "" + c.key), "key" in c) { d = {}; for (var g in c) g !== "key" && (d[g] = c[g]) } else d = c; return c = d.ref, { $$typeof: i, type: o, key: h, ref: c !== void 0 ? c : null, props: d } } return ll.Fragment = l, ll.jsx = u, ll.jsxs = u, ll } var wm; function o1() { return wm || (wm = 1, br.exports = u1()), br.exports } var k = o1(), Tr = { exports: {} }, st = {};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Lm; function r1() { if (Lm) return st; Lm = 1; var i = Symbol.for("react.transitional.element"), l = Symbol.for("react.portal"), u = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), d = Symbol.for("react.consumer"), h = Symbol.for("react.context"), g = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), b = Symbol.iterator; function x(T) { return T === null || typeof T != "object" ? null : (T = b && T[b] || T["@@iterator"], typeof T == "function" ? T : null) } var V = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, w = Object.assign, U = {}; function B(T, j, K) { this.props = T, this.context = j, this.refs = U, this.updater = K || V } B.prototype.isReactComponent = {}, B.prototype.setState = function (T, j) { if (typeof T != "object" && typeof T != "function" && T != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, T, j, "setState") }, B.prototype.forceUpdate = function (T) { this.updater.enqueueForceUpdate(this, T, "forceUpdate") }; function q() { } q.prototype = B.prototype; function Z(T, j, K) { this.props = T, this.context = j, this.refs = U, this.updater = K || V } var Y = Z.prototype = new q; Y.constructor = Z, w(Y, B.prototype), Y.isPureReactComponent = !0; var et = Array.isArray, H = { H: null, A: null, T: null, S: null, V: null }, W = Object.prototype.hasOwnProperty; function nt(T, j, K, G, $, dt) { return K = dt.ref, { $$typeof: i, type: T, key: j, ref: K !== void 0 ? K : null, props: dt } } function P(T, j) { return nt(T.type, j, void 0, void 0, void 0, T.props) } function yt(T) { return typeof T == "object" && T !== null && T.$$typeof === i } function Ct(T) { var j = { "=": "=0", ":": "=2" }; return "$" + T.replace(/[=:]/g, function (K) { return j[K] }) } var Xt = /\/+/g; function Ht(T, j) { return typeof T == "object" && T !== null && T.key != null ? Ct("" + T.key) : j.toString(36) } function Qe() { } function je(T) { switch (T.status) { case "fulfilled": return T.value; case "rejected": throw T.reason; default: switch (typeof T.status == "string" ? T.then(Qe, Qe) : (T.status = "pending", T.then(function (j) { T.status === "pending" && (T.status = "fulfilled", T.value = j) }, function (j) { T.status === "pending" && (T.status = "rejected", T.reason = j) })), T.status) { case "fulfilled": return T.value; case "rejected": throw T.reason } }throw T } function qt(T, j, K, G, $) { var dt = typeof T; (dt === "undefined" || dt === "boolean") && (T = null); var lt = !1; if (T === null) lt = !0; else switch (dt) { case "bigint": case "string": case "number": lt = !0; break; case "object": switch (T.$$typeof) { case i: case l: lt = !0; break; case v: return lt = T._init, qt(lt(T._payload), j, K, G, $) } }if (lt) return $ = $(T), lt = G === "" ? "." + Ht(T, 0) : G, et($) ? (K = "", lt != null && (K = lt.replace(Xt, "$&/") + "/"), qt($, j, K, "", function (hn) { return hn })) : $ != null && (yt($) && ($ = P($, K + ($.key == null || T && T.key === $.key ? "" : ("" + $.key).replace(Xt, "$&/") + "/") + lt)), j.push($)), 1; lt = 0; var ce = G === "" ? "." : G + ":"; if (et(T)) for (var Et = 0; Et < T.length; Et++)G = T[Et], dt = ce + Ht(G, Et), lt += qt(G, j, K, dt, $); else if (Et = x(T), typeof Et == "function") for (T = Et.call(T), Et = 0; !(G = T.next()).done;)G = G.value, dt = ce + Ht(G, Et++), lt += qt(G, j, K, dt, $); else if (dt === "object") { if (typeof T.then == "function") return qt(je(T), j, K, G, $); throw j = String(T), Error("Objects are not valid as a React child (found: " + (j === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : j) + "). If you meant to render a collection of children, use an array instead.") } return lt } function z(T, j, K) { if (T == null) return T; var G = [], $ = 0; return qt(T, G, "", "", function (dt) { return j.call(K, dt, $++) }), G } function L(T) { if (T._status === -1) { var j = T._result; j = j(), j.then(function (K) { (T._status === 0 || T._status === -1) && (T._status = 1, T._result = K) }, function (K) { (T._status === 0 || T._status === -1) && (T._status = 2, T._result = K) }), T._status === -1 && (T._status = 0, T._result = j) } if (T._status === 1) return T._result.default; throw T._result } var J = typeof reportError == "function" ? reportError : function (T) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var j = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof T == "object" && T !== null && typeof T.message == "string" ? String(T.message) : String(T), error: T }); if (!window.dispatchEvent(j)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", T); return } console.error(T) }; function ft() { } return st.Children = { map: z, forEach: function (T, j, K) { z(T, function () { j.apply(this, arguments) }, K) }, count: function (T) { var j = 0; return z(T, function () { j++ }), j }, toArray: function (T) { return z(T, function (j) { return j }) || [] }, only: function (T) { if (!yt(T)) throw Error("React.Children.only expected to receive a single React element child."); return T } }, st.Component = B, st.Fragment = u, st.Profiler = c, st.PureComponent = Z, st.StrictMode = o, st.Suspense = y, st.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = H, st.__COMPILER_RUNTIME = { __proto__: null, c: function (T) { return H.H.useMemoCache(T) } }, st.cache = function (T) { return function () { return T.apply(null, arguments) } }, st.cloneElement = function (T, j, K) { if (T == null) throw Error("The argument must be a React element, but you passed " + T + "."); var G = w({}, T.props), $ = T.key, dt = void 0; if (j != null) for (lt in j.ref !== void 0 && (dt = void 0), j.key !== void 0 && ($ = "" + j.key), j) !W.call(j, lt) || lt === "key" || lt === "__self" || lt === "__source" || lt === "ref" && j.ref === void 0 || (G[lt] = j[lt]); var lt = arguments.length - 2; if (lt === 1) G.children = K; else if (1 < lt) { for (var ce = Array(lt), Et = 0; Et < lt; Et++)ce[Et] = arguments[Et + 2]; G.children = ce } return nt(T.type, $, void 0, void 0, dt, G) }, st.createContext = function (T) { return T = { $$typeof: h, _currentValue: T, _currentValue2: T, _threadCount: 0, Provider: null, Consumer: null }, T.Provider = T, T.Consumer = { $$typeof: d, _context: T }, T }, st.createElement = function (T, j, K) { var G, $ = {}, dt = null; if (j != null) for (G in j.key !== void 0 && (dt = "" + j.key), j) W.call(j, G) && G !== "key" && G !== "__self" && G !== "__source" && ($[G] = j[G]); var lt = arguments.length - 2; if (lt === 1) $.children = K; else if (1 < lt) { for (var ce = Array(lt), Et = 0; Et < lt; Et++)ce[Et] = arguments[Et + 2]; $.children = ce } if (T && T.defaultProps) for (G in lt = T.defaultProps, lt) $[G] === void 0 && ($[G] = lt[G]); return nt(T, dt, void 0, void 0, null, $) }, st.createRef = function () { return { current: null } }, st.forwardRef = function (T) { return { $$typeof: g, render: T } }, st.isValidElement = yt, st.lazy = function (T) { return { $$typeof: v, _payload: { _status: -1, _result: T }, _init: L } }, st.memo = function (T, j) { return { $$typeof: m, type: T, compare: j === void 0 ? null : j } }, st.startTransition = function (T) { var j = H.T, K = {}; H.T = K; try { var G = T(), $ = H.S; $ !== null && $(K, G), typeof G == "object" && G !== null && typeof G.then == "function" && G.then(ft, J) } catch (dt) { J(dt) } finally { H.T = j } }, st.unstable_useCacheRefresh = function () { return H.H.useCacheRefresh() }, st.use = function (T) { return H.H.use(T) }, st.useActionState = function (T, j, K) { return H.H.useActionState(T, j, K) }, st.useCallback = function (T, j) { return H.H.useCallback(T, j) }, st.useContext = function (T) { return H.H.useContext(T) }, st.useDebugValue = function () { }, st.useDeferredValue = function (T, j) { return H.H.useDeferredValue(T, j) }, st.useEffect = function (T, j, K) { var G = H.H; if (typeof K == "function") throw Error("useEffect CRUD overload is not enabled in this build of React."); return G.useEffect(T, j) }, st.useId = function () { return H.H.useId() }, st.useImperativeHandle = function (T, j, K) { return H.H.useImperativeHandle(T, j, K) }, st.useInsertionEffect = function (T, j) { return H.H.useInsertionEffect(T, j) }, st.useLayoutEffect = function (T, j) { return H.H.useLayoutEffect(T, j) }, st.useMemo = function (T, j) { return H.H.useMemo(T, j) }, st.useOptimistic = function (T, j) { return H.H.useOptimistic(T, j) }, st.useReducer = function (T, j, K) { return H.H.useReducer(T, j, K) }, st.useRef = function (T) { return H.H.useRef(T) }, st.useState = function (T) { return H.H.useState(T) }, st.useSyncExternalStore = function (T, j, K) { return H.H.useSyncExternalStore(T, j, K) }, st.useTransition = function () { return H.H.useTransition() }, st.version = "19.1.1", st } var Hm; function oc() { return Hm || (Hm = 1, Tr.exports = r1()), Tr.exports } var X = oc(), Ar = { exports: {} }, sl = {}, xr = { exports: {} }, Er = {};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var qm; function c1() { return qm || (qm = 1, (function (i) { function l(z, L) { var J = z.length; z.push(L); t: for (; 0 < J;) { var ft = J - 1 >>> 1, T = z[ft]; if (0 < c(T, L)) z[ft] = L, z[J] = T, J = ft; else break t } } function u(z) { return z.length === 0 ? null : z[0] } function o(z) { if (z.length === 0) return null; var L = z[0], J = z.pop(); if (J !== L) { z[0] = J; t: for (var ft = 0, T = z.length, j = T >>> 1; ft < j;) { var K = 2 * (ft + 1) - 1, G = z[K], $ = K + 1, dt = z[$]; if (0 > c(G, J)) $ < T && 0 > c(dt, G) ? (z[ft] = dt, z[$] = J, ft = $) : (z[ft] = G, z[K] = J, ft = K); else if ($ < T && 0 > c(dt, J)) z[ft] = dt, z[$] = J, ft = $; else break t } } return L } function c(z, L) { var J = z.sortIndex - L.sortIndex; return J !== 0 ? J : z.id - L.id } if (i.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var d = performance; i.unstable_now = function () { return d.now() } } else { var h = Date, g = h.now(); i.unstable_now = function () { return h.now() - g } } var y = [], m = [], v = 1, b = null, x = 3, V = !1, w = !1, U = !1, B = !1, q = typeof setTimeout == "function" ? setTimeout : null, Z = typeof clearTimeout == "function" ? clearTimeout : null, Y = typeof setImmediate < "u" ? setImmediate : null; function et(z) { for (var L = u(m); L !== null;) { if (L.callback === null) o(m); else if (L.startTime <= z) o(m), L.sortIndex = L.expirationTime, l(y, L); else break; L = u(m) } } function H(z) { if (U = !1, et(z), !w) if (u(y) !== null) w = !0, W || (W = !0, Ht()); else { var L = u(m); L !== null && qt(H, L.startTime - z) } } var W = !1, nt = -1, P = 5, yt = -1; function Ct() { return B ? !0 : !(i.unstable_now() - yt < P) } function Xt() { if (B = !1, W) { var z = i.unstable_now(); yt = z; var L = !0; try { t: { w = !1, U && (U = !1, Z(nt), nt = -1), V = !0; var J = x; try { e: { for (et(z), b = u(y); b !== null && !(b.expirationTime > z && Ct());) { var ft = b.callback; if (typeof ft == "function") { b.callback = null, x = b.priorityLevel; var T = ft(b.expirationTime <= z); if (z = i.unstable_now(), typeof T == "function") { b.callback = T, et(z), L = !0; break e } b === u(y) && o(y), et(z) } else o(y); b = u(y) } if (b !== null) L = !0; else { var j = u(m); j !== null && qt(H, j.startTime - z), L = !1 } } break t } finally { b = null, x = J, V = !1 } L = void 0 } } finally { L ? Ht() : W = !1 } } } var Ht; if (typeof Y == "function") Ht = function () { Y(Xt) }; else if (typeof MessageChannel < "u") { var Qe = new MessageChannel, je = Qe.port2; Qe.port1.onmessage = Xt, Ht = function () { je.postMessage(null) } } else Ht = function () { q(Xt, 0) }; function qt(z, L) { nt = q(function () { z(i.unstable_now()) }, L) } i.unstable_IdlePriority = 5, i.unstable_ImmediatePriority = 1, i.unstable_LowPriority = 4, i.unstable_NormalPriority = 3, i.unstable_Profiling = null, i.unstable_UserBlockingPriority = 2, i.unstable_cancelCallback = function (z) { z.callback = null }, i.unstable_forceFrameRate = function (z) { 0 > z || 125 < z ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < z ? Math.floor(1e3 / z) : 5 }, i.unstable_getCurrentPriorityLevel = function () { return x }, i.unstable_next = function (z) { switch (x) { case 1: case 2: case 3: var L = 3; break; default: L = x }var J = x; x = L; try { return z() } finally { x = J } }, i.unstable_requestPaint = function () { B = !0 }, i.unstable_runWithPriority = function (z, L) { switch (z) { case 1: case 2: case 3: case 4: case 5: break; default: z = 3 }var J = x; x = z; try { return L() } finally { x = J } }, i.unstable_scheduleCallback = function (z, L, J) { var ft = i.unstable_now(); switch (typeof J == "object" && J !== null ? (J = J.delay, J = typeof J == "number" && 0 < J ? ft + J : ft) : J = ft, z) { case 1: var T = -1; break; case 2: T = 250; break; case 5: T = 1073741823; break; case 4: T = 1e4; break; default: T = 5e3 }return T = J + T, z = { id: v++, callback: L, priorityLevel: z, startTime: J, expirationTime: T, sortIndex: -1 }, J > ft ? (z.sortIndex = J, l(m, z), u(y) === null && z === u(m) && (U ? (Z(nt), nt = -1) : U = !0, qt(H, J - ft))) : (z.sortIndex = T, l(y, z), w || V || (w = !0, W || (W = !0, Ht()))), z }, i.unstable_shouldYield = Ct, i.unstable_wrapCallback = function (z) { var L = x; return function () { var J = x; x = L; try { return z.apply(this, arguments) } finally { x = J } } } })(Er)), Er } var Ym; function f1() { return Ym || (Ym = 1, xr.exports = c1()), xr.exports } var Mr = { exports: {} }, te = {};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Gm; function h1() { if (Gm) return te; Gm = 1; var i = oc(); function l(y) { var m = "https://react.dev/errors/" + y; if (1 < arguments.length) { m += "?args[]=" + encodeURIComponent(arguments[1]); for (var v = 2; v < arguments.length; v++)m += "&args[]=" + encodeURIComponent(arguments[v]) } return "Minified React error #" + y + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function u() { } var o = { d: { f: u, r: function () { throw Error(l(522)) }, D: u, C: u, L: u, m: u, X: u, S: u, M: u }, p: 0, findDOMNode: null }, c = Symbol.for("react.portal"); function d(y, m, v) { var b = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: c, key: b == null ? null : "" + b, children: y, containerInfo: m, implementation: v } } var h = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function g(y, m) { if (y === "font") return ""; if (typeof m == "string") return m === "use-credentials" ? m : "" } return te.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = o, te.createPortal = function (y, m) { var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!m || m.nodeType !== 1 && m.nodeType !== 9 && m.nodeType !== 11) throw Error(l(299)); return d(y, m, null, v) }, te.flushSync = function (y) { var m = h.T, v = o.p; try { if (h.T = null, o.p = 2, y) return y() } finally { h.T = m, o.p = v, o.d.f() } }, te.preconnect = function (y, m) { typeof y == "string" && (m ? (m = m.crossOrigin, m = typeof m == "string" ? m === "use-credentials" ? m : "" : void 0) : m = null, o.d.C(y, m)) }, te.prefetchDNS = function (y) { typeof y == "string" && o.d.D(y) }, te.preinit = function (y, m) { if (typeof y == "string" && m && typeof m.as == "string") { var v = m.as, b = g(v, m.crossOrigin), x = typeof m.integrity == "string" ? m.integrity : void 0, V = typeof m.fetchPriority == "string" ? m.fetchPriority : void 0; v === "style" ? o.d.S(y, typeof m.precedence == "string" ? m.precedence : void 0, { crossOrigin: b, integrity: x, fetchPriority: V }) : v === "script" && o.d.X(y, { crossOrigin: b, integrity: x, fetchPriority: V, nonce: typeof m.nonce == "string" ? m.nonce : void 0 }) } }, te.preinitModule = function (y, m) { if (typeof y == "string") if (typeof m == "object" && m !== null) { if (m.as == null || m.as === "script") { var v = g(m.as, m.crossOrigin); o.d.M(y, { crossOrigin: v, integrity: typeof m.integrity == "string" ? m.integrity : void 0, nonce: typeof m.nonce == "string" ? m.nonce : void 0 }) } } else m == null && o.d.M(y) }, te.preload = function (y, m) { if (typeof y == "string" && typeof m == "object" && m !== null && typeof m.as == "string") { var v = m.as, b = g(v, m.crossOrigin); o.d.L(y, v, { crossOrigin: b, integrity: typeof m.integrity == "string" ? m.integrity : void 0, nonce: typeof m.nonce == "string" ? m.nonce : void 0, type: typeof m.type == "string" ? m.type : void 0, fetchPriority: typeof m.fetchPriority == "string" ? m.fetchPriority : void 0, referrerPolicy: typeof m.referrerPolicy == "string" ? m.referrerPolicy : void 0, imageSrcSet: typeof m.imageSrcSet == "string" ? m.imageSrcSet : void 0, imageSizes: typeof m.imageSizes == "string" ? m.imageSizes : void 0, media: typeof m.media == "string" ? m.media : void 0 }) } }, te.preloadModule = function (y, m) { if (typeof y == "string") if (m) { var v = g(m.as, m.crossOrigin); o.d.m(y, { as: typeof m.as == "string" && m.as !== "script" ? m.as : void 0, crossOrigin: v, integrity: typeof m.integrity == "string" ? m.integrity : void 0 }) } else o.d.m(y) }, te.requestFormReset = function (y) { o.d.r(y) }, te.unstable_batchedUpdates = function (y, m) { return y(m) }, te.useFormState = function (y, m, v) { return h.H.useFormState(y, m, v) }, te.useFormStatus = function () { return h.H.useHostTransitionStatus() }, te.version = "19.1.1", te } var Xm; function d1() { if (Xm) return Mr.exports; Xm = 1; function i() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i) } catch (l) { console.error(l) } } return i(), Mr.exports = h1(), Mr.exports }/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Zm; function m1() {
  if (Zm) return sl; Zm = 1; var i = f1(), l = oc(), u = d1(); function o(t) { var e = "https://react.dev/errors/" + t; if (1 < arguments.length) { e += "?args[]=" + encodeURIComponent(arguments[1]); for (var n = 2; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]) } return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function c(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function d(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, (e.flags & 4098) !== 0 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function h(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function g(t) { if (d(t) !== t) throw Error(o(188)) } function y(t) { var e = t.alternate; if (!e) { if (e = d(t), e === null) throw Error(o(188)); return e !== t ? null : t } for (var n = t, a = e; ;) { var s = n.return; if (s === null) break; var r = s.alternate; if (r === null) { if (a = s.return, a !== null) { n = a; continue } break } if (s.child === r.child) { for (r = s.child; r;) { if (r === n) return g(s), t; if (r === a) return g(s), e; r = r.sibling } throw Error(o(188)) } if (n.return !== a.return) n = s, a = r; else { for (var f = !1, p = s.child; p;) { if (p === n) { f = !0, n = s, a = r; break } if (p === a) { f = !0, a = s, n = r; break } p = p.sibling } if (!f) { for (p = r.child; p;) { if (p === n) { f = !0, n = r, a = s; break } if (p === a) { f = !0, a = r, n = s; break } p = p.sibling } if (!f) throw Error(o(189)) } } if (n.alternate !== a) throw Error(o(190)) } if (n.tag !== 3) throw Error(o(188)); return n.stateNode.current === n ? t : e } function m(t) { var e = t.tag; if (e === 5 || e === 26 || e === 27 || e === 6) return t; for (t = t.child; t !== null;) { if (e = m(t), e !== null) return e; t = t.sibling } return null } var v = Object.assign, b = Symbol.for("react.element"), x = Symbol.for("react.transitional.element"), V = Symbol.for("react.portal"), w = Symbol.for("react.fragment"), U = Symbol.for("react.strict_mode"), B = Symbol.for("react.profiler"), q = Symbol.for("react.provider"), Z = Symbol.for("react.consumer"), Y = Symbol.for("react.context"), et = Symbol.for("react.forward_ref"), H = Symbol.for("react.suspense"), W = Symbol.for("react.suspense_list"), nt = Symbol.for("react.memo"), P = Symbol.for("react.lazy"), yt = Symbol.for("react.activity"), Ct = Symbol.for("react.memo_cache_sentinel"), Xt = Symbol.iterator; function Ht(t) { return t === null || typeof t != "object" ? null : (t = Xt && t[Xt] || t["@@iterator"], typeof t == "function" ? t : null) } var Qe = Symbol.for("react.client.reference"); function je(t) { if (t == null) return null; if (typeof t == "function") return t.$$typeof === Qe ? null : t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case w: return "Fragment"; case B: return "Profiler"; case U: return "StrictMode"; case H: return "Suspense"; case W: return "SuspenseList"; case yt: return "Activity" }if (typeof t == "object") switch (t.$$typeof) { case V: return "Portal"; case Y: return (t.displayName || "Context") + ".Provider"; case Z: return (t._context.displayName || "Context") + ".Consumer"; case et: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case nt: return e = t.displayName || null, e !== null ? e : je(t.type) || "Memo"; case P: e = t._payload, t = t._init; try { return je(t(e)) } catch { } }return null } var qt = Array.isArray, z = l.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, L = u.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, J = { pending: !1, data: null, method: null, action: null }, ft = [], T = -1; function j(t) { return { current: t } } function K(t) { 0 > T || (t.current = ft[T], ft[T] = null, T--) } function G(t, e) { T++, ft[T] = t.current, t.current = e } var $ = j(null), dt = j(null), lt = j(null), ce = j(null); function Et(t, e) { switch (G(lt, e), G(dt, t), G($, null), e.nodeType) { case 9: case 11: t = (t = e.documentElement) && (t = t.namespaceURI) ? cm(t) : 0; break; default: if (t = e.tagName, e = e.namespaceURI) e = cm(e), t = fm(e, t); else switch (t) { case "svg": t = 1; break; case "math": t = 2; break; default: t = 0 } }K($), G($, t) } function hn() { K($), K(dt), K(lt) } function iu(t) { t.memoizedState !== null && G(ce, t); var e = $.current, n = fm(e, t.type); e !== n && (G(dt, t), G($, n)) } function El(t) { dt.current === t && (K($), K(dt)), ce.current === t && (K(ce), tl._currentValue = J) } var lu = Object.prototype.hasOwnProperty, su = i.unstable_scheduleCallback, uu = i.unstable_cancelCallback, Hg = i.unstable_shouldYield, qg = i.unstable_requestPaint, we = i.unstable_now, Yg = i.unstable_getCurrentPriorityLevel, Xc = i.unstable_ImmediatePriority, Zc = i.unstable_UserBlockingPriority, Ml = i.unstable_NormalPriority, Gg = i.unstable_LowPriority, Kc = i.unstable_IdlePriority, Xg = i.log, Zg = i.unstable_setDisableYieldValue, oi = null, fe = null; function dn(t) { if (typeof Xg == "function" && Zg(t), fe && typeof fe.setStrictMode == "function") try { fe.setStrictMode(oi, t) } catch { } } var he = Math.clz32 ? Math.clz32 : Jg, Kg = Math.log, Qg = Math.LN2; function Jg(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Kg(t) / Qg | 0) | 0 } var Dl = 256, Rl = 4194304; function Yn(t) { var e = t & 42; if (e !== 0) return e; switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: return 128; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194048; case 4194304: case 8388608: case 16777216: case 33554432: return t & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return t } } function Ol(t, e, n) { var a = t.pendingLanes; if (a === 0) return 0; var s = 0, r = t.suspendedLanes, f = t.pingedLanes; t = t.warmLanes; var p = a & 134217727; return p !== 0 ? (a = p & ~r, a !== 0 ? s = Yn(a) : (f &= p, f !== 0 ? s = Yn(f) : n || (n = p & ~t, n !== 0 && (s = Yn(n))))) : (p = a & ~r, p !== 0 ? s = Yn(p) : f !== 0 ? s = Yn(f) : n || (n = a & ~t, n !== 0 && (s = Yn(n)))), s === 0 ? 0 : e !== 0 && e !== s && (e & r) === 0 && (r = s & -s, n = e & -e, r >= n || r === 32 && (n & 4194048) !== 0) ? e : s } function ri(t, e) { return (t.pendingLanes & ~(t.suspendedLanes & ~t.pingedLanes) & e) === 0 } function kg(t, e) { switch (t) { case 1: case 2: case 4: case 8: case 64: return e + 250; case 16: case 32: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Qc() { var t = Dl; return Dl <<= 1, (Dl & 4194048) === 0 && (Dl = 256), t } function Jc() { var t = Rl; return Rl <<= 1, (Rl & 62914560) === 0 && (Rl = 4194304), t } function ou(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function ci(t, e) { t.pendingLanes |= e, e !== 268435456 && (t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0) } function Pg(t, e, n, a, s, r) { var f = t.pendingLanes; t.pendingLanes = n, t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0, t.expiredLanes &= n, t.entangledLanes &= n, t.errorRecoveryDisabledLanes &= n, t.shellSuspendCounter = 0; var p = t.entanglements, S = t.expirationTimes, D = t.hiddenUpdates; for (n = f & ~n; 0 < n;) { var C = 31 - he(n), _ = 1 << C; p[C] = 0, S[C] = -1; var R = D[C]; if (R !== null) for (D[C] = null, C = 0; C < R.length; C++) { var O = R[C]; O !== null && (O.lane &= -536870913) } n &= ~_ } a !== 0 && kc(t, a, 0), r !== 0 && s === 0 && t.tag !== 0 && (t.suspendedLanes |= r & ~(f & ~e)) } function kc(t, e, n) { t.pendingLanes |= e, t.suspendedLanes &= ~e; var a = 31 - he(e); t.entangledLanes |= e, t.entanglements[a] = t.entanglements[a] | 1073741824 | n & 4194090 } function Pc(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var a = 31 - he(n), s = 1 << a; s & e | t[a] & e && (t[a] |= e), n &= ~s } } function ru(t) { switch (t) { case 2: t = 1; break; case 8: t = 4; break; case 32: t = 16; break; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: t = 128; break; case 268435456: t = 134217728; break; default: t = 0 }return t } function cu(t) { return t &= -t, 2 < t ? 8 < t ? (t & 134217727) !== 0 ? 32 : 268435456 : 8 : 2 } function Fc() { var t = L.p; return t !== 0 ? t : (t = window.event, t === void 0 ? 32 : Vm(t.type)) } function Fg(t, e) { var n = L.p; try { return L.p = t, e() } finally { L.p = n } } var mn = Math.random().toString(36).slice(2), $t = "__reactFiber$" + mn, ie = "__reactProps$" + mn, fa = "__reactContainer$" + mn, fu = "__reactEvents$" + mn, Wg = "__reactListeners$" + mn, $g = "__reactHandles$" + mn, Wc = "__reactResources$" + mn, fi = "__reactMarker$" + mn; function hu(t) { delete t[$t], delete t[ie], delete t[fu], delete t[Wg], delete t[$g] } function ha(t) { var e = t[$t]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[fa] || n[$t]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = pm(t); t !== null;) { if (n = t[$t]) return n; t = pm(t) } return e } t = n, n = t.parentNode } return null } function da(t) { if (t = t[$t] || t[fa]) { var e = t.tag; if (e === 5 || e === 6 || e === 13 || e === 26 || e === 27 || e === 3) return t } return null } function hi(t) { var e = t.tag; if (e === 5 || e === 26 || e === 27 || e === 6) return t.stateNode; throw Error(o(33)) } function ma(t) { var e = t[Wc]; return e || (e = t[Wc] = { hoistableStyles: new Map, hoistableScripts: new Map }), e } function Zt(t) { t[fi] = !0 } var $c = new Set, Ic = {}; function Gn(t, e) { pa(t, e), pa(t + "Capture", e) } function pa(t, e) { for (Ic[t] = e, t = 0; t < e.length; t++)$c.add(e[t]) } var Ig = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), tf = {}, ef = {}; function t0(t) { return lu.call(ef, t) ? !0 : lu.call(tf, t) ? !1 : Ig.test(t) ? ef[t] = !0 : (tf[t] = !0, !1) } function Cl(t, e, n) { if (t0(e)) if (n === null) t.removeAttribute(e); else { switch (typeof n) { case "undefined": case "function": case "symbol": t.removeAttribute(e); return; case "boolean": var a = e.toLowerCase().slice(0, 5); if (a !== "data-" && a !== "aria-") { t.removeAttribute(e); return } }t.setAttribute(e, "" + n) } } function Vl(t, e, n) { if (n === null) t.removeAttribute(e); else { switch (typeof n) { case "undefined": case "function": case "symbol": case "boolean": t.removeAttribute(e); return }t.setAttribute(e, "" + n) } } function Je(t, e, n, a) { if (a === null) t.removeAttribute(n); else { switch (typeof a) { case "undefined": case "function": case "symbol": case "boolean": t.removeAttribute(n); return }t.setAttributeNS(e, n, "" + a) } } var du, nf; function ya(t) {
    if (du === void 0) try { throw Error() } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/); du = e && e[1] || "", nf = -1 < n.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < n.stack.indexOf("@") ? "@unknown:0:0" : ""
    } return `
`+ du + t + nf
  } var mu = !1; function pu(t, e) {
    if (!t || mu) return ""; mu = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
      var a = { DetermineComponentFrameRoot: function () { try { if (e) { var _ = function () { throw Error() }; if (Object.defineProperty(_.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(_, []) } catch (O) { var R = O } Reflect.construct(t, [], _) } else { try { _.call() } catch (O) { R = O } t.call(_.prototype) } } else { try { throw Error() } catch (O) { R = O } (_ = t()) && typeof _.catch == "function" && _.catch(function () { }) } } catch (O) { if (O && R && typeof O.stack == "string") return [O.stack, R.stack] } return [null, null] } }; a.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var s = Object.getOwnPropertyDescriptor(a.DetermineComponentFrameRoot, "name"); s && s.configurable && Object.defineProperty(a.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var r = a.DetermineComponentFrameRoot(), f = r[0], p = r[1]; if (f && p) {
        var S = f.split(`
`), D = p.split(`
`); for (s = a = 0; a < S.length && !S[a].includes("DetermineComponentFrameRoot");)a++; for (; s < D.length && !D[s].includes("DetermineComponentFrameRoot");)s++; if (a === S.length || s === D.length) for (a = S.length - 1, s = D.length - 1; 1 <= a && 0 <= s && S[a] !== D[s];)s--; for (; 1 <= a && 0 <= s; a--, s--)if (S[a] !== D[s]) {
          if (a !== 1 || s !== 1) do if (a--, s--, 0 > s || S[a] !== D[s]) {
            var C = `
`+ S[a].replace(" at new ", " at "); return t.displayName && C.includes("<anonymous>") && (C = C.replace("<anonymous>", t.displayName)), C
          } while (1 <= a && 0 <= s); break
        }
      }
    } finally { mu = !1, Error.prepareStackTrace = n } return (n = t ? t.displayName || t.name : "") ? ya(n) : ""
  } function e0(t) { switch (t.tag) { case 26: case 27: case 5: return ya(t.type); case 16: return ya("Lazy"); case 13: return ya("Suspense"); case 19: return ya("SuspenseList"); case 0: case 15: return pu(t.type, !1); case 11: return pu(t.type.render, !1); case 1: return pu(t.type, !0); case 31: return ya("Activity"); default: return "" } } function af(t) {
    try { var e = ""; do e += e0(t), t = t.return; while (t); return e } catch (n) {
      return `
Error generating stack: `+ n.message + `
`+ n.stack
    }
  } function be(t) { switch (typeof t) { case "bigint": case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function lf(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function n0(t) { var e = lf(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), a = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var s = n.get, r = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return s.call(this) }, set: function (f) { a = "" + f, r.call(this, f) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return a }, setValue: function (f) { a = "" + f }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function zl(t) { t._valueTracker || (t._valueTracker = n0(t)) } function sf(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), a = ""; return t && (a = lf(t) ? t.checked ? "true" : "false" : t.value), t = a, t !== n ? (e.setValue(t), !0) : !1 } function Nl(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } var a0 = /[\n"\\]/g; function Te(t) { return t.replace(a0, function (e) { return "\\" + e.charCodeAt(0).toString(16) + " " }) } function yu(t, e, n, a, s, r, f, p) { t.name = "", f != null && typeof f != "function" && typeof f != "symbol" && typeof f != "boolean" ? t.type = f : t.removeAttribute("type"), e != null ? f === "number" ? (e === 0 && t.value === "" || t.value != e) && (t.value = "" + be(e)) : t.value !== "" + be(e) && (t.value = "" + be(e)) : f !== "submit" && f !== "reset" || t.removeAttribute("value"), e != null ? gu(t, f, be(e)) : n != null ? gu(t, f, be(n)) : a != null && t.removeAttribute("value"), s == null && r != null && (t.defaultChecked = !!r), s != null && (t.checked = s && typeof s != "function" && typeof s != "symbol"), p != null && typeof p != "function" && typeof p != "symbol" && typeof p != "boolean" ? t.name = "" + be(p) : t.removeAttribute("name") } function uf(t, e, n, a, s, r, f, p) { if (r != null && typeof r != "function" && typeof r != "symbol" && typeof r != "boolean" && (t.type = r), e != null || n != null) { if (!(r !== "submit" && r !== "reset" || e != null)) return; n = n != null ? "" + be(n) : "", e = e != null ? "" + be(e) : n, p || e === t.value || (t.value = e), t.defaultValue = e } a = a ?? s, a = typeof a != "function" && typeof a != "symbol" && !!a, t.checked = p ? t.checked : !!a, t.defaultChecked = !!a, f != null && typeof f != "function" && typeof f != "symbol" && typeof f != "boolean" && (t.name = f) } function gu(t, e, n) { e === "number" && Nl(t.ownerDocument) === t || t.defaultValue === "" + n || (t.defaultValue = "" + n) } function ga(t, e, n, a) { if (t = t.options, e) { e = {}; for (var s = 0; s < n.length; s++)e["$" + n[s]] = !0; for (n = 0; n < t.length; n++)s = e.hasOwnProperty("$" + t[n].value), t[n].selected !== s && (t[n].selected = s), s && a && (t[n].defaultSelected = !0) } else { for (n = "" + be(n), e = null, s = 0; s < t.length; s++) { if (t[s].value === n) { t[s].selected = !0, a && (t[s].defaultSelected = !0); return } e !== null || t[s].disabled || (e = t[s]) } e !== null && (e.selected = !0) } } function of(t, e, n) { if (e != null && (e = "" + be(e), e !== t.value && (t.value = e), n == null)) { t.defaultValue !== e && (t.defaultValue = e); return } t.defaultValue = n != null ? "" + be(n) : "" } function rf(t, e, n, a) { if (e == null) { if (a != null) { if (n != null) throw Error(o(92)); if (qt(a)) { if (1 < a.length) throw Error(o(93)); a = a[0] } n = a } n == null && (n = ""), e = n } n = be(e), t.defaultValue = n, a = t.textContent, a === n && a !== "" && a !== null && (t.value = a) } function va(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var i0 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function cf(t, e, n) { var a = e.indexOf("--") === 0; n == null || typeof n == "boolean" || n === "" ? a ? t.setProperty(e, "") : e === "float" ? t.cssFloat = "" : t[e] = "" : a ? t.setProperty(e, n) : typeof n != "number" || n === 0 || i0.has(e) ? e === "float" ? t.cssFloat = n : t[e] = ("" + n).trim() : t[e] = n + "px" } function ff(t, e, n) { if (e != null && typeof e != "object") throw Error(o(62)); if (t = t.style, n != null) { for (var a in n) !n.hasOwnProperty(a) || e != null && e.hasOwnProperty(a) || (a.indexOf("--") === 0 ? t.setProperty(a, "") : a === "float" ? t.cssFloat = "" : t[a] = ""); for (var s in e) a = e[s], e.hasOwnProperty(s) && n[s] !== a && cf(t, s, a) } else for (var r in e) e.hasOwnProperty(r) && cf(t, r, e[r]) } function vu(t) { if (t.indexOf("-") === -1) return !1; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var l0 = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), s0 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function Ul(t) { return s0.test("" + t) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : t } var Su = null; function bu(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var Sa = null, ba = null; function hf(t) { var e = da(t); if (e && (t = e.stateNode)) { var n = t[ie] || null; t: switch (t = e.stateNode, e.type) { case "input": if (yu(t, n.value, n.defaultValue, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll('input[name="' + Te("" + e) + '"][type="radio"]'), e = 0; e < n.length; e++) { var a = n[e]; if (a !== t && a.form === t.form) { var s = a[ie] || null; if (!s) throw Error(o(90)); yu(a, s.value, s.defaultValue, s.defaultValue, s.checked, s.defaultChecked, s.type, s.name) } } for (e = 0; e < n.length; e++)a = n[e], a.form === t.form && sf(a) } break t; case "textarea": of(t, n.value, n.defaultValue); break t; case "select": e = n.value, e != null && ga(t, !!n.multiple, e, !1) } } } var Tu = !1; function df(t, e, n) { if (Tu) return t(e, n); Tu = !0; try { var a = t(e); return a } finally { if (Tu = !1, (Sa !== null || ba !== null) && (vs(), Sa && (e = Sa, t = ba, ba = Sa = null, hf(e), t))) for (e = 0; e < t.length; e++)hf(t[e]) } } function di(t, e) { var n = t.stateNode; if (n === null) return null; var a = n[ie] || null; if (a === null) return null; n = a[e]; t: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (a = !a.disabled) || (t = t.type, a = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !a; break t; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(o(231, e, typeof n)); return n } var ke = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Au = !1; if (ke) try { var mi = {}; Object.defineProperty(mi, "passive", { get: function () { Au = !0 } }), window.addEventListener("test", mi, mi), window.removeEventListener("test", mi, mi) } catch { Au = !1 } var pn = null, xu = null, _l = null; function mf() { if (_l) return _l; var t, e = xu, n = e.length, a, s = "value" in pn ? pn.value : pn.textContent, r = s.length; for (t = 0; t < n && e[t] === s[t]; t++); var f = n - t; for (a = 1; a <= f && e[n - a] === s[r - a]; a++); return _l = s.slice(t, 1 < a ? 1 - a : void 0) } function Bl(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function jl() { return !0 } function pf() { return !1 } function le(t) { function e(n, a, s, r, f) { this._reactName = n, this._targetInst = s, this.type = a, this.nativeEvent = r, this.target = f, this.currentTarget = null; for (var p in t) t.hasOwnProperty(p) && (n = t[p], this[p] = n ? n(r) : r[p]); return this.isDefaultPrevented = (r.defaultPrevented != null ? r.defaultPrevented : r.returnValue === !1) ? jl : pf, this.isPropagationStopped = pf, this } return v(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = jl) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = jl) }, persist: function () { }, isPersistent: jl }), e } var Xn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, wl = le(Xn), pi = v({}, Xn, { view: 0, detail: 0 }), u0 = le(pi), Eu, Mu, yi, Ll = v({}, pi, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ru, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== yi && (yi && t.type === "mousemove" ? (Eu = t.screenX - yi.screenX, Mu = t.screenY - yi.screenY) : Mu = Eu = 0, yi = t), Eu) }, movementY: function (t) { return "movementY" in t ? t.movementY : Mu } }), yf = le(Ll), o0 = v({}, Ll, { dataTransfer: 0 }), r0 = le(o0), c0 = v({}, pi, { relatedTarget: 0 }), Du = le(c0), f0 = v({}, Xn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), h0 = le(f0), d0 = v({}, Xn, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), m0 = le(d0), p0 = v({}, Xn, { data: 0 }), gf = le(p0), y0 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, g0 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, v0 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function S0(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = v0[t]) ? !!e[t] : !1 } function Ru() { return S0 } var b0 = v({}, pi, { key: function (t) { if (t.key) { var e = y0[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = Bl(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? g0[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ru, charCode: function (t) { return t.type === "keypress" ? Bl(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? Bl(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), T0 = le(b0), A0 = v({}, Ll, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), vf = le(A0), x0 = v({}, pi, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ru }), E0 = le(x0), M0 = v({}, Xn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), D0 = le(M0), R0 = v({}, Ll, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), O0 = le(R0), C0 = v({}, Xn, { newState: 0, oldState: 0 }), V0 = le(C0), z0 = [9, 13, 27, 32], Ou = ke && "CompositionEvent" in window, gi = null; ke && "documentMode" in document && (gi = document.documentMode); var N0 = ke && "TextEvent" in window && !gi, Sf = ke && (!Ou || gi && 8 < gi && 11 >= gi), bf = " ", Tf = !1; function Af(t, e) { switch (t) { case "keyup": return z0.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function xf(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var Ta = !1; function U0(t, e) { switch (t) { case "compositionend": return xf(e); case "keypress": return e.which !== 32 ? null : (Tf = !0, bf); case "textInput": return t = e.data, t === bf && Tf ? null : t; default: return null } } function _0(t, e) { if (Ta) return t === "compositionend" || !Ou && Af(t, e) ? (t = mf(), _l = xu = pn = null, Ta = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return Sf && e.locale !== "ko" ? null : e.data; default: return null } } var B0 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Ef(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!B0[t.type] : e === "textarea" } function Mf(t, e, n, a) { Sa ? ba ? ba.push(a) : ba = [a] : Sa = a, e = Es(e, "onChange"), 0 < e.length && (n = new wl("onChange", "change", null, n, a), t.push({ event: n, listeners: e })) } var vi = null, Si = null; function j0(t) { lm(t, 0) } function Hl(t) { var e = hi(t); if (sf(e)) return t } function Df(t, e) { if (t === "change") return e } var Rf = !1; if (ke) { var Cu; if (ke) { var Vu = "oninput" in document; if (!Vu) { var Of = document.createElement("div"); Of.setAttribute("oninput", "return;"), Vu = typeof Of.oninput == "function" } Cu = Vu } else Cu = !1; Rf = Cu && (!document.documentMode || 9 < document.documentMode) } function Cf() { vi && (vi.detachEvent("onpropertychange", Vf), Si = vi = null) } function Vf(t) { if (t.propertyName === "value" && Hl(Si)) { var e = []; Mf(e, Si, t, bu(t)), df(j0, e) } } function w0(t, e, n) { t === "focusin" ? (Cf(), vi = e, Si = n, vi.attachEvent("onpropertychange", Vf)) : t === "focusout" && Cf() } function L0(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return Hl(Si) } function H0(t, e) { if (t === "click") return Hl(e) } function q0(t, e) { if (t === "input" || t === "change") return Hl(e) } function Y0(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var de = typeof Object.is == "function" ? Object.is : Y0; function bi(t, e) { if (de(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), a = Object.keys(e); if (n.length !== a.length) return !1; for (a = 0; a < n.length; a++) { var s = n[a]; if (!lu.call(e, s) || !de(t[s], e[s])) return !1 } return !0 } function zf(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function Nf(t, e) { var n = zf(t); t = 0; for (var a; n;) { if (n.nodeType === 3) { if (a = t + n.textContent.length, t <= e && a >= e) return { node: n, offset: e - t }; t = a } t: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break t } n = n.parentNode } n = void 0 } n = zf(n) } } function Uf(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Uf(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function _f(t) { t = t != null && t.ownerDocument != null && t.ownerDocument.defaultView != null ? t.ownerDocument.defaultView : window; for (var e = Nl(t.document); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = Nl(t.document) } return e } function zu(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } var G0 = ke && "documentMode" in document && 11 >= document.documentMode, Aa = null, Nu = null, Ti = null, Uu = !1; function Bf(t, e, n) { var a = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Uu || Aa == null || Aa !== Nl(a) || (a = Aa, "selectionStart" in a && zu(a) ? a = { start: a.selectionStart, end: a.selectionEnd } : (a = (a.ownerDocument && a.ownerDocument.defaultView || window).getSelection(), a = { anchorNode: a.anchorNode, anchorOffset: a.anchorOffset, focusNode: a.focusNode, focusOffset: a.focusOffset }), Ti && bi(Ti, a) || (Ti = a, a = Es(Nu, "onSelect"), 0 < a.length && (e = new wl("onSelect", "select", null, e, n), t.push({ event: e, listeners: a }), e.target = Aa))) } function Zn(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var xa = { animationend: Zn("Animation", "AnimationEnd"), animationiteration: Zn("Animation", "AnimationIteration"), animationstart: Zn("Animation", "AnimationStart"), transitionrun: Zn("Transition", "TransitionRun"), transitionstart: Zn("Transition", "TransitionStart"), transitioncancel: Zn("Transition", "TransitionCancel"), transitionend: Zn("Transition", "TransitionEnd") }, _u = {}, jf = {}; ke && (jf = document.createElement("div").style, "AnimationEvent" in window || (delete xa.animationend.animation, delete xa.animationiteration.animation, delete xa.animationstart.animation), "TransitionEvent" in window || delete xa.transitionend.transition); function Kn(t) { if (_u[t]) return _u[t]; if (!xa[t]) return t; var e = xa[t], n; for (n in e) if (e.hasOwnProperty(n) && n in jf) return _u[t] = e[n]; return t } var wf = Kn("animationend"), Lf = Kn("animationiteration"), Hf = Kn("animationstart"), X0 = Kn("transitionrun"), Z0 = Kn("transitionstart"), K0 = Kn("transitioncancel"), qf = Kn("transitionend"), Yf = new Map, Bu = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); Bu.push("scrollEnd"); function Ne(t, e) { Yf.set(t, e), Gn(e, [t]) } var Gf = new WeakMap; function Ae(t, e) { if (typeof t == "object" && t !== null) { var n = Gf.get(t); return n !== void 0 ? n : (e = { value: t, source: e, stack: af(e) }, Gf.set(t, e), e) } return { value: t, source: e, stack: af(e) } } var xe = [], Ea = 0, ju = 0; function ql() { for (var t = Ea, e = ju = Ea = 0; e < t;) { var n = xe[e]; xe[e++] = null; var a = xe[e]; xe[e++] = null; var s = xe[e]; xe[e++] = null; var r = xe[e]; if (xe[e++] = null, a !== null && s !== null) { var f = a.pending; f === null ? s.next = s : (s.next = f.next, f.next = s), a.pending = s } r !== 0 && Xf(n, s, r) } } function Yl(t, e, n, a) { xe[Ea++] = t, xe[Ea++] = e, xe[Ea++] = n, xe[Ea++] = a, ju |= a, t.lanes |= a, t = t.alternate, t !== null && (t.lanes |= a) } function wu(t, e, n, a) { return Yl(t, e, n, a), Gl(t) } function Ma(t, e) { return Yl(t, null, null, e), Gl(t) } function Xf(t, e, n) { t.lanes |= n; var a = t.alternate; a !== null && (a.lanes |= n); for (var s = !1, r = t.return; r !== null;)r.childLanes |= n, a = r.alternate, a !== null && (a.childLanes |= n), r.tag === 22 && (t = r.stateNode, t === null || t._visibility & 1 || (s = !0)), t = r, r = r.return; return t.tag === 3 ? (r = t.stateNode, s && e !== null && (s = 31 - he(n), t = r.hiddenUpdates, a = t[s], a === null ? t[s] = [e] : a.push(e), e.lane = n | 536870912), r) : null } function Gl(t) { if (50 < Qi) throw Qi = 0, Zo = null, Error(o(185)); for (var e = t.return; e !== null;)t = e, e = t.return; return t.tag === 3 ? t.stateNode : null } var Da = {}; function Q0(t, e, n, a) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = a, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function me(t, e, n, a) { return new Q0(t, e, n, a) } function Lu(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function Pe(t, e) { var n = t.alternate; return n === null ? (n = me(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 65011712, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n.refCleanup = t.refCleanup, n } function Zf(t, e) { t.flags &= 65011714; var n = t.alternate; return n === null ? (t.childLanes = 0, t.lanes = e, t.child = null, t.subtreeFlags = 0, t.memoizedProps = null, t.memoizedState = null, t.updateQueue = null, t.dependencies = null, t.stateNode = null) : (t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.subtreeFlags = 0, t.deletions = null, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, t.type = n.type, e = n.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), t } function Xl(t, e, n, a, s, r) { var f = 0; if (a = t, typeof t == "function") Lu(t) && (f = 1); else if (typeof t == "string") f = kv(t, n, $.current) ? 26 : t === "html" || t === "head" || t === "body" ? 27 : 5; else t: switch (t) { case yt: return t = me(31, n, e, s), t.elementType = yt, t.lanes = r, t; case w: return Qn(n.children, s, r, e); case U: f = 8, s |= 24; break; case B: return t = me(12, n, e, s | 2), t.elementType = B, t.lanes = r, t; case H: return t = me(13, n, e, s), t.elementType = H, t.lanes = r, t; case W: return t = me(19, n, e, s), t.elementType = W, t.lanes = r, t; default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case q: case Y: f = 10; break t; case Z: f = 9; break t; case et: f = 11; break t; case nt: f = 14; break t; case P: f = 16, a = null; break t }f = 29, n = Error(o(130, t === null ? "null" : typeof t, "")), a = null }return e = me(f, n, e, s), e.elementType = t, e.type = a, e.lanes = r, e } function Qn(t, e, n, a) { return t = me(7, t, a, e), t.lanes = n, t } function Hu(t, e, n) { return t = me(6, t, null, e), t.lanes = n, t } function qu(t, e, n) { return e = me(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } var Ra = [], Oa = 0, Zl = null, Kl = 0, Ee = [], Me = 0, Jn = null, Fe = 1, We = ""; function kn(t, e) { Ra[Oa++] = Kl, Ra[Oa++] = Zl, Zl = t, Kl = e } function Kf(t, e, n) { Ee[Me++] = Fe, Ee[Me++] = We, Ee[Me++] = Jn, Jn = t; var a = Fe; t = We; var s = 32 - he(a) - 1; a &= ~(1 << s), n += 1; var r = 32 - he(e) + s; if (30 < r) { var f = s - s % 5; r = (a & (1 << f) - 1).toString(32), a >>= f, s -= f, Fe = 1 << 32 - he(e) + s | n << s | a, We = r + t } else Fe = 1 << r | n << s | a, We = t } function Yu(t) { t.return !== null && (kn(t, 1), Kf(t, 1, 0)) } function Gu(t) { for (; t === Zl;)Zl = Ra[--Oa], Ra[Oa] = null, Kl = Ra[--Oa], Ra[Oa] = null; for (; t === Jn;)Jn = Ee[--Me], Ee[Me] = null, We = Ee[--Me], Ee[Me] = null, Fe = Ee[--Me], Ee[Me] = null } var ne = null, Vt = null, pt = !1, Pn = null, Le = !1, Xu = Error(o(519)); function Fn(t) { var e = Error(o(418, "")); throw Ei(Ae(e, t)), Xu } function Qf(t) { var e = t.stateNode, n = t.type, a = t.memoizedProps; switch (e[$t] = t, e[ie] = a, n) { case "dialog": ct("cancel", e), ct("close", e); break; case "iframe": case "object": case "embed": ct("load", e); break; case "video": case "audio": for (n = 0; n < ki.length; n++)ct(ki[n], e); break; case "source": ct("error", e); break; case "img": case "image": case "link": ct("error", e), ct("load", e); break; case "details": ct("toggle", e); break; case "input": ct("invalid", e), uf(e, a.value, a.defaultValue, a.checked, a.defaultChecked, a.type, a.name, !0), zl(e); break; case "select": ct("invalid", e); break; case "textarea": ct("invalid", e), rf(e, a.value, a.defaultValue, a.children), zl(e) }n = a.children, typeof n != "string" && typeof n != "number" && typeof n != "bigint" || e.textContent === "" + n || a.suppressHydrationWarning === !0 || rm(e.textContent, n) ? (a.popover != null && (ct("beforetoggle", e), ct("toggle", e)), a.onScroll != null && ct("scroll", e), a.onScrollEnd != null && ct("scrollend", e), a.onClick != null && (e.onclick = Ms), e = !0) : e = !1, e || Fn(t) } function Jf(t) { for (ne = t.return; ne;)switch (ne.tag) { case 5: case 13: Le = !1; return; case 27: case 3: Le = !0; return; default: ne = ne.return } } function Ai(t) { if (t !== ne) return !1; if (!pt) return Jf(t), pt = !0, !1; var e = t.tag, n; if ((n = e !== 3 && e !== 27) && ((n = e === 5) && (n = t.type, n = !(n !== "form" && n !== "button") || sr(t.type, t.memoizedProps)), n = !n), n && Vt && Fn(t), Jf(t), e === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(o(317)); t: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) if (n = t.data, n === "/$") { if (e === 0) { Vt = _e(t.nextSibling); break t } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++; t = t.nextSibling } Vt = null } } else e === 27 ? (e = Vt, zn(t.type) ? (t = cr, cr = null, Vt = t) : Vt = e) : Vt = ne ? _e(t.stateNode.nextSibling) : null; return !0 } function xi() { Vt = ne = null, pt = !1 } function kf() { var t = Pn; return t !== null && (oe === null ? oe = t : oe.push.apply(oe, t), Pn = null), t } function Ei(t) { Pn === null ? Pn = [t] : Pn.push(t) } var Zu = j(null), Wn = null, $e = null; function yn(t, e, n) { G(Zu, e._currentValue), e._currentValue = n } function Ie(t) { t._currentValue = Zu.current, K(Zu) } function Ku(t, e, n) { for (; t !== null;) { var a = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, a !== null && (a.childLanes |= e)) : a !== null && (a.childLanes & e) !== e && (a.childLanes |= e), t === n) break; t = t.return } } function Qu(t, e, n, a) { var s = t.child; for (s !== null && (s.return = t); s !== null;) { var r = s.dependencies; if (r !== null) { var f = s.child; r = r.firstContext; t: for (; r !== null;) { var p = r; r = s; for (var S = 0; S < e.length; S++)if (p.context === e[S]) { r.lanes |= n, p = r.alternate, p !== null && (p.lanes |= n), Ku(r.return, n, t), a || (f = null); break t } r = p.next } } else if (s.tag === 18) { if (f = s.return, f === null) throw Error(o(341)); f.lanes |= n, r = f.alternate, r !== null && (r.lanes |= n), Ku(f, n, t), f = null } else f = s.child; if (f !== null) f.return = s; else for (f = s; f !== null;) { if (f === t) { f = null; break } if (s = f.sibling, s !== null) { s.return = f.return, f = s; break } f = f.return } s = f } } function Mi(t, e, n, a) { t = null; for (var s = e, r = !1; s !== null;) { if (!r) { if ((s.flags & 524288) !== 0) r = !0; else if ((s.flags & 262144) !== 0) break } if (s.tag === 10) { var f = s.alternate; if (f === null) throw Error(o(387)); if (f = f.memoizedProps, f !== null) { var p = s.type; de(s.pendingProps.value, f.value) || (t !== null ? t.push(p) : t = [p]) } } else if (s === ce.current) { if (f = s.alternate, f === null) throw Error(o(387)); f.memoizedState.memoizedState !== s.memoizedState.memoizedState && (t !== null ? t.push(tl) : t = [tl]) } s = s.return } t !== null && Qu(e, t, n, a), e.flags |= 262144 } function Ql(t) { for (t = t.firstContext; t !== null;) { if (!de(t.context._currentValue, t.memoizedValue)) return !0; t = t.next } return !1 } function $n(t) { Wn = t, $e = null, t = t.dependencies, t !== null && (t.firstContext = null) } function It(t) { return Pf(Wn, t) } function Jl(t, e) { return Wn === null && $n(t), Pf(t, e) } function Pf(t, e) { var n = e._currentValue; if (e = { context: e, memoizedValue: n, next: null }, $e === null) { if (t === null) throw Error(o(308)); $e = e, t.dependencies = { lanes: 0, firstContext: e }, t.flags |= 524288 } else $e = $e.next = e; return n } var J0 = typeof AbortController < "u" ? AbortController : function () { var t = [], e = this.signal = { aborted: !1, addEventListener: function (n, a) { t.push(a) } }; this.abort = function () { e.aborted = !0, t.forEach(function (n) { return n() }) } }, k0 = i.unstable_scheduleCallback, P0 = i.unstable_NormalPriority, Yt = { $$typeof: Y, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function Ju() { return { controller: new J0, data: new Map, refCount: 0 } } function Di(t) { t.refCount--, t.refCount === 0 && k0(P0, function () { t.controller.abort() }) } var Ri = null, ku = 0, Ca = 0, Va = null; function F0(t, e) { if (Ri === null) { var n = Ri = []; ku = 0, Ca = Wo(), Va = { status: "pending", value: void 0, then: function (a) { n.push(a) } } } return ku++, e.then(Ff, Ff), e } function Ff() { if (--ku === 0 && Ri !== null) { Va !== null && (Va.status = "fulfilled"); var t = Ri; Ri = null, Ca = 0, Va = null; for (var e = 0; e < t.length; e++)(0, t[e])() } } function W0(t, e) { var n = [], a = { status: "pending", value: null, reason: null, then: function (s) { n.push(s) } }; return t.then(function () { a.status = "fulfilled", a.value = e; for (var s = 0; s < n.length; s++)(0, n[s])(e) }, function (s) { for (a.status = "rejected", a.reason = s, s = 0; s < n.length; s++)(0, n[s])(void 0) }), a } var Wf = z.S; z.S = function (t, e) { typeof e == "object" && e !== null && typeof e.then == "function" && F0(t, e), Wf !== null && Wf(t, e) }; var In = j(null); function Pu() { var t = In.current; return t !== null ? t : xt.pooledCache } function kl(t, e) { e === null ? G(In, In.current) : G(In, e.pool) } function $f() { var t = Pu(); return t === null ? null : { parent: Yt._currentValue, pool: t } } var Oi = Error(o(460)), If = Error(o(474)), Pl = Error(o(542)), Fu = { then: function () { } }; function th(t) { return t = t.status, t === "fulfilled" || t === "rejected" } function Fl() { } function eh(t, e, n) { switch (n = t[n], n === void 0 ? t.push(e) : n !== e && (e.then(Fl, Fl), e = n), e.status) { case "fulfilled": return e.value; case "rejected": throw t = e.reason, ah(t), t; default: if (typeof e.status == "string") e.then(Fl, Fl); else { if (t = xt, t !== null && 100 < t.shellSuspendCounter) throw Error(o(482)); t = e, t.status = "pending", t.then(function (a) { if (e.status === "pending") { var s = e; s.status = "fulfilled", s.value = a } }, function (a) { if (e.status === "pending") { var s = e; s.status = "rejected", s.reason = a } }) } switch (e.status) { case "fulfilled": return e.value; case "rejected": throw t = e.reason, ah(t), t }throw Ci = e, Oi } } var Ci = null; function nh() { if (Ci === null) throw Error(o(459)); var t = Ci; return Ci = null, t } function ah(t) { if (t === Oi || t === Pl) throw Error(o(483)) } var gn = !1; function Wu(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function $u(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, callbacks: null }) } function vn(t) { return { lane: t, tag: 0, payload: null, callback: null, next: null } } function Sn(t, e, n) { var a = t.updateQueue; if (a === null) return null; if (a = a.shared, (gt & 2) !== 0) { var s = a.pending; return s === null ? e.next = e : (e.next = s.next, s.next = e), a.pending = e, e = Gl(t), Xf(t, null, n), e } return Yl(t, a, e, n), Gl(t) } function Vi(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194048) !== 0)) { var a = e.lanes; a &= t.pendingLanes, n |= a, e.lanes = n, Pc(t, n) } } function Iu(t, e) { var n = t.updateQueue, a = t.alternate; if (a !== null && (a = a.updateQueue, n === a)) { var s = null, r = null; if (n = n.firstBaseUpdate, n !== null) { do { var f = { lane: n.lane, tag: n.tag, payload: n.payload, callback: null, next: null }; r === null ? s = r = f : r = r.next = f, n = n.next } while (n !== null); r === null ? s = r = e : r = r.next = e } else s = r = e; n = { baseState: a.baseState, firstBaseUpdate: s, lastBaseUpdate: r, shared: a.shared, callbacks: a.callbacks }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } var to = !1; function zi() { if (to) { var t = Va; if (t !== null) throw t } } function Ni(t, e, n, a) { to = !1; var s = t.updateQueue; gn = !1; var r = s.firstBaseUpdate, f = s.lastBaseUpdate, p = s.shared.pending; if (p !== null) { s.shared.pending = null; var S = p, D = S.next; S.next = null, f === null ? r = D : f.next = D, f = S; var C = t.alternate; C !== null && (C = C.updateQueue, p = C.lastBaseUpdate, p !== f && (p === null ? C.firstBaseUpdate = D : p.next = D, C.lastBaseUpdate = S)) } if (r !== null) { var _ = s.baseState; f = 0, C = D = S = null, p = r; do { var R = p.lane & -536870913, O = R !== p.lane; if (O ? (ht & R) === R : (a & R) === R) { R !== 0 && R === Ca && (to = !0), C !== null && (C = C.next = { lane: 0, tag: p.tag, payload: p.payload, callback: null, next: null }); t: { var at = t, I = p; R = e; var Tt = n; switch (I.tag) { case 1: if (at = I.payload, typeof at == "function") { _ = at.call(Tt, _, R); break t } _ = at; break t; case 3: at.flags = at.flags & -65537 | 128; case 0: if (at = I.payload, R = typeof at == "function" ? at.call(Tt, _, R) : at, R == null) break t; _ = v({}, _, R); break t; case 2: gn = !0 } } R = p.callback, R !== null && (t.flags |= 64, O && (t.flags |= 8192), O = s.callbacks, O === null ? s.callbacks = [R] : O.push(R)) } else O = { lane: R, tag: p.tag, payload: p.payload, callback: p.callback, next: null }, C === null ? (D = C = O, S = _) : C = C.next = O, f |= R; if (p = p.next, p === null) { if (p = s.shared.pending, p === null) break; O = p, p = O.next, O.next = null, s.lastBaseUpdate = O, s.shared.pending = null } } while (!0); C === null && (S = _), s.baseState = S, s.firstBaseUpdate = D, s.lastBaseUpdate = C, r === null && (s.shared.lanes = 0), Rn |= f, t.lanes = f, t.memoizedState = _ } } function ih(t, e) { if (typeof t != "function") throw Error(o(191, t)); t.call(e) } function lh(t, e) { var n = t.callbacks; if (n !== null) for (t.callbacks = null, t = 0; t < n.length; t++)ih(n[t], e) } var za = j(null), Wl = j(0); function sh(t, e) { t = un, G(Wl, t), G(za, e), un = t | e.baseLanes } function eo() { G(Wl, un), G(za, za.current) } function no() { un = Wl.current, K(za), K(Wl) } var bn = 0, ut = null, St = null, jt = null, $l = !1, Na = !1, ta = !1, Il = 0, Ui = 0, Ua = null, $0 = 0; function Ut() { throw Error(o(321)) } function ao(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!de(t[n], e[n])) return !1; return !0 } function io(t, e, n, a, s, r) { return bn = r, ut = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, z.H = t === null || t.memoizedState === null ? Xh : Zh, ta = !1, r = n(a, s), ta = !1, Na && (r = oh(e, n, a, s)), uh(t), r } function uh(t) { z.H = ls; var e = St !== null && St.next !== null; if (bn = 0, jt = St = ut = null, $l = !1, Ui = 0, Ua = null, e) throw Error(o(300)); t === null || Kt || (t = t.dependencies, t !== null && Ql(t) && (Kt = !0)) } function oh(t, e, n, a) { ut = t; var s = 0; do { if (Na && (Ua = null), Ui = 0, Na = !1, 25 <= s) throw Error(o(301)); if (s += 1, jt = St = null, t.updateQueue != null) { var r = t.updateQueue; r.lastEffect = null, r.events = null, r.stores = null, r.memoCache != null && (r.memoCache.index = 0) } z.H = lv, r = e(n, a) } while (Na); return r } function I0() { var t = z.H, e = t.useState()[0]; return e = typeof e.then == "function" ? _i(e) : e, t = t.useState()[0], (St !== null ? St.memoizedState : null) !== t && (ut.flags |= 1024), e } function lo() { var t = Il !== 0; return Il = 0, t } function so(t, e, n) { e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~n } function uo(t) { if ($l) { for (t = t.memoizedState; t !== null;) { var e = t.queue; e !== null && (e.pending = null), t = t.next } $l = !1 } bn = 0, jt = St = ut = null, Na = !1, Ui = Il = 0, Ua = null } function se() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return jt === null ? ut.memoizedState = jt = t : jt = jt.next = t, jt } function wt() { if (St === null) { var t = ut.alternate; t = t !== null ? t.memoizedState : null } else t = St.next; var e = jt === null ? ut.memoizedState : jt.next; if (e !== null) jt = e, St = t; else { if (t === null) throw ut.alternate === null ? Error(o(467)) : Error(o(310)); St = t, t = { memoizedState: St.memoizedState, baseState: St.baseState, baseQueue: St.baseQueue, queue: St.queue, next: null }, jt === null ? ut.memoizedState = jt = t : jt = jt.next = t } return jt } function oo() { return { lastEffect: null, events: null, stores: null, memoCache: null } } function _i(t) { var e = Ui; return Ui += 1, Ua === null && (Ua = []), t = eh(Ua, t, e), e = ut, (jt === null ? e.memoizedState : jt.next) === null && (e = e.alternate, z.H = e === null || e.memoizedState === null ? Xh : Zh), t } function ts(t) { if (t !== null && typeof t == "object") { if (typeof t.then == "function") return _i(t); if (t.$$typeof === Y) return It(t) } throw Error(o(438, String(t))) } function ro(t) { var e = null, n = ut.updateQueue; if (n !== null && (e = n.memoCache), e == null) { var a = ut.alternate; a !== null && (a = a.updateQueue, a !== null && (a = a.memoCache, a != null && (e = { data: a.data.map(function (s) { return s.slice() }), index: 0 }))) } if (e == null && (e = { data: [], index: 0 }), n === null && (n = oo(), ut.updateQueue = n), n.memoCache = e, n = e.data[e.index], n === void 0) for (n = e.data[e.index] = Array(t), a = 0; a < t; a++)n[a] = Ct; return e.index++, n } function tn(t, e) { return typeof e == "function" ? e(t) : e } function es(t) { var e = wt(); return co(e, St, t) } function co(t, e, n) { var a = t.queue; if (a === null) throw Error(o(311)); a.lastRenderedReducer = n; var s = t.baseQueue, r = a.pending; if (r !== null) { if (s !== null) { var f = s.next; s.next = r.next, r.next = f } e.baseQueue = s = r, a.pending = null } if (r = t.baseState, s === null) t.memoizedState = r; else { e = s.next; var p = f = null, S = null, D = e, C = !1; do { var _ = D.lane & -536870913; if (_ !== D.lane ? (ht & _) === _ : (bn & _) === _) { var R = D.revertLane; if (R === 0) S !== null && (S = S.next = { lane: 0, revertLane: 0, action: D.action, hasEagerState: D.hasEagerState, eagerState: D.eagerState, next: null }), _ === Ca && (C = !0); else if ((bn & R) === R) { D = D.next, R === Ca && (C = !0); continue } else _ = { lane: 0, revertLane: D.revertLane, action: D.action, hasEagerState: D.hasEagerState, eagerState: D.eagerState, next: null }, S === null ? (p = S = _, f = r) : S = S.next = _, ut.lanes |= R, Rn |= R; _ = D.action, ta && n(r, _), r = D.hasEagerState ? D.eagerState : n(r, _) } else R = { lane: _, revertLane: D.revertLane, action: D.action, hasEagerState: D.hasEagerState, eagerState: D.eagerState, next: null }, S === null ? (p = S = R, f = r) : S = S.next = R, ut.lanes |= _, Rn |= _; D = D.next } while (D !== null && D !== e); if (S === null ? f = r : S.next = p, !de(r, t.memoizedState) && (Kt = !0, C && (n = Va, n !== null))) throw n; t.memoizedState = r, t.baseState = f, t.baseQueue = S, a.lastRenderedState = r } return s === null && (a.lanes = 0), [t.memoizedState, a.dispatch] } function fo(t) { var e = wt(), n = e.queue; if (n === null) throw Error(o(311)); n.lastRenderedReducer = t; var a = n.dispatch, s = n.pending, r = e.memoizedState; if (s !== null) { n.pending = null; var f = s = s.next; do r = t(r, f.action), f = f.next; while (f !== s); de(r, e.memoizedState) || (Kt = !0), e.memoizedState = r, e.baseQueue === null && (e.baseState = r), n.lastRenderedState = r } return [r, a] } function rh(t, e, n) { var a = ut, s = wt(), r = pt; if (r) { if (n === void 0) throw Error(o(407)); n = n() } else n = e(); var f = !de((St || s).memoizedState, n); f && (s.memoizedState = n, Kt = !0), s = s.queue; var p = hh.bind(null, a, s, t); if (Bi(2048, 8, p, [t]), s.getSnapshot !== e || f || jt !== null && jt.memoizedState.tag & 1) { if (a.flags |= 2048, _a(9, ns(), fh.bind(null, a, s, n, e), null), xt === null) throw Error(o(349)); r || (bn & 124) !== 0 || ch(a, e, n) } return n } function ch(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = ut.updateQueue, e === null ? (e = oo(), ut.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function fh(t, e, n, a) { e.value = n, e.getSnapshot = a, dh(e) && mh(t) } function hh(t, e, n) { return n(function () { dh(e) && mh(t) }) } function dh(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !de(t, n) } catch { return !0 } } function mh(t) { var e = Ma(t, 2); e !== null && Se(e, t, 2) } function ho(t) { var e = se(); if (typeof t == "function") { var n = t; if (t = n(), ta) { dn(!0); try { n() } finally { dn(!1) } } } return e.memoizedState = e.baseState = t, e.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: tn, lastRenderedState: t }, e } function ph(t, e, n, a) { return t.baseState = n, co(t, St, typeof a == "function" ? a : tn) } function tv(t, e, n, a, s) { if (is(t)) throw Error(o(485)); if (t = e.action, t !== null) { var r = { payload: s, action: t, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (f) { r.listeners.push(f) } }; z.T !== null ? n(!0) : r.isTransition = !1, a(r), n = e.pending, n === null ? (r.next = e.pending = r, yh(e, r)) : (r.next = n.next, e.pending = n.next = r) } } function yh(t, e) { var n = e.action, a = e.payload, s = t.state; if (e.isTransition) { var r = z.T, f = {}; z.T = f; try { var p = n(s, a), S = z.S; S !== null && S(f, p), gh(t, e, p) } catch (D) { mo(t, e, D) } finally { z.T = r } } else try { r = n(s, a), gh(t, e, r) } catch (D) { mo(t, e, D) } } function gh(t, e, n) { n !== null && typeof n == "object" && typeof n.then == "function" ? n.then(function (a) { vh(t, e, a) }, function (a) { return mo(t, e, a) }) : vh(t, e, n) } function vh(t, e, n) { e.status = "fulfilled", e.value = n, Sh(e), t.state = n, e = t.pending, e !== null && (n = e.next, n === e ? t.pending = null : (n = n.next, e.next = n, yh(t, n))) } function mo(t, e, n) { var a = t.pending; if (t.pending = null, a !== null) { a = a.next; do e.status = "rejected", e.reason = n, Sh(e), e = e.next; while (e !== a) } t.action = null } function Sh(t) { t = t.listeners; for (var e = 0; e < t.length; e++)(0, t[e])() } function bh(t, e) { return e } function Th(t, e) { if (pt) { var n = xt.formState; if (n !== null) { t: { var a = ut; if (pt) { if (Vt) { e: { for (var s = Vt, r = Le; s.nodeType !== 8;) { if (!r) { s = null; break e } if (s = _e(s.nextSibling), s === null) { s = null; break e } } r = s.data, s = r === "F!" || r === "F" ? s : null } if (s) { Vt = _e(s.nextSibling), a = s.data === "F!"; break t } } Fn(a) } a = !1 } a && (e = n[0]) } } return n = se(), n.memoizedState = n.baseState = e, a = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: bh, lastRenderedState: e }, n.queue = a, n = qh.bind(null, ut, a), a.dispatch = n, a = ho(!1), r = So.bind(null, ut, !1, a.queue), a = se(), s = { state: e, dispatch: null, action: t, pending: null }, a.queue = s, n = tv.bind(null, ut, s, r, n), s.dispatch = n, a.memoizedState = t, [e, n, !1] } function Ah(t) { var e = wt(); return xh(e, St, t) } function xh(t, e, n) { if (e = co(t, e, bh)[0], t = es(tn)[0], typeof e == "object" && e !== null && typeof e.then == "function") try { var a = _i(e) } catch (f) { throw f === Oi ? Pl : f } else a = e; e = wt(); var s = e.queue, r = s.dispatch; return n !== e.memoizedState && (ut.flags |= 2048, _a(9, ns(), ev.bind(null, s, n), null)), [a, r, t] } function ev(t, e) { t.action = e } function Eh(t) { var e = wt(), n = St; if (n !== null) return xh(e, n, t); wt(), e = e.memoizedState, n = wt(); var a = n.queue.dispatch; return n.memoizedState = t, [e, a, !1] } function _a(t, e, n, a) { return t = { tag: t, create: n, deps: a, inst: e, next: null }, e = ut.updateQueue, e === null && (e = oo(), ut.updateQueue = e), n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (a = n.next, n.next = t, t.next = a, e.lastEffect = t), t } function ns() { return { destroy: void 0, resource: void 0 } } function Mh() { return wt().memoizedState } function as(t, e, n, a) { var s = se(); a = a === void 0 ? null : a, ut.flags |= t, s.memoizedState = _a(1 | e, ns(), n, a) } function Bi(t, e, n, a) { var s = wt(); a = a === void 0 ? null : a; var r = s.memoizedState.inst; St !== null && a !== null && ao(a, St.memoizedState.deps) ? s.memoizedState = _a(e, r, n, a) : (ut.flags |= t, s.memoizedState = _a(1 | e, r, n, a)) } function Dh(t, e) { as(8390656, 8, t, e) } function Rh(t, e) { Bi(2048, 8, t, e) } function Oh(t, e) { return Bi(4, 2, t, e) } function Ch(t, e) { return Bi(4, 4, t, e) } function Vh(t, e) { if (typeof e == "function") { t = t(); var n = e(t); return function () { typeof n == "function" ? n() : e(null) } } if (e != null) return t = t(), e.current = t, function () { e.current = null } } function zh(t, e, n) { n = n != null ? n.concat([t]) : null, Bi(4, 4, Vh.bind(null, e, t), n) } function po() { } function Nh(t, e) { var n = wt(); e = e === void 0 ? null : e; var a = n.memoizedState; return e !== null && ao(e, a[1]) ? a[0] : (n.memoizedState = [t, e], t) } function Uh(t, e) { var n = wt(); e = e === void 0 ? null : e; var a = n.memoizedState; if (e !== null && ao(e, a[1])) return a[0]; if (a = t(), ta) { dn(!0); try { t() } finally { dn(!1) } } return n.memoizedState = [a, e], a } function yo(t, e, n) { return n === void 0 || (bn & 1073741824) !== 0 ? t.memoizedState = e : (t.memoizedState = n, t = jd(), ut.lanes |= t, Rn |= t, n) } function _h(t, e, n, a) { return de(n, e) ? n : za.current !== null ? (t = yo(t, n, a), de(t, e) || (Kt = !0), t) : (bn & 42) === 0 ? (Kt = !0, t.memoizedState = n) : (t = jd(), ut.lanes |= t, Rn |= t, e) } function Bh(t, e, n, a, s) { var r = L.p; L.p = r !== 0 && 8 > r ? r : 8; var f = z.T, p = {}; z.T = p, So(t, !1, e, n); try { var S = s(), D = z.S; if (D !== null && D(p, S), S !== null && typeof S == "object" && typeof S.then == "function") { var C = W0(S, a); ji(t, e, C, ve(t)) } else ji(t, e, a, ve(t)) } catch (_) { ji(t, e, { then: function () { }, status: "rejected", reason: _ }, ve()) } finally { L.p = r, z.T = f } } function nv() { } function go(t, e, n, a) { if (t.tag !== 5) throw Error(o(476)); var s = jh(t).queue; Bh(t, s, e, J, n === null ? nv : function () { return wh(t), n(a) }) } function jh(t) { var e = t.memoizedState; if (e !== null) return e; e = { memoizedState: J, baseState: J, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: tn, lastRenderedState: J }, next: null }; var n = {}; return e.next = { memoizedState: n, baseState: n, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: tn, lastRenderedState: n }, next: null }, t.memoizedState = e, t = t.alternate, t !== null && (t.memoizedState = e), e } function wh(t) { var e = jh(t).next.queue; ji(t, e, {}, ve()) } function vo() { return It(tl) } function Lh() { return wt().memoizedState } function Hh() { return wt().memoizedState } function av(t) { for (var e = t.return; e !== null;) { switch (e.tag) { case 24: case 3: var n = ve(); t = vn(n); var a = Sn(e, t, n); a !== null && (Se(a, e, n), Vi(a, e, n)), e = { cache: Ju() }, t.payload = e; return }e = e.return } } function iv(t, e, n) { var a = ve(); n = { lane: a, revertLane: 0, action: n, hasEagerState: !1, eagerState: null, next: null }, is(t) ? Yh(e, n) : (n = wu(t, e, n, a), n !== null && (Se(n, t, a), Gh(n, e, a))) } function qh(t, e, n) { var a = ve(); ji(t, e, n, a) } function ji(t, e, n, a) { var s = { lane: a, revertLane: 0, action: n, hasEagerState: !1, eagerState: null, next: null }; if (is(t)) Yh(e, s); else { var r = t.alternate; if (t.lanes === 0 && (r === null || r.lanes === 0) && (r = e.lastRenderedReducer, r !== null)) try { var f = e.lastRenderedState, p = r(f, n); if (s.hasEagerState = !0, s.eagerState = p, de(p, f)) return Yl(t, e, s, 0), xt === null && ql(), !1 } catch { } finally { } if (n = wu(t, e, s, a), n !== null) return Se(n, t, a), Gh(n, e, a), !0 } return !1 } function So(t, e, n, a) { if (a = { lane: 2, revertLane: Wo(), action: a, hasEagerState: !1, eagerState: null, next: null }, is(t)) { if (e) throw Error(o(479)) } else e = wu(t, n, a, 2), e !== null && Se(e, t, 2) } function is(t) { var e = t.alternate; return t === ut || e !== null && e === ut } function Yh(t, e) { Na = $l = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function Gh(t, e, n) { if ((n & 4194048) !== 0) { var a = e.lanes; a &= t.pendingLanes, n |= a, e.lanes = n, Pc(t, n) } } var ls = { readContext: It, use: ts, useCallback: Ut, useContext: Ut, useEffect: Ut, useImperativeHandle: Ut, useLayoutEffect: Ut, useInsertionEffect: Ut, useMemo: Ut, useReducer: Ut, useRef: Ut, useState: Ut, useDebugValue: Ut, useDeferredValue: Ut, useTransition: Ut, useSyncExternalStore: Ut, useId: Ut, useHostTransitionStatus: Ut, useFormState: Ut, useActionState: Ut, useOptimistic: Ut, useMemoCache: Ut, useCacheRefresh: Ut }, Xh = { readContext: It, use: ts, useCallback: function (t, e) { return se().memoizedState = [t, e === void 0 ? null : e], t }, useContext: It, useEffect: Dh, useImperativeHandle: function (t, e, n) { n = n != null ? n.concat([t]) : null, as(4194308, 4, Vh.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return as(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { as(4, 2, t, e) }, useMemo: function (t, e) { var n = se(); e = e === void 0 ? null : e; var a = t(); if (ta) { dn(!0); try { t() } finally { dn(!1) } } return n.memoizedState = [a, e], a }, useReducer: function (t, e, n) { var a = se(); if (n !== void 0) { var s = n(e); if (ta) { dn(!0); try { n(e) } finally { dn(!1) } } } else s = e; return a.memoizedState = a.baseState = s, t = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: s }, a.queue = t, t = t.dispatch = iv.bind(null, ut, t), [a.memoizedState, t] }, useRef: function (t) { var e = se(); return t = { current: t }, e.memoizedState = t }, useState: function (t) { t = ho(t); var e = t.queue, n = qh.bind(null, ut, e); return e.dispatch = n, [t.memoizedState, n] }, useDebugValue: po, useDeferredValue: function (t, e) { var n = se(); return yo(n, t, e) }, useTransition: function () { var t = ho(!1); return t = Bh.bind(null, ut, t.queue, !0, !1), se().memoizedState = t, [!1, t] }, useSyncExternalStore: function (t, e, n) { var a = ut, s = se(); if (pt) { if (n === void 0) throw Error(o(407)); n = n() } else { if (n = e(), xt === null) throw Error(o(349)); (ht & 124) !== 0 || ch(a, e, n) } s.memoizedState = n; var r = { value: n, getSnapshot: e }; return s.queue = r, Dh(hh.bind(null, a, r, t), [t]), a.flags |= 2048, _a(9, ns(), fh.bind(null, a, r, n, e), null), n }, useId: function () { var t = se(), e = xt.identifierPrefix; if (pt) { var n = We, a = Fe; n = (a & ~(1 << 32 - he(a) - 1)).toString(32) + n, e = "" + e + "R" + n, n = Il++, 0 < n && (e += "H" + n.toString(32)), e += "" } else n = $0++, e = "" + e + "r" + n.toString(32) + ""; return t.memoizedState = e }, useHostTransitionStatus: vo, useFormState: Th, useActionState: Th, useOptimistic: function (t) { var e = se(); e.memoizedState = e.baseState = t; var n = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return e.queue = n, e = So.bind(null, ut, !0, n), n.dispatch = e, [t, e] }, useMemoCache: ro, useCacheRefresh: function () { return se().memoizedState = av.bind(null, ut) } }, Zh = { readContext: It, use: ts, useCallback: Nh, useContext: It, useEffect: Rh, useImperativeHandle: zh, useInsertionEffect: Oh, useLayoutEffect: Ch, useMemo: Uh, useReducer: es, useRef: Mh, useState: function () { return es(tn) }, useDebugValue: po, useDeferredValue: function (t, e) { var n = wt(); return _h(n, St.memoizedState, t, e) }, useTransition: function () { var t = es(tn)[0], e = wt().memoizedState; return [typeof t == "boolean" ? t : _i(t), e] }, useSyncExternalStore: rh, useId: Lh, useHostTransitionStatus: vo, useFormState: Ah, useActionState: Ah, useOptimistic: function (t, e) { var n = wt(); return ph(n, St, t, e) }, useMemoCache: ro, useCacheRefresh: Hh }, lv = { readContext: It, use: ts, useCallback: Nh, useContext: It, useEffect: Rh, useImperativeHandle: zh, useInsertionEffect: Oh, useLayoutEffect: Ch, useMemo: Uh, useReducer: fo, useRef: Mh, useState: function () { return fo(tn) }, useDebugValue: po, useDeferredValue: function (t, e) { var n = wt(); return St === null ? yo(n, t, e) : _h(n, St.memoizedState, t, e) }, useTransition: function () { var t = fo(tn)[0], e = wt().memoizedState; return [typeof t == "boolean" ? t : _i(t), e] }, useSyncExternalStore: rh, useId: Lh, useHostTransitionStatus: vo, useFormState: Eh, useActionState: Eh, useOptimistic: function (t, e) { var n = wt(); return St !== null ? ph(n, St, t, e) : (n.baseState = t, [t, n.queue.dispatch]) }, useMemoCache: ro, useCacheRefresh: Hh }, Ba = null, wi = 0; function ss(t) { var e = wi; return wi += 1, Ba === null && (Ba = []), eh(Ba, t, e) } function Li(t, e) { e = e.props.ref, t.ref = e !== void 0 ? e : null } function us(t, e) { throw e.$$typeof === b ? Error(o(525)) : (t = Object.prototype.toString.call(e), Error(o(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))) } function Kh(t) { var e = t._init; return e(t._payload) } function Qh(t) { function e(E, A) { if (t) { var M = E.deletions; M === null ? (E.deletions = [A], E.flags |= 16) : M.push(A) } } function n(E, A) { if (!t) return null; for (; A !== null;)e(E, A), A = A.sibling; return null } function a(E) { for (var A = new Map; E !== null;)E.key !== null ? A.set(E.key, E) : A.set(E.index, E), E = E.sibling; return A } function s(E, A) { return E = Pe(E, A), E.index = 0, E.sibling = null, E } function r(E, A, M) { return E.index = M, t ? (M = E.alternate, M !== null ? (M = M.index, M < A ? (E.flags |= 67108866, A) : M) : (E.flags |= 67108866, A)) : (E.flags |= 1048576, A) } function f(E) { return t && E.alternate === null && (E.flags |= 67108866), E } function p(E, A, M, N) { return A === null || A.tag !== 6 ? (A = Hu(M, E.mode, N), A.return = E, A) : (A = s(A, M), A.return = E, A) } function S(E, A, M, N) { var Q = M.type; return Q === w ? C(E, A, M.props.children, N, M.key) : A !== null && (A.elementType === Q || typeof Q == "object" && Q !== null && Q.$$typeof === P && Kh(Q) === A.type) ? (A = s(A, M.props), Li(A, M), A.return = E, A) : (A = Xl(M.type, M.key, M.props, null, E.mode, N), Li(A, M), A.return = E, A) } function D(E, A, M, N) { return A === null || A.tag !== 4 || A.stateNode.containerInfo !== M.containerInfo || A.stateNode.implementation !== M.implementation ? (A = qu(M, E.mode, N), A.return = E, A) : (A = s(A, M.children || []), A.return = E, A) } function C(E, A, M, N, Q) { return A === null || A.tag !== 7 ? (A = Qn(M, E.mode, N, Q), A.return = E, A) : (A = s(A, M), A.return = E, A) } function _(E, A, M) { if (typeof A == "string" && A !== "" || typeof A == "number" || typeof A == "bigint") return A = Hu("" + A, E.mode, M), A.return = E, A; if (typeof A == "object" && A !== null) { switch (A.$$typeof) { case x: return M = Xl(A.type, A.key, A.props, null, E.mode, M), Li(M, A), M.return = E, M; case V: return A = qu(A, E.mode, M), A.return = E, A; case P: var N = A._init; return A = N(A._payload), _(E, A, M) }if (qt(A) || Ht(A)) return A = Qn(A, E.mode, M, null), A.return = E, A; if (typeof A.then == "function") return _(E, ss(A), M); if (A.$$typeof === Y) return _(E, Jl(E, A), M); us(E, A) } return null } function R(E, A, M, N) { var Q = A !== null ? A.key : null; if (typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint") return Q !== null ? null : p(E, A, "" + M, N); if (typeof M == "object" && M !== null) { switch (M.$$typeof) { case x: return M.key === Q ? S(E, A, M, N) : null; case V: return M.key === Q ? D(E, A, M, N) : null; case P: return Q = M._init, M = Q(M._payload), R(E, A, M, N) }if (qt(M) || Ht(M)) return Q !== null ? null : C(E, A, M, N, null); if (typeof M.then == "function") return R(E, A, ss(M), N); if (M.$$typeof === Y) return R(E, A, Jl(E, M), N); us(E, M) } return null } function O(E, A, M, N, Q) { if (typeof N == "string" && N !== "" || typeof N == "number" || typeof N == "bigint") return E = E.get(M) || null, p(A, E, "" + N, Q); if (typeof N == "object" && N !== null) { switch (N.$$typeof) { case x: return E = E.get(N.key === null ? M : N.key) || null, S(A, E, N, Q); case V: return E = E.get(N.key === null ? M : N.key) || null, D(A, E, N, Q); case P: var ot = N._init; return N = ot(N._payload), O(E, A, M, N, Q) }if (qt(N) || Ht(N)) return E = E.get(M) || null, C(A, E, N, Q, null); if (typeof N.then == "function") return O(E, A, M, ss(N), Q); if (N.$$typeof === Y) return O(E, A, M, Jl(A, N), Q); us(A, N) } return null } function at(E, A, M, N) { for (var Q = null, ot = null, F = A, tt = A = 0, Jt = null; F !== null && tt < M.length; tt++) { F.index > tt ? (Jt = F, F = null) : Jt = F.sibling; var mt = R(E, F, M[tt], N); if (mt === null) { F === null && (F = Jt); break } t && F && mt.alternate === null && e(E, F), A = r(mt, A, tt), ot === null ? Q = mt : ot.sibling = mt, ot = mt, F = Jt } if (tt === M.length) return n(E, F), pt && kn(E, tt), Q; if (F === null) { for (; tt < M.length; tt++)F = _(E, M[tt], N), F !== null && (A = r(F, A, tt), ot === null ? Q = F : ot.sibling = F, ot = F); return pt && kn(E, tt), Q } for (F = a(F); tt < M.length; tt++)Jt = O(F, E, tt, M[tt], N), Jt !== null && (t && Jt.alternate !== null && F.delete(Jt.key === null ? tt : Jt.key), A = r(Jt, A, tt), ot === null ? Q = Jt : ot.sibling = Jt, ot = Jt); return t && F.forEach(function (jn) { return e(E, jn) }), pt && kn(E, tt), Q } function I(E, A, M, N) { if (M == null) throw Error(o(151)); for (var Q = null, ot = null, F = A, tt = A = 0, Jt = null, mt = M.next(); F !== null && !mt.done; tt++, mt = M.next()) { F.index > tt ? (Jt = F, F = null) : Jt = F.sibling; var jn = R(E, F, mt.value, N); if (jn === null) { F === null && (F = Jt); break } t && F && jn.alternate === null && e(E, F), A = r(jn, A, tt), ot === null ? Q = jn : ot.sibling = jn, ot = jn, F = Jt } if (mt.done) return n(E, F), pt && kn(E, tt), Q; if (F === null) { for (; !mt.done; tt++, mt = M.next())mt = _(E, mt.value, N), mt !== null && (A = r(mt, A, tt), ot === null ? Q = mt : ot.sibling = mt, ot = mt); return pt && kn(E, tt), Q } for (F = a(F); !mt.done; tt++, mt = M.next())mt = O(F, E, tt, mt.value, N), mt !== null && (t && mt.alternate !== null && F.delete(mt.key === null ? tt : mt.key), A = r(mt, A, tt), ot === null ? Q = mt : ot.sibling = mt, ot = mt); return t && F.forEach(function (s1) { return e(E, s1) }), pt && kn(E, tt), Q } function Tt(E, A, M, N) { if (typeof M == "object" && M !== null && M.type === w && M.key === null && (M = M.props.children), typeof M == "object" && M !== null) { switch (M.$$typeof) { case x: t: { for (var Q = M.key; A !== null;) { if (A.key === Q) { if (Q = M.type, Q === w) { if (A.tag === 7) { n(E, A.sibling), N = s(A, M.props.children), N.return = E, E = N; break t } } else if (A.elementType === Q || typeof Q == "object" && Q !== null && Q.$$typeof === P && Kh(Q) === A.type) { n(E, A.sibling), N = s(A, M.props), Li(N, M), N.return = E, E = N; break t } n(E, A); break } else e(E, A); A = A.sibling } M.type === w ? (N = Qn(M.props.children, E.mode, N, M.key), N.return = E, E = N) : (N = Xl(M.type, M.key, M.props, null, E.mode, N), Li(N, M), N.return = E, E = N) } return f(E); case V: t: { for (Q = M.key; A !== null;) { if (A.key === Q) if (A.tag === 4 && A.stateNode.containerInfo === M.containerInfo && A.stateNode.implementation === M.implementation) { n(E, A.sibling), N = s(A, M.children || []), N.return = E, E = N; break t } else { n(E, A); break } else e(E, A); A = A.sibling } N = qu(M, E.mode, N), N.return = E, E = N } return f(E); case P: return Q = M._init, M = Q(M._payload), Tt(E, A, M, N) }if (qt(M)) return at(E, A, M, N); if (Ht(M)) { if (Q = Ht(M), typeof Q != "function") throw Error(o(150)); return M = Q.call(M), I(E, A, M, N) } if (typeof M.then == "function") return Tt(E, A, ss(M), N); if (M.$$typeof === Y) return Tt(E, A, Jl(E, M), N); us(E, M) } return typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint" ? (M = "" + M, A !== null && A.tag === 6 ? (n(E, A.sibling), N = s(A, M), N.return = E, E = N) : (n(E, A), N = Hu(M, E.mode, N), N.return = E, E = N), f(E)) : n(E, A) } return function (E, A, M, N) { try { wi = 0; var Q = Tt(E, A, M, N); return Ba = null, Q } catch (F) { if (F === Oi || F === Pl) throw F; var ot = me(29, F, null, E.mode); return ot.lanes = N, ot.return = E, ot } finally { } } } var ja = Qh(!0), Jh = Qh(!1), De = j(null), He = null; function Tn(t) { var e = t.alternate; G(Gt, Gt.current & 1), G(De, t), He === null && (e === null || za.current !== null || e.memoizedState !== null) && (He = t) } function kh(t) { if (t.tag === 22) { if (G(Gt, Gt.current), G(De, t), He === null) { var e = t.alternate; e !== null && e.memoizedState !== null && (He = t) } } else An() } function An() { G(Gt, Gt.current), G(De, De.current) } function en(t) { K(De), He === t && (He = null), K(Gt) } var Gt = j(0); function os(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || rr(n))) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if ((e.flags & 128) !== 0) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } function bo(t, e, n, a) { e = t.memoizedState, n = n(a, e), n = n == null ? e : v({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var To = { enqueueSetState: function (t, e, n) { t = t._reactInternals; var a = ve(), s = vn(a); s.payload = e, n != null && (s.callback = n), e = Sn(t, s, a), e !== null && (Se(e, t, a), Vi(e, t, a)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var a = ve(), s = vn(a); s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Sn(t, s, a), e !== null && (Se(e, t, a), Vi(e, t, a)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = ve(), a = vn(n); a.tag = 2, e != null && (a.callback = e), e = Sn(t, a, n), e !== null && (Se(e, t, n), Vi(e, t, n)) } }; function Ph(t, e, n, a, s, r, f) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(a, r, f) : e.prototype && e.prototype.isPureReactComponent ? !bi(n, a) || !bi(s, r) : !0 } function Fh(t, e, n, a) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, a), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, a), e.state !== t && To.enqueueReplaceState(e, e.state, null) } function ea(t, e) { var n = e; if ("ref" in e) { n = {}; for (var a in e) a !== "ref" && (n[a] = e[a]) } if (t = t.defaultProps) { n === e && (n = v({}, n)); for (var s in t) n[s] === void 0 && (n[s] = t[s]) } return n } var rs = typeof reportError == "function" ? reportError : function (t) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var e = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof t == "object" && t !== null && typeof t.message == "string" ? String(t.message) : String(t), error: t }); if (!window.dispatchEvent(e)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", t); return } console.error(t) }; function Wh(t) { rs(t) } function $h(t) { console.error(t) } function Ih(t) { rs(t) } function cs(t, e) { try { var n = t.onUncaughtError; n(e.value, { componentStack: e.stack }) } catch (a) { setTimeout(function () { throw a }) } } function td(t, e, n) { try { var a = t.onCaughtError; a(n.value, { componentStack: n.stack, errorBoundary: e.tag === 1 ? e.stateNode : null }) } catch (s) { setTimeout(function () { throw s }) } } function Ao(t, e, n) { return n = vn(n), n.tag = 3, n.payload = { element: null }, n.callback = function () { cs(t, e) }, n } function ed(t) { return t = vn(t), t.tag = 3, t } function nd(t, e, n, a) { var s = n.type.getDerivedStateFromError; if (typeof s == "function") { var r = a.value; t.payload = function () { return s(r) }, t.callback = function () { td(e, n, a) } } var f = n.stateNode; f !== null && typeof f.componentDidCatch == "function" && (t.callback = function () { td(e, n, a), typeof s != "function" && (On === null ? On = new Set([this]) : On.add(this)); var p = a.stack; this.componentDidCatch(a.value, { componentStack: p !== null ? p : "" }) }) } function sv(t, e, n, a, s) { if (n.flags |= 32768, a !== null && typeof a == "object" && typeof a.then == "function") { if (e = n.alternate, e !== null && Mi(e, n, s, !0), n = De.current, n !== null) { switch (n.tag) { case 13: return He === null ? Qo() : n.alternate === null && zt === 0 && (zt = 3), n.flags &= -257, n.flags |= 65536, n.lanes = s, a === Fu ? n.flags |= 16384 : (e = n.updateQueue, e === null ? n.updateQueue = new Set([a]) : e.add(a), ko(t, a, s)), !1; case 22: return n.flags |= 65536, a === Fu ? n.flags |= 16384 : (e = n.updateQueue, e === null ? (e = { transitions: null, markerInstances: null, retryQueue: new Set([a]) }, n.updateQueue = e) : (n = e.retryQueue, n === null ? e.retryQueue = new Set([a]) : n.add(a)), ko(t, a, s)), !1 }throw Error(o(435, n.tag)) } return ko(t, a, s), Qo(), !1 } if (pt) return e = De.current, e !== null ? ((e.flags & 65536) === 0 && (e.flags |= 256), e.flags |= 65536, e.lanes = s, a !== Xu && (t = Error(o(422), { cause: a }), Ei(Ae(t, n)))) : (a !== Xu && (e = Error(o(423), { cause: a }), Ei(Ae(e, n))), t = t.current.alternate, t.flags |= 65536, s &= -s, t.lanes |= s, a = Ae(a, n), s = Ao(t.stateNode, a, s), Iu(t, s), zt !== 4 && (zt = 2)), !1; var r = Error(o(520), { cause: a }); if (r = Ae(r, n), Ki === null ? Ki = [r] : Ki.push(r), zt !== 4 && (zt = 2), e === null) return !0; a = Ae(a, n), n = e; do { switch (n.tag) { case 3: return n.flags |= 65536, t = s & -s, n.lanes |= t, t = Ao(n.stateNode, a, t), Iu(n, t), !1; case 1: if (e = n.type, r = n.stateNode, (n.flags & 128) === 0 && (typeof e.getDerivedStateFromError == "function" || r !== null && typeof r.componentDidCatch == "function" && (On === null || !On.has(r)))) return n.flags |= 65536, s &= -s, n.lanes |= s, s = ed(s), nd(s, t, n, a), Iu(n, s), !1 }n = n.return } while (n !== null); return !1 } var ad = Error(o(461)), Kt = !1; function kt(t, e, n, a) { e.child = t === null ? Jh(e, null, n, a) : ja(e, t.child, n, a) } function id(t, e, n, a, s) { n = n.render; var r = e.ref; if ("ref" in a) { var f = {}; for (var p in a) p !== "ref" && (f[p] = a[p]) } else f = a; return $n(e), a = io(t, e, n, f, r, s), p = lo(), t !== null && !Kt ? (so(t, e, s), nn(t, e, s)) : (pt && p && Yu(e), e.flags |= 1, kt(t, e, a, s), e.child) } function ld(t, e, n, a, s) { if (t === null) { var r = n.type; return typeof r == "function" && !Lu(r) && r.defaultProps === void 0 && n.compare === null ? (e.tag = 15, e.type = r, sd(t, e, r, a, s)) : (t = Xl(n.type, null, a, e, e.mode, s), t.ref = e.ref, t.return = e, e.child = t) } if (r = t.child, !Vo(t, s)) { var f = r.memoizedProps; if (n = n.compare, n = n !== null ? n : bi, n(f, a) && t.ref === e.ref) return nn(t, e, s) } return e.flags |= 1, t = Pe(r, a), t.ref = e.ref, t.return = e, e.child = t } function sd(t, e, n, a, s) { if (t !== null) { var r = t.memoizedProps; if (bi(r, a) && t.ref === e.ref) if (Kt = !1, e.pendingProps = a = r, Vo(t, s)) (t.flags & 131072) !== 0 && (Kt = !0); else return e.lanes = t.lanes, nn(t, e, s) } return xo(t, e, n, a, s) } function ud(t, e, n) { var a = e.pendingProps, s = a.children, r = t !== null ? t.memoizedState : null; if (a.mode === "hidden") { if ((e.flags & 128) !== 0) { if (a = r !== null ? r.baseLanes | n : n, t !== null) { for (s = e.child = t.child, r = 0; s !== null;)r = r | s.lanes | s.childLanes, s = s.sibling; e.childLanes = r & ~a } else e.childLanes = 0, e.child = null; return od(t, e, a, n) } if ((n & 536870912) !== 0) e.memoizedState = { baseLanes: 0, cachePool: null }, t !== null && kl(e, r !== null ? r.cachePool : null), r !== null ? sh(e, r) : eo(), kh(e); else return e.lanes = e.childLanes = 536870912, od(t, e, r !== null ? r.baseLanes | n : n, n) } else r !== null ? (kl(e, r.cachePool), sh(e, r), An(), e.memoizedState = null) : (t !== null && kl(e, null), eo(), An()); return kt(t, e, s, n), e.child } function od(t, e, n, a) { var s = Pu(); return s = s === null ? null : { parent: Yt._currentValue, pool: s }, e.memoizedState = { baseLanes: n, cachePool: s }, t !== null && kl(e, null), eo(), kh(e), t !== null && Mi(t, e, a, !0), null } function fs(t, e) { var n = e.ref; if (n === null) t !== null && t.ref !== null && (e.flags |= 4194816); else { if (typeof n != "function" && typeof n != "object") throw Error(o(284)); (t === null || t.ref !== n) && (e.flags |= 4194816) } } function xo(t, e, n, a, s) { return $n(e), n = io(t, e, n, a, void 0, s), a = lo(), t !== null && !Kt ? (so(t, e, s), nn(t, e, s)) : (pt && a && Yu(e), e.flags |= 1, kt(t, e, n, s), e.child) } function rd(t, e, n, a, s, r) { return $n(e), e.updateQueue = null, n = oh(e, a, n, s), uh(t), a = lo(), t !== null && !Kt ? (so(t, e, r), nn(t, e, r)) : (pt && a && Yu(e), e.flags |= 1, kt(t, e, n, r), e.child) } function cd(t, e, n, a, s) { if ($n(e), e.stateNode === null) { var r = Da, f = n.contextType; typeof f == "object" && f !== null && (r = It(f)), r = new n(a, r), e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, r.updater = To, e.stateNode = r, r._reactInternals = e, r = e.stateNode, r.props = a, r.state = e.memoizedState, r.refs = {}, Wu(e), f = n.contextType, r.context = typeof f == "object" && f !== null ? It(f) : Da, r.state = e.memoizedState, f = n.getDerivedStateFromProps, typeof f == "function" && (bo(e, n, f, a), r.state = e.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (f = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), f !== r.state && To.enqueueReplaceState(r, r.state, null), Ni(e, a, r, s), zi(), r.state = e.memoizedState), typeof r.componentDidMount == "function" && (e.flags |= 4194308), a = !0 } else if (t === null) { r = e.stateNode; var p = e.memoizedProps, S = ea(n, p); r.props = S; var D = r.context, C = n.contextType; f = Da, typeof C == "object" && C !== null && (f = It(C)); var _ = n.getDerivedStateFromProps; C = typeof _ == "function" || typeof r.getSnapshotBeforeUpdate == "function", p = e.pendingProps !== p, C || typeof r.UNSAFE_componentWillReceiveProps != "function" && typeof r.componentWillReceiveProps != "function" || (p || D !== f) && Fh(e, r, a, f), gn = !1; var R = e.memoizedState; r.state = R, Ni(e, a, r, s), zi(), D = e.memoizedState, p || R !== D || gn ? (typeof _ == "function" && (bo(e, n, _, a), D = e.memoizedState), (S = gn || Ph(e, n, S, a, R, D, f)) ? (C || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount()), typeof r.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof r.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = a, e.memoizedState = D), r.props = a, r.state = D, r.context = f, a = S) : (typeof r.componentDidMount == "function" && (e.flags |= 4194308), a = !1) } else { r = e.stateNode, $u(t, e), f = e.memoizedProps, C = ea(n, f), r.props = C, _ = e.pendingProps, R = r.context, D = n.contextType, S = Da, typeof D == "object" && D !== null && (S = It(D)), p = n.getDerivedStateFromProps, (D = typeof p == "function" || typeof r.getSnapshotBeforeUpdate == "function") || typeof r.UNSAFE_componentWillReceiveProps != "function" && typeof r.componentWillReceiveProps != "function" || (f !== _ || R !== S) && Fh(e, r, a, S), gn = !1, R = e.memoizedState, r.state = R, Ni(e, a, r, s), zi(); var O = e.memoizedState; f !== _ || R !== O || gn || t !== null && t.dependencies !== null && Ql(t.dependencies) ? (typeof p == "function" && (bo(e, n, p, a), O = e.memoizedState), (C = gn || Ph(e, n, C, a, R, O, S) || t !== null && t.dependencies !== null && Ql(t.dependencies)) ? (D || typeof r.UNSAFE_componentWillUpdate != "function" && typeof r.componentWillUpdate != "function" || (typeof r.componentWillUpdate == "function" && r.componentWillUpdate(a, O, S), typeof r.UNSAFE_componentWillUpdate == "function" && r.UNSAFE_componentWillUpdate(a, O, S)), typeof r.componentDidUpdate == "function" && (e.flags |= 4), typeof r.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof r.componentDidUpdate != "function" || f === t.memoizedProps && R === t.memoizedState || (e.flags |= 4), typeof r.getSnapshotBeforeUpdate != "function" || f === t.memoizedProps && R === t.memoizedState || (e.flags |= 1024), e.memoizedProps = a, e.memoizedState = O), r.props = a, r.state = O, r.context = S, a = C) : (typeof r.componentDidUpdate != "function" || f === t.memoizedProps && R === t.memoizedState || (e.flags |= 4), typeof r.getSnapshotBeforeUpdate != "function" || f === t.memoizedProps && R === t.memoizedState || (e.flags |= 1024), a = !1) } return r = a, fs(t, e), a = (e.flags & 128) !== 0, r || a ? (r = e.stateNode, n = a && typeof n.getDerivedStateFromError != "function" ? null : r.render(), e.flags |= 1, t !== null && a ? (e.child = ja(e, t.child, null, s), e.child = ja(e, null, n, s)) : kt(t, e, n, s), e.memoizedState = r.state, t = e.child) : t = nn(t, e, s), t } function fd(t, e, n, a) { return xi(), e.flags |= 256, kt(t, e, n, a), e.child } var Eo = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }; function Mo(t) { return { baseLanes: t, cachePool: $f() } } function Do(t, e, n) { return t = t !== null ? t.childLanes & ~n : 0, e && (t |= Re), t } function hd(t, e, n) { var a = e.pendingProps, s = !1, r = (e.flags & 128) !== 0, f; if ((f = r) || (f = t !== null && t.memoizedState === null ? !1 : (Gt.current & 2) !== 0), f && (s = !0, e.flags &= -129), f = (e.flags & 32) !== 0, e.flags &= -33, t === null) { if (pt) { if (s ? Tn(e) : An(), pt) { var p = Vt, S; if (S = p) { t: { for (S = p, p = Le; S.nodeType !== 8;) { if (!p) { p = null; break t } if (S = _e(S.nextSibling), S === null) { p = null; break t } } p = S } p !== null ? (e.memoizedState = { dehydrated: p, treeContext: Jn !== null ? { id: Fe, overflow: We } : null, retryLane: 536870912, hydrationErrors: null }, S = me(18, null, null, 0), S.stateNode = p, S.return = e, e.child = S, ne = e, Vt = null, S = !0) : S = !1 } S || Fn(e) } if (p = e.memoizedState, p !== null && (p = p.dehydrated, p !== null)) return rr(p) ? e.lanes = 32 : e.lanes = 536870912, null; en(e) } return p = a.children, a = a.fallback, s ? (An(), s = e.mode, p = hs({ mode: "hidden", children: p }, s), a = Qn(a, s, n, null), p.return = e, a.return = e, p.sibling = a, e.child = p, s = e.child, s.memoizedState = Mo(n), s.childLanes = Do(t, f, n), e.memoizedState = Eo, a) : (Tn(e), Ro(e, p)) } if (S = t.memoizedState, S !== null && (p = S.dehydrated, p !== null)) { if (r) e.flags & 256 ? (Tn(e), e.flags &= -257, e = Oo(t, e, n)) : e.memoizedState !== null ? (An(), e.child = t.child, e.flags |= 128, e = null) : (An(), s = a.fallback, p = e.mode, a = hs({ mode: "visible", children: a.children }, p), s = Qn(s, p, n, null), s.flags |= 2, a.return = e, s.return = e, a.sibling = s, e.child = a, ja(e, t.child, null, n), a = e.child, a.memoizedState = Mo(n), a.childLanes = Do(t, f, n), e.memoizedState = Eo, e = s); else if (Tn(e), rr(p)) { if (f = p.nextSibling && p.nextSibling.dataset, f) var D = f.dgst; f = D, a = Error(o(419)), a.stack = "", a.digest = f, Ei({ value: a, source: null, stack: null }), e = Oo(t, e, n) } else if (Kt || Mi(t, e, n, !1), f = (n & t.childLanes) !== 0, Kt || f) { if (f = xt, f !== null && (a = n & -n, a = (a & 42) !== 0 ? 1 : ru(a), a = (a & (f.suspendedLanes | n)) !== 0 ? 0 : a, a !== 0 && a !== S.retryLane)) throw S.retryLane = a, Ma(t, a), Se(f, t, a), ad; p.data === "$?" || Qo(), e = Oo(t, e, n) } else p.data === "$?" ? (e.flags |= 192, e.child = t.child, e = null) : (t = S.treeContext, Vt = _e(p.nextSibling), ne = e, pt = !0, Pn = null, Le = !1, t !== null && (Ee[Me++] = Fe, Ee[Me++] = We, Ee[Me++] = Jn, Fe = t.id, We = t.overflow, Jn = e), e = Ro(e, a.children), e.flags |= 4096); return e } return s ? (An(), s = a.fallback, p = e.mode, S = t.child, D = S.sibling, a = Pe(S, { mode: "hidden", children: a.children }), a.subtreeFlags = S.subtreeFlags & 65011712, D !== null ? s = Pe(D, s) : (s = Qn(s, p, n, null), s.flags |= 2), s.return = e, a.return = e, a.sibling = s, e.child = a, a = s, s = e.child, p = t.child.memoizedState, p === null ? p = Mo(n) : (S = p.cachePool, S !== null ? (D = Yt._currentValue, S = S.parent !== D ? { parent: D, pool: D } : S) : S = $f(), p = { baseLanes: p.baseLanes | n, cachePool: S }), s.memoizedState = p, s.childLanes = Do(t, f, n), e.memoizedState = Eo, a) : (Tn(e), n = t.child, t = n.sibling, n = Pe(n, { mode: "visible", children: a.children }), n.return = e, n.sibling = null, t !== null && (f = e.deletions, f === null ? (e.deletions = [t], e.flags |= 16) : f.push(t)), e.child = n, e.memoizedState = null, n) } function Ro(t, e) { return e = hs({ mode: "visible", children: e }, t.mode), e.return = t, t.child = e } function hs(t, e) { return t = me(22, t, null, e), t.lanes = 0, t.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }, t } function Oo(t, e, n) { return ja(e, t.child, null, n), t = Ro(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function dd(t, e, n) { t.lanes |= e; var a = t.alternate; a !== null && (a.lanes |= e), Ku(t.return, e, n) } function Co(t, e, n, a, s) { var r = t.memoizedState; r === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: a, tail: n, tailMode: s } : (r.isBackwards = e, r.rendering = null, r.renderingStartTime = 0, r.last = a, r.tail = n, r.tailMode = s) } function md(t, e, n) { var a = e.pendingProps, s = a.revealOrder, r = a.tail; if (kt(t, e, a.children, n), a = Gt.current, (a & 2) !== 0) a = a & 1 | 2, e.flags |= 128; else { if (t !== null && (t.flags & 128) !== 0) t: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && dd(t, n, e); else if (t.tag === 19) dd(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break t; for (; t.sibling === null;) { if (t.return === null || t.return === e) break t; t = t.return } t.sibling.return = t.return, t = t.sibling } a &= 1 } switch (G(Gt, a), s) { case "forwards": for (n = e.child, s = null; n !== null;)t = n.alternate, t !== null && os(t) === null && (s = n), n = n.sibling; n = s, n === null ? (s = e.child, e.child = null) : (s = n.sibling, n.sibling = null), Co(e, !1, s, n, r); break; case "backwards": for (n = null, s = e.child, e.child = null; s !== null;) { if (t = s.alternate, t !== null && os(t) === null) { e.child = s; break } t = s.sibling, s.sibling = n, n = s, s = t } Co(e, !0, n, null, r); break; case "together": Co(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function nn(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), Rn |= e.lanes, (n & e.childLanes) === 0) if (t !== null) { if (Mi(t, e, n, !1), (n & e.childLanes) === 0) return null } else return null; if (t !== null && e.child !== t.child) throw Error(o(153)); if (e.child !== null) { for (t = e.child, n = Pe(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = Pe(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function Vo(t, e) { return (t.lanes & e) !== 0 ? !0 : (t = t.dependencies, !!(t !== null && Ql(t))) } function uv(t, e, n) { switch (e.tag) { case 3: Et(e, e.stateNode.containerInfo), yn(e, Yt, t.memoizedState.cache), xi(); break; case 27: case 5: iu(e); break; case 4: Et(e, e.stateNode.containerInfo); break; case 10: yn(e, e.type, e.memoizedProps.value); break; case 13: var a = e.memoizedState; if (a !== null) return a.dehydrated !== null ? (Tn(e), e.flags |= 128, null) : (n & e.child.childLanes) !== 0 ? hd(t, e, n) : (Tn(e), t = nn(t, e, n), t !== null ? t.sibling : null); Tn(e); break; case 19: var s = (t.flags & 128) !== 0; if (a = (n & e.childLanes) !== 0, a || (Mi(t, e, n, !1), a = (n & e.childLanes) !== 0), s) { if (a) return md(t, e, n); e.flags |= 128 } if (s = e.memoizedState, s !== null && (s.rendering = null, s.tail = null, s.lastEffect = null), G(Gt, Gt.current), a) break; return null; case 22: case 23: return e.lanes = 0, ud(t, e, n); case 24: yn(e, Yt, t.memoizedState.cache) }return nn(t, e, n) } function pd(t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps) Kt = !0; else { if (!Vo(t, n) && (e.flags & 128) === 0) return Kt = !1, uv(t, e, n); Kt = (t.flags & 131072) !== 0 } else Kt = !1, pt && (e.flags & 1048576) !== 0 && Kf(e, Kl, e.index); switch (e.lanes = 0, e.tag) { case 16: t: { t = e.pendingProps; var a = e.elementType, s = a._init; if (a = s(a._payload), e.type = a, typeof a == "function") Lu(a) ? (t = ea(a, t), e.tag = 1, e = cd(null, e, a, t, n)) : (e.tag = 0, e = xo(null, e, a, t, n)); else { if (a != null) { if (s = a.$$typeof, s === et) { e.tag = 11, e = id(null, e, a, t, n); break t } else if (s === nt) { e.tag = 14, e = ld(null, e, a, t, n); break t } } throw e = je(a) || a, Error(o(306, e, "")) } } return e; case 0: return xo(t, e, e.type, e.pendingProps, n); case 1: return a = e.type, s = ea(a, e.pendingProps), cd(t, e, a, s, n); case 3: t: { if (Et(e, e.stateNode.containerInfo), t === null) throw Error(o(387)); a = e.pendingProps; var r = e.memoizedState; s = r.element, $u(t, e), Ni(e, a, null, n); var f = e.memoizedState; if (a = f.cache, yn(e, Yt, a), a !== r.cache && Qu(e, [Yt], n, !0), zi(), a = f.element, r.isDehydrated) if (r = { element: a, isDehydrated: !1, cache: f.cache }, e.updateQueue.baseState = r, e.memoizedState = r, e.flags & 256) { e = fd(t, e, a, n); break t } else if (a !== s) { s = Ae(Error(o(424)), e), Ei(s), e = fd(t, e, a, n); break t } else { switch (t = e.stateNode.containerInfo, t.nodeType) { case 9: t = t.body; break; default: t = t.nodeName === "HTML" ? t.ownerDocument.body : t }for (Vt = _e(t.firstChild), ne = e, pt = !0, Pn = null, Le = !0, n = Jh(e, null, a, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling } else { if (xi(), a === s) { e = nn(t, e, n); break t } kt(t, e, a, n) } e = e.child } return e; case 26: return fs(t, e), t === null ? (n = Sm(e.type, null, e.pendingProps, null)) ? e.memoizedState = n : pt || (n = e.type, t = e.pendingProps, a = Ds(lt.current).createElement(n), a[$t] = e, a[ie] = t, Ft(a, n, t), Zt(a), e.stateNode = a) : e.memoizedState = Sm(e.type, t.memoizedProps, e.pendingProps, t.memoizedState), null; case 27: return iu(e), t === null && pt && (a = e.stateNode = ym(e.type, e.pendingProps, lt.current), ne = e, Le = !0, s = Vt, zn(e.type) ? (cr = s, Vt = _e(a.firstChild)) : Vt = s), kt(t, e, e.pendingProps.children, n), fs(t, e), t === null && (e.flags |= 4194304), e.child; case 5: return t === null && pt && ((s = a = Vt) && (a = Bv(a, e.type, e.pendingProps, Le), a !== null ? (e.stateNode = a, ne = e, Vt = _e(a.firstChild), Le = !1, s = !0) : s = !1), s || Fn(e)), iu(e), s = e.type, r = e.pendingProps, f = t !== null ? t.memoizedProps : null, a = r.children, sr(s, r) ? a = null : f !== null && sr(s, f) && (e.flags |= 32), e.memoizedState !== null && (s = io(t, e, I0, null, null, n), tl._currentValue = s), fs(t, e), kt(t, e, a, n), e.child; case 6: return t === null && pt && ((t = n = Vt) && (n = jv(n, e.pendingProps, Le), n !== null ? (e.stateNode = n, ne = e, Vt = null, t = !0) : t = !1), t || Fn(e)), null; case 13: return hd(t, e, n); case 4: return Et(e, e.stateNode.containerInfo), a = e.pendingProps, t === null ? e.child = ja(e, null, a, n) : kt(t, e, a, n), e.child; case 11: return id(t, e, e.type, e.pendingProps, n); case 7: return kt(t, e, e.pendingProps, n), e.child; case 8: return kt(t, e, e.pendingProps.children, n), e.child; case 12: return kt(t, e, e.pendingProps.children, n), e.child; case 10: return a = e.pendingProps, yn(e, e.type, a.value), kt(t, e, a.children, n), e.child; case 9: return s = e.type._context, a = e.pendingProps.children, $n(e), s = It(s), a = a(s), e.flags |= 1, kt(t, e, a, n), e.child; case 14: return ld(t, e, e.type, e.pendingProps, n); case 15: return sd(t, e, e.type, e.pendingProps, n); case 19: return md(t, e, n); case 31: return a = e.pendingProps, n = e.mode, a = { mode: a.mode, children: a.children }, t === null ? (n = hs(a, n), n.ref = e.ref, e.child = n, n.return = e, e = n) : (n = Pe(t.child, a), n.ref = e.ref, e.child = n, n.return = e, e = n), e; case 22: return ud(t, e, n); case 24: return $n(e), a = It(Yt), t === null ? (s = Pu(), s === null && (s = xt, r = Ju(), s.pooledCache = r, r.refCount++, r !== null && (s.pooledCacheLanes |= n), s = r), e.memoizedState = { parent: a, cache: s }, Wu(e), yn(e, Yt, s)) : ((t.lanes & n) !== 0 && ($u(t, e), Ni(e, null, null, n), zi()), s = t.memoizedState, r = e.memoizedState, s.parent !== a ? (s = { parent: a, cache: a }, e.memoizedState = s, e.lanes === 0 && (e.memoizedState = e.updateQueue.baseState = s), yn(e, Yt, a)) : (a = r.cache, yn(e, Yt, a), a !== s.cache && Qu(e, [Yt], n, !0))), kt(t, e, e.pendingProps.children, n), e.child; case 29: throw e.pendingProps }throw Error(o(156, e.tag)) } function an(t) { t.flags |= 4 } function yd(t, e) { if (e.type !== "stylesheet" || (e.state.loading & 4) !== 0) t.flags &= -16777217; else if (t.flags |= 16777216, !Em(e)) { if (e = De.current, e !== null && ((ht & 4194048) === ht ? He !== null : (ht & 62914560) !== ht && (ht & 536870912) === 0 || e !== He)) throw Ci = Fu, If; t.flags |= 8192 } } function ds(t, e) { e !== null && (t.flags |= 4), t.flags & 16384 && (e = t.tag !== 22 ? Jc() : 536870912, t.lanes |= e, qa |= e) } function Hi(t, e) { if (!pt) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var a = null; n !== null;)n.alternate !== null && (a = n), n = n.sibling; a === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : a.sibling = null } } function Rt(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, a = 0; if (e) for (var s = t.child; s !== null;)n |= s.lanes | s.childLanes, a |= s.subtreeFlags & 65011712, a |= s.flags & 65011712, s.return = t, s = s.sibling; else for (s = t.child; s !== null;)n |= s.lanes | s.childLanes, a |= s.subtreeFlags, a |= s.flags, s.return = t, s = s.sibling; return t.subtreeFlags |= a, t.childLanes = n, e } function ov(t, e, n) { var a = e.pendingProps; switch (Gu(e), e.tag) { case 31: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Rt(e), null; case 1: return Rt(e), null; case 3: return n = e.stateNode, a = null, t !== null && (a = t.memoizedState.cache), e.memoizedState.cache !== a && (e.flags |= 2048), Ie(Yt), hn(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (t === null || t.child === null) && (Ai(e) ? an(e) : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, kf())), Rt(e), null; case 26: return n = e.memoizedState, t === null ? (an(e), n !== null ? (Rt(e), yd(e, n)) : (Rt(e), e.flags &= -16777217)) : n ? n !== t.memoizedState ? (an(e), Rt(e), yd(e, n)) : (Rt(e), e.flags &= -16777217) : (t.memoizedProps !== a && an(e), Rt(e), e.flags &= -16777217), null; case 27: El(e), n = lt.current; var s = e.type; if (t !== null && e.stateNode != null) t.memoizedProps !== a && an(e); else { if (!a) { if (e.stateNode === null) throw Error(o(166)); return Rt(e), null } t = $.current, Ai(e) ? Qf(e) : (t = ym(s, a, n), e.stateNode = t, an(e)) } return Rt(e), null; case 5: if (El(e), n = e.type, t !== null && e.stateNode != null) t.memoizedProps !== a && an(e); else { if (!a) { if (e.stateNode === null) throw Error(o(166)); return Rt(e), null } if (t = $.current, Ai(e)) Qf(e); else { switch (s = Ds(lt.current), t) { case 1: t = s.createElementNS("http://www.w3.org/2000/svg", n); break; case 2: t = s.createElementNS("http://www.w3.org/1998/Math/MathML", n); break; default: switch (n) { case "svg": t = s.createElementNS("http://www.w3.org/2000/svg", n); break; case "math": t = s.createElementNS("http://www.w3.org/1998/Math/MathML", n); break; case "script": t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild); break; case "select": t = typeof a.is == "string" ? s.createElement("select", { is: a.is }) : s.createElement("select"), a.multiple ? t.multiple = !0 : a.size && (t.size = a.size); break; default: t = typeof a.is == "string" ? s.createElement(n, { is: a.is }) : s.createElement(n) } }t[$t] = e, t[ie] = a; t: for (s = e.child; s !== null;) { if (s.tag === 5 || s.tag === 6) t.appendChild(s.stateNode); else if (s.tag !== 4 && s.tag !== 27 && s.child !== null) { s.child.return = s, s = s.child; continue } if (s === e) break t; for (; s.sibling === null;) { if (s.return === null || s.return === e) break t; s = s.return } s.sibling.return = s.return, s = s.sibling } e.stateNode = t; t: switch (Ft(t, n, a), n) { case "button": case "input": case "select": case "textarea": t = !!a.autoFocus; break t; case "img": t = !0; break t; default: t = !1 }t && an(e) } } return Rt(e), e.flags &= -16777217, null; case 6: if (t && e.stateNode != null) t.memoizedProps !== a && an(e); else { if (typeof a != "string" && e.stateNode === null) throw Error(o(166)); if (t = lt.current, Ai(e)) { if (t = e.stateNode, n = e.memoizedProps, a = null, s = ne, s !== null) switch (s.tag) { case 27: case 5: a = s.memoizedProps }t[$t] = e, t = !!(t.nodeValue === n || a !== null && a.suppressHydrationWarning === !0 || rm(t.nodeValue, n)), t || Fn(e) } else t = Ds(t).createTextNode(a), t[$t] = e, e.stateNode = t } return Rt(e), null; case 13: if (a = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (s = Ai(e), a !== null && a.dehydrated !== null) { if (t === null) { if (!s) throw Error(o(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(o(317)); s[$t] = e } else xi(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4; Rt(e), s = !1 } else s = kf(), t !== null && t.memoizedState !== null && (t.memoizedState.hydrationErrors = s), s = !0; if (!s) return e.flags & 256 ? (en(e), e) : (en(e), null) } if (en(e), (e.flags & 128) !== 0) return e.lanes = n, e; if (n = a !== null, t = t !== null && t.memoizedState !== null, n) { a = e.child, s = null, a.alternate !== null && a.alternate.memoizedState !== null && a.alternate.memoizedState.cachePool !== null && (s = a.alternate.memoizedState.cachePool.pool); var r = null; a.memoizedState !== null && a.memoizedState.cachePool !== null && (r = a.memoizedState.cachePool.pool), r !== s && (a.flags |= 2048) } return n !== t && n && (e.child.flags |= 8192), ds(e, e.updateQueue), Rt(e), null; case 4: return hn(), t === null && er(e.stateNode.containerInfo), Rt(e), null; case 10: return Ie(e.type), Rt(e), null; case 19: if (K(Gt), s = e.memoizedState, s === null) return Rt(e), null; if (a = (e.flags & 128) !== 0, r = s.rendering, r === null) if (a) Hi(s, !1); else { if (zt !== 0 || t !== null && (t.flags & 128) !== 0) for (t = e.child; t !== null;) { if (r = os(t), r !== null) { for (e.flags |= 128, Hi(s, !1), t = r.updateQueue, e.updateQueue = t, ds(e, t), e.subtreeFlags = 0, t = n, n = e.child; n !== null;)Zf(n, t), n = n.sibling; return G(Gt, Gt.current & 1 | 2), e.child } t = t.sibling } s.tail !== null && we() > ys && (e.flags |= 128, a = !0, Hi(s, !1), e.lanes = 4194304) } else { if (!a) if (t = os(r), t !== null) { if (e.flags |= 128, a = !0, t = t.updateQueue, e.updateQueue = t, ds(e, t), Hi(s, !0), s.tail === null && s.tailMode === "hidden" && !r.alternate && !pt) return Rt(e), null } else 2 * we() - s.renderingStartTime > ys && n !== 536870912 && (e.flags |= 128, a = !0, Hi(s, !1), e.lanes = 4194304); s.isBackwards ? (r.sibling = e.child, e.child = r) : (t = s.last, t !== null ? t.sibling = r : e.child = r, s.last = r) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = we(), e.sibling = null, t = Gt.current, G(Gt, a ? t & 1 | 2 : t & 1), e) : (Rt(e), null); case 22: case 23: return en(e), no(), a = e.memoizedState !== null, t !== null ? t.memoizedState !== null !== a && (e.flags |= 8192) : a && (e.flags |= 8192), a ? (n & 536870912) !== 0 && (e.flags & 128) === 0 && (Rt(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Rt(e), n = e.updateQueue, n !== null && ds(e, n.retryQueue), n = null, t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (n = t.memoizedState.cachePool.pool), a = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (a = e.memoizedState.cachePool.pool), a !== n && (e.flags |= 2048), t !== null && K(In), null; case 24: return n = null, t !== null && (n = t.memoizedState.cache), e.memoizedState.cache !== n && (e.flags |= 2048), Ie(Yt), Rt(e), null; case 25: return null; case 30: return null }throw Error(o(156, e.tag)) } function rv(t, e) { switch (Gu(e), e.tag) { case 1: return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return Ie(Yt), hn(), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null; case 26: case 27: case 5: return El(e), null; case 13: if (en(e), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(o(340)); xi() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return K(Gt), null; case 4: return hn(), null; case 10: return Ie(e.type), null; case 22: case 23: return en(e), no(), t !== null && K(In), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 24: return Ie(Yt), null; case 25: return null; default: return null } } function gd(t, e) { switch (Gu(e), e.tag) { case 3: Ie(Yt), hn(); break; case 26: case 27: case 5: El(e); break; case 4: hn(); break; case 13: en(e); break; case 19: K(Gt); break; case 10: Ie(e.type); break; case 22: case 23: en(e), no(), t !== null && K(In); break; case 24: Ie(Yt) } } function qi(t, e) { try { var n = e.updateQueue, a = n !== null ? n.lastEffect : null; if (a !== null) { var s = a.next; n = s; do { if ((n.tag & t) === t) { a = void 0; var r = n.create, f = n.inst; a = r(), f.destroy = a } n = n.next } while (n !== s) } } catch (p) { At(e, e.return, p) } } function xn(t, e, n) { try { var a = e.updateQueue, s = a !== null ? a.lastEffect : null; if (s !== null) { var r = s.next; a = r; do { if ((a.tag & t) === t) { var f = a.inst, p = f.destroy; if (p !== void 0) { f.destroy = void 0, s = e; var S = n, D = p; try { D() } catch (C) { At(s, S, C) } } } a = a.next } while (a !== r) } } catch (C) { At(e, e.return, C) } } function vd(t) { var e = t.updateQueue; if (e !== null) { var n = t.stateNode; try { lh(e, n) } catch (a) { At(t, t.return, a) } } } function Sd(t, e, n) { n.props = ea(t.type, t.memoizedProps), n.state = t.memoizedState; try { n.componentWillUnmount() } catch (a) { At(t, e, a) } } function Yi(t, e) { try { var n = t.ref; if (n !== null) { switch (t.tag) { case 26: case 27: case 5: var a = t.stateNode; break; case 30: a = t.stateNode; break; default: a = t.stateNode }typeof n == "function" ? t.refCleanup = n(a) : n.current = a } } catch (s) { At(t, e, s) } } function qe(t, e) { var n = t.ref, a = t.refCleanup; if (n !== null) if (typeof a == "function") try { a() } catch (s) { At(t, e, s) } finally { t.refCleanup = null, t = t.alternate, t != null && (t.refCleanup = null) } else if (typeof n == "function") try { n(null) } catch (s) { At(t, e, s) } else n.current = null } function bd(t) { var e = t.type, n = t.memoizedProps, a = t.stateNode; try { t: switch (e) { case "button": case "input": case "select": case "textarea": n.autoFocus && a.focus(); break t; case "img": n.src ? a.src = n.src : n.srcSet && (a.srcset = n.srcSet) } } catch (s) { At(t, t.return, s) } } function zo(t, e, n) { try { var a = t.stateNode; Vv(a, t.type, n, e), a[ie] = e } catch (s) { At(t, t.return, s) } } function Td(t) { return t.tag === 5 || t.tag === 3 || t.tag === 26 || t.tag === 27 && zn(t.type) || t.tag === 4 } function No(t) { t: for (; ;) { for (; t.sibling === null;) { if (t.return === null || Td(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.tag === 27 && zn(t.type) || t.flags & 2 || t.child === null || t.tag === 4) continue t; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function Uo(t, e, n) { var a = t.tag; if (a === 5 || a === 6) t = t.stateNode, e ? (n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n).insertBefore(t, e) : (e = n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n, e.appendChild(t), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = Ms)); else if (a !== 4 && (a === 27 && zn(t.type) && (n = t.stateNode, e = null), t = t.child, t !== null)) for (Uo(t, e, n), t = t.sibling; t !== null;)Uo(t, e, n), t = t.sibling } function ms(t, e, n) { var a = t.tag; if (a === 5 || a === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (a !== 4 && (a === 27 && zn(t.type) && (n = t.stateNode), t = t.child, t !== null)) for (ms(t, e, n), t = t.sibling; t !== null;)ms(t, e, n), t = t.sibling } function Ad(t) { var e = t.stateNode, n = t.memoizedProps; try { for (var a = t.type, s = e.attributes; s.length;)e.removeAttributeNode(s[0]); Ft(e, a, n), e[$t] = t, e[ie] = n } catch (r) { At(t, t.return, r) } } var ln = !1, _t = !1, _o = !1, xd = typeof WeakSet == "function" ? WeakSet : Set, Qt = null; function cv(t, e) { if (t = t.containerInfo, ir = Ns, t = _f(t), zu(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else t: { n = (n = t.ownerDocument) && n.defaultView || window; var a = n.getSelection && n.getSelection(); if (a && a.rangeCount !== 0) { n = a.anchorNode; var s = a.anchorOffset, r = a.focusNode; a = a.focusOffset; try { n.nodeType, r.nodeType } catch { n = null; break t } var f = 0, p = -1, S = -1, D = 0, C = 0, _ = t, R = null; e: for (; ;) { for (var O; _ !== n || s !== 0 && _.nodeType !== 3 || (p = f + s), _ !== r || a !== 0 && _.nodeType !== 3 || (S = f + a), _.nodeType === 3 && (f += _.nodeValue.length), (O = _.firstChild) !== null;)R = _, _ = O; for (; ;) { if (_ === t) break e; if (R === n && ++D === s && (p = f), R === r && ++C === a && (S = f), (O = _.nextSibling) !== null) break; _ = R, R = _.parentNode } _ = O } n = p === -1 || S === -1 ? null : { start: p, end: S } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (lr = { focusedElem: t, selectionRange: n }, Ns = !1, Qt = e; Qt !== null;)if (e = Qt, t = e.child, (e.subtreeFlags & 1024) !== 0 && t !== null) t.return = e, Qt = t; else for (; Qt !== null;) { switch (e = Qt, r = e.alternate, t = e.flags, e.tag) { case 0: break; case 11: case 15: break; case 1: if ((t & 1024) !== 0 && r !== null) { t = void 0, n = e, s = r.memoizedProps, r = r.memoizedState, a = n.stateNode; try { var at = ea(n.type, s, n.elementType === n.type); t = a.getSnapshotBeforeUpdate(at, r), a.__reactInternalSnapshotBeforeUpdate = t } catch (I) { At(n, n.return, I) } } break; case 3: if ((t & 1024) !== 0) { if (t = e.stateNode.containerInfo, n = t.nodeType, n === 9) or(t); else if (n === 1) switch (t.nodeName) { case "HEAD": case "HTML": case "BODY": or(t); break; default: t.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if ((t & 1024) !== 0) throw Error(o(163)) }if (t = e.sibling, t !== null) { t.return = e.return, Qt = t; break } Qt = e.return } } function Ed(t, e, n) { var a = n.flags; switch (n.tag) { case 0: case 11: case 15: En(t, n), a & 4 && qi(5, n); break; case 1: if (En(t, n), a & 4) if (t = n.stateNode, e === null) try { t.componentDidMount() } catch (f) { At(n, n.return, f) } else { var s = ea(n.type, e.memoizedProps); e = e.memoizedState; try { t.componentDidUpdate(s, e, t.__reactInternalSnapshotBeforeUpdate) } catch (f) { At(n, n.return, f) } } a & 64 && vd(n), a & 512 && Yi(n, n.return); break; case 3: if (En(t, n), a & 64 && (t = n.updateQueue, t !== null)) { if (e = null, n.child !== null) switch (n.child.tag) { case 27: case 5: e = n.child.stateNode; break; case 1: e = n.child.stateNode }try { lh(t, e) } catch (f) { At(n, n.return, f) } } break; case 27: e === null && a & 4 && Ad(n); case 26: case 5: En(t, n), e === null && a & 4 && bd(n), a & 512 && Yi(n, n.return); break; case 12: En(t, n); break; case 13: En(t, n), a & 4 && Rd(t, n), a & 64 && (t = n.memoizedState, t !== null && (t = t.dehydrated, t !== null && (n = Sv.bind(null, n), wv(t, n)))); break; case 22: if (a = n.memoizedState !== null || ln, !a) { e = e !== null && e.memoizedState !== null || _t, s = ln; var r = _t; ln = a, (_t = e) && !r ? Mn(t, n, (n.subtreeFlags & 8772) !== 0) : En(t, n), ln = s, _t = r } break; case 30: break; default: En(t, n) } } function Md(t) { var e = t.alternate; e !== null && (t.alternate = null, Md(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && hu(e)), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } var Mt = null, ue = !1; function sn(t, e, n) { for (n = n.child; n !== null;)Dd(t, e, n), n = n.sibling } function Dd(t, e, n) { if (fe && typeof fe.onCommitFiberUnmount == "function") try { fe.onCommitFiberUnmount(oi, n) } catch { } switch (n.tag) { case 26: _t || qe(n, e), sn(t, e, n), n.memoizedState ? n.memoizedState.count-- : n.stateNode && (n = n.stateNode, n.parentNode.removeChild(n)); break; case 27: _t || qe(n, e); var a = Mt, s = ue; zn(n.type) && (Mt = n.stateNode, ue = !1), sn(t, e, n), Fi(n.stateNode), Mt = a, ue = s; break; case 5: _t || qe(n, e); case 6: if (a = Mt, s = ue, Mt = null, sn(t, e, n), Mt = a, ue = s, Mt !== null) if (ue) try { (Mt.nodeType === 9 ? Mt.body : Mt.nodeName === "HTML" ? Mt.ownerDocument.body : Mt).removeChild(n.stateNode) } catch (r) { At(n, e, r) } else try { Mt.removeChild(n.stateNode) } catch (r) { At(n, e, r) } break; case 18: Mt !== null && (ue ? (t = Mt, mm(t.nodeType === 9 ? t.body : t.nodeName === "HTML" ? t.ownerDocument.body : t, n.stateNode), il(t)) : mm(Mt, n.stateNode)); break; case 4: a = Mt, s = ue, Mt = n.stateNode.containerInfo, ue = !0, sn(t, e, n), Mt = a, ue = s; break; case 0: case 11: case 14: case 15: _t || xn(2, n, e), _t || xn(4, n, e), sn(t, e, n); break; case 1: _t || (qe(n, e), a = n.stateNode, typeof a.componentWillUnmount == "function" && Sd(n, e, a)), sn(t, e, n); break; case 21: sn(t, e, n); break; case 22: _t = (a = _t) || n.memoizedState !== null, sn(t, e, n), _t = a; break; default: sn(t, e, n) } } function Rd(t, e) { if (e.memoizedState === null && (t = e.alternate, t !== null && (t = t.memoizedState, t !== null && (t = t.dehydrated, t !== null)))) try { il(t) } catch (n) { At(e, e.return, n) } } function fv(t) { switch (t.tag) { case 13: case 19: var e = t.stateNode; return e === null && (e = t.stateNode = new xd), e; case 22: return t = t.stateNode, e = t._retryCache, e === null && (e = t._retryCache = new xd), e; default: throw Error(o(435, t.tag)) } } function Bo(t, e) { var n = fv(t); e.forEach(function (a) { var s = bv.bind(null, t, a); n.has(a) || (n.add(a), a.then(s, s)) }) } function pe(t, e) { var n = e.deletions; if (n !== null) for (var a = 0; a < n.length; a++) { var s = n[a], r = t, f = e, p = f; t: for (; p !== null;) { switch (p.tag) { case 27: if (zn(p.type)) { Mt = p.stateNode, ue = !1; break t } break; case 5: Mt = p.stateNode, ue = !1; break t; case 3: case 4: Mt = p.stateNode.containerInfo, ue = !0; break t }p = p.return } if (Mt === null) throw Error(o(160)); Dd(r, f, s), Mt = null, ue = !1, r = s.alternate, r !== null && (r.return = null), s.return = null } if (e.subtreeFlags & 13878) for (e = e.child; e !== null;)Od(e, t), e = e.sibling } var Ue = null; function Od(t, e) { var n = t.alternate, a = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: pe(e, t), ye(t), a & 4 && (xn(3, t, t.return), qi(3, t), xn(5, t, t.return)); break; case 1: pe(e, t), ye(t), a & 512 && (_t || n === null || qe(n, n.return)), a & 64 && ln && (t = t.updateQueue, t !== null && (a = t.callbacks, a !== null && (n = t.shared.hiddenCallbacks, t.shared.hiddenCallbacks = n === null ? a : n.concat(a)))); break; case 26: var s = Ue; if (pe(e, t), ye(t), a & 512 && (_t || n === null || qe(n, n.return)), a & 4) { var r = n !== null ? n.memoizedState : null; if (a = t.memoizedState, n === null) if (a === null) if (t.stateNode === null) { t: { a = t.type, n = t.memoizedProps, s = s.ownerDocument || s; e: switch (a) { case "title": r = s.getElementsByTagName("title")[0], (!r || r[fi] || r[$t] || r.namespaceURI === "http://www.w3.org/2000/svg" || r.hasAttribute("itemprop")) && (r = s.createElement(a), s.head.insertBefore(r, s.querySelector("head > title"))), Ft(r, a, n), r[$t] = t, Zt(r), a = r; break t; case "link": var f = Am("link", "href", s).get(a + (n.href || "")); if (f) { for (var p = 0; p < f.length; p++)if (r = f[p], r.getAttribute("href") === (n.href == null || n.href === "" ? null : n.href) && r.getAttribute("rel") === (n.rel == null ? null : n.rel) && r.getAttribute("title") === (n.title == null ? null : n.title) && r.getAttribute("crossorigin") === (n.crossOrigin == null ? null : n.crossOrigin)) { f.splice(p, 1); break e } } r = s.createElement(a), Ft(r, a, n), s.head.appendChild(r); break; case "meta": if (f = Am("meta", "content", s).get(a + (n.content || ""))) { for (p = 0; p < f.length; p++)if (r = f[p], r.getAttribute("content") === (n.content == null ? null : "" + n.content) && r.getAttribute("name") === (n.name == null ? null : n.name) && r.getAttribute("property") === (n.property == null ? null : n.property) && r.getAttribute("http-equiv") === (n.httpEquiv == null ? null : n.httpEquiv) && r.getAttribute("charset") === (n.charSet == null ? null : n.charSet)) { f.splice(p, 1); break e } } r = s.createElement(a), Ft(r, a, n), s.head.appendChild(r); break; default: throw Error(o(468, a)) }r[$t] = t, Zt(r), a = r } t.stateNode = a } else xm(s, t.type, t.stateNode); else t.stateNode = Tm(s, a, t.memoizedProps); else r !== a ? (r === null ? n.stateNode !== null && (n = n.stateNode, n.parentNode.removeChild(n)) : r.count--, a === null ? xm(s, t.type, t.stateNode) : Tm(s, a, t.memoizedProps)) : a === null && t.stateNode !== null && zo(t, t.memoizedProps, n.memoizedProps) } break; case 27: pe(e, t), ye(t), a & 512 && (_t || n === null || qe(n, n.return)), n !== null && a & 4 && zo(t, t.memoizedProps, n.memoizedProps); break; case 5: if (pe(e, t), ye(t), a & 512 && (_t || n === null || qe(n, n.return)), t.flags & 32) { s = t.stateNode; try { va(s, "") } catch (O) { At(t, t.return, O) } } a & 4 && t.stateNode != null && (s = t.memoizedProps, zo(t, s, n !== null ? n.memoizedProps : s)), a & 1024 && (_o = !0); break; case 6: if (pe(e, t), ye(t), a & 4) { if (t.stateNode === null) throw Error(o(162)); a = t.memoizedProps, n = t.stateNode; try { n.nodeValue = a } catch (O) { At(t, t.return, O) } } break; case 3: if (Cs = null, s = Ue, Ue = Rs(e.containerInfo), pe(e, t), Ue = s, ye(t), a & 4 && n !== null && n.memoizedState.isDehydrated) try { il(e.containerInfo) } catch (O) { At(t, t.return, O) } _o && (_o = !1, Cd(t)); break; case 4: a = Ue, Ue = Rs(t.stateNode.containerInfo), pe(e, t), ye(t), Ue = a; break; case 12: pe(e, t), ye(t); break; case 13: pe(e, t), ye(t), t.child.flags & 8192 && t.memoizedState !== null != (n !== null && n.memoizedState !== null) && (Yo = we()), a & 4 && (a = t.updateQueue, a !== null && (t.updateQueue = null, Bo(t, a))); break; case 22: s = t.memoizedState !== null; var S = n !== null && n.memoizedState !== null, D = ln, C = _t; if (ln = D || s, _t = C || S, pe(e, t), _t = C, ln = D, ye(t), a & 8192) t: for (e = t.stateNode, e._visibility = s ? e._visibility & -2 : e._visibility | 1, s && (n === null || S || ln || _t || na(t)), n = null, e = t; ;) { if (e.tag === 5 || e.tag === 26) { if (n === null) { S = n = e; try { if (r = S.stateNode, s) f = r.style, typeof f.setProperty == "function" ? f.setProperty("display", "none", "important") : f.display = "none"; else { p = S.stateNode; var _ = S.memoizedProps.style, R = _ != null && _.hasOwnProperty("display") ? _.display : null; p.style.display = R == null || typeof R == "boolean" ? "" : ("" + R).trim() } } catch (O) { At(S, S.return, O) } } } else if (e.tag === 6) { if (n === null) { S = e; try { S.stateNode.nodeValue = s ? "" : S.memoizedProps } catch (O) { At(S, S.return, O) } } } else if ((e.tag !== 22 && e.tag !== 23 || e.memoizedState === null || e === t) && e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break t; for (; e.sibling === null;) { if (e.return === null || e.return === t) break t; n === e && (n = null), e = e.return } n === e && (n = null), e.sibling.return = e.return, e = e.sibling } a & 4 && (a = t.updateQueue, a !== null && (n = a.retryQueue, n !== null && (a.retryQueue = null, Bo(t, n)))); break; case 19: pe(e, t), ye(t), a & 4 && (a = t.updateQueue, a !== null && (t.updateQueue = null, Bo(t, a))); break; case 30: break; case 21: break; default: pe(e, t), ye(t) } } function ye(t) { var e = t.flags; if (e & 2) { try { for (var n, a = t.return; a !== null;) { if (Td(a)) { n = a; break } a = a.return } if (n == null) throw Error(o(160)); switch (n.tag) { case 27: var s = n.stateNode, r = No(t); ms(t, r, s); break; case 5: var f = n.stateNode; n.flags & 32 && (va(f, ""), n.flags &= -33); var p = No(t); ms(t, p, f); break; case 3: case 4: var S = n.stateNode.containerInfo, D = No(t); Uo(t, D, S); break; default: throw Error(o(161)) } } catch (C) { At(t, t.return, C) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function Cd(t) { if (t.subtreeFlags & 1024) for (t = t.child; t !== null;) { var e = t; Cd(e), e.tag === 5 && e.flags & 1024 && e.stateNode.reset(), t = t.sibling } } function En(t, e) { if (e.subtreeFlags & 8772) for (e = e.child; e !== null;)Ed(t, e.alternate, e), e = e.sibling } function na(t) { for (t = t.child; t !== null;) { var e = t; switch (e.tag) { case 0: case 11: case 14: case 15: xn(4, e, e.return), na(e); break; case 1: qe(e, e.return); var n = e.stateNode; typeof n.componentWillUnmount == "function" && Sd(e, e.return, n), na(e); break; case 27: Fi(e.stateNode); case 26: case 5: qe(e, e.return), na(e); break; case 22: e.memoizedState === null && na(e); break; case 30: na(e); break; default: na(e) }t = t.sibling } } function Mn(t, e, n) { for (n = n && (e.subtreeFlags & 8772) !== 0, e = e.child; e !== null;) { var a = e.alternate, s = t, r = e, f = r.flags; switch (r.tag) { case 0: case 11: case 15: Mn(s, r, n), qi(4, r); break; case 1: if (Mn(s, r, n), a = r, s = a.stateNode, typeof s.componentDidMount == "function") try { s.componentDidMount() } catch (D) { At(a, a.return, D) } if (a = r, s = a.updateQueue, s !== null) { var p = a.stateNode; try { var S = s.shared.hiddenCallbacks; if (S !== null) for (s.shared.hiddenCallbacks = null, s = 0; s < S.length; s++)ih(S[s], p) } catch (D) { At(a, a.return, D) } } n && f & 64 && vd(r), Yi(r, r.return); break; case 27: Ad(r); case 26: case 5: Mn(s, r, n), n && a === null && f & 4 && bd(r), Yi(r, r.return); break; case 12: Mn(s, r, n); break; case 13: Mn(s, r, n), n && f & 4 && Rd(s, r); break; case 22: r.memoizedState === null && Mn(s, r, n), Yi(r, r.return); break; case 30: break; default: Mn(s, r, n) }e = e.sibling } } function jo(t, e) { var n = null; t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (n = t.memoizedState.cachePool.pool), t = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (t = e.memoizedState.cachePool.pool), t !== n && (t != null && t.refCount++, n != null && Di(n)) } function wo(t, e) { t = null, e.alternate !== null && (t = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== t && (e.refCount++, t != null && Di(t)) } function Ye(t, e, n, a) { if (e.subtreeFlags & 10256) for (e = e.child; e !== null;)Vd(t, e, n, a), e = e.sibling } function Vd(t, e, n, a) { var s = e.flags; switch (e.tag) { case 0: case 11: case 15: Ye(t, e, n, a), s & 2048 && qi(9, e); break; case 1: Ye(t, e, n, a); break; case 3: Ye(t, e, n, a), s & 2048 && (t = null, e.alternate !== null && (t = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== t && (e.refCount++, t != null && Di(t))); break; case 12: if (s & 2048) { Ye(t, e, n, a), t = e.stateNode; try { var r = e.memoizedProps, f = r.id, p = r.onPostCommit; typeof p == "function" && p(f, e.alternate === null ? "mount" : "update", t.passiveEffectDuration, -0) } catch (S) { At(e, e.return, S) } } else Ye(t, e, n, a); break; case 13: Ye(t, e, n, a); break; case 23: break; case 22: r = e.stateNode, f = e.alternate, e.memoizedState !== null ? r._visibility & 2 ? Ye(t, e, n, a) : Gi(t, e) : r._visibility & 2 ? Ye(t, e, n, a) : (r._visibility |= 2, wa(t, e, n, a, (e.subtreeFlags & 10256) !== 0)), s & 2048 && jo(f, e); break; case 24: Ye(t, e, n, a), s & 2048 && wo(e.alternate, e); break; default: Ye(t, e, n, a) } } function wa(t, e, n, a, s) { for (s = s && (e.subtreeFlags & 10256) !== 0, e = e.child; e !== null;) { var r = t, f = e, p = n, S = a, D = f.flags; switch (f.tag) { case 0: case 11: case 15: wa(r, f, p, S, s), qi(8, f); break; case 23: break; case 22: var C = f.stateNode; f.memoizedState !== null ? C._visibility & 2 ? wa(r, f, p, S, s) : Gi(r, f) : (C._visibility |= 2, wa(r, f, p, S, s)), s && D & 2048 && jo(f.alternate, f); break; case 24: wa(r, f, p, S, s), s && D & 2048 && wo(f.alternate, f); break; default: wa(r, f, p, S, s) }e = e.sibling } } function Gi(t, e) { if (e.subtreeFlags & 10256) for (e = e.child; e !== null;) { var n = t, a = e, s = a.flags; switch (a.tag) { case 22: Gi(n, a), s & 2048 && jo(a.alternate, a); break; case 24: Gi(n, a), s & 2048 && wo(a.alternate, a); break; default: Gi(n, a) }e = e.sibling } } var Xi = 8192; function La(t) { if (t.subtreeFlags & Xi) for (t = t.child; t !== null;)zd(t), t = t.sibling } function zd(t) { switch (t.tag) { case 26: La(t), t.flags & Xi && t.memoizedState !== null && Fv(Ue, t.memoizedState, t.memoizedProps); break; case 5: La(t); break; case 3: case 4: var e = Ue; Ue = Rs(t.stateNode.containerInfo), La(t), Ue = e; break; case 22: t.memoizedState === null && (e = t.alternate, e !== null && e.memoizedState !== null ? (e = Xi, Xi = 16777216, La(t), Xi = e) : La(t)); break; default: La(t) } } function Nd(t) { var e = t.alternate; if (e !== null && (t = e.child, t !== null)) { e.child = null; do e = t.sibling, t.sibling = null, t = e; while (t !== null) } } function Zi(t) { var e = t.deletions; if ((t.flags & 16) !== 0) { if (e !== null) for (var n = 0; n < e.length; n++) { var a = e[n]; Qt = a, _d(a, t) } Nd(t) } if (t.subtreeFlags & 10256) for (t = t.child; t !== null;)Ud(t), t = t.sibling } function Ud(t) { switch (t.tag) { case 0: case 11: case 15: Zi(t), t.flags & 2048 && xn(9, t, t.return); break; case 3: Zi(t); break; case 12: Zi(t); break; case 22: var e = t.stateNode; t.memoizedState !== null && e._visibility & 2 && (t.return === null || t.return.tag !== 13) ? (e._visibility &= -3, ps(t)) : Zi(t); break; default: Zi(t) } } function ps(t) { var e = t.deletions; if ((t.flags & 16) !== 0) { if (e !== null) for (var n = 0; n < e.length; n++) { var a = e[n]; Qt = a, _d(a, t) } Nd(t) } for (t = t.child; t !== null;) { switch (e = t, e.tag) { case 0: case 11: case 15: xn(8, e, e.return), ps(e); break; case 22: n = e.stateNode, n._visibility & 2 && (n._visibility &= -3, ps(e)); break; default: ps(e) }t = t.sibling } } function _d(t, e) { for (; Qt !== null;) { var n = Qt; switch (n.tag) { case 0: case 11: case 15: xn(8, n, e); break; case 23: case 22: if (n.memoizedState !== null && n.memoizedState.cachePool !== null) { var a = n.memoizedState.cachePool.pool; a != null && a.refCount++ } break; case 24: Di(n.memoizedState.cache) }if (a = n.child, a !== null) a.return = n, Qt = a; else t: for (n = t; Qt !== null;) { a = Qt; var s = a.sibling, r = a.return; if (Md(a), a === n) { Qt = null; break t } if (s !== null) { s.return = r, Qt = s; break t } Qt = r } } } var hv = { getCacheForType: function (t) { var e = It(Yt), n = e.data.get(t); return n === void 0 && (n = t(), e.data.set(t, n)), n } }, dv = typeof WeakMap == "function" ? WeakMap : Map, gt = 0, xt = null, rt = null, ht = 0, vt = 0, ge = null, Dn = !1, Ha = !1, Lo = !1, un = 0, zt = 0, Rn = 0, aa = 0, Ho = 0, Re = 0, qa = 0, Ki = null, oe = null, qo = !1, Yo = 0, ys = 1 / 0, gs = null, On = null, Pt = 0, Cn = null, Ya = null, Ga = 0, Go = 0, Xo = null, Bd = null, Qi = 0, Zo = null; function ve() { if ((gt & 2) !== 0 && ht !== 0) return ht & -ht; if (z.T !== null) { var t = Ca; return t !== 0 ? t : Wo() } return Fc() } function jd() { Re === 0 && (Re = (ht & 536870912) === 0 || pt ? Qc() : 536870912); var t = De.current; return t !== null && (t.flags |= 32), Re } function Se(t, e, n) { (t === xt && (vt === 2 || vt === 9) || t.cancelPendingCommit !== null) && (Xa(t, 0), Vn(t, ht, Re, !1)), ci(t, n), ((gt & 2) === 0 || t !== xt) && (t === xt && ((gt & 2) === 0 && (aa |= n), zt === 4 && Vn(t, ht, Re, !1)), Ge(t)) } function wd(t, e, n) { if ((gt & 6) !== 0) throw Error(o(327)); var a = !n && (e & 124) === 0 && (e & t.expiredLanes) === 0 || ri(t, e), s = a ? yv(t, e) : Jo(t, e, !0), r = a; do { if (s === 0) { Ha && !a && Vn(t, e, 0, !1); break } else { if (n = t.current.alternate, r && !mv(n)) { s = Jo(t, e, !1), r = !1; continue } if (s === 2) { if (r = e, t.errorRecoveryDisabledLanes & r) var f = 0; else f = t.pendingLanes & -536870913, f = f !== 0 ? f : f & 536870912 ? 536870912 : 0; if (f !== 0) { e = f; t: { var p = t; s = Ki; var S = p.current.memoizedState.isDehydrated; if (S && (Xa(p, f).flags |= 256), f = Jo(p, f, !1), f !== 2) { if (Lo && !S) { p.errorRecoveryDisabledLanes |= r, aa |= r, s = 4; break t } r = oe, oe = s, r !== null && (oe === null ? oe = r : oe.push.apply(oe, r)) } s = f } if (r = !1, s !== 2) continue } } if (s === 1) { Xa(t, 0), Vn(t, e, 0, !0); break } t: { switch (a = t, r = s, r) { case 0: case 1: throw Error(o(345)); case 4: if ((e & 4194048) !== e) break; case 6: Vn(a, e, Re, !Dn); break t; case 2: oe = null; break; case 3: case 5: break; default: throw Error(o(329)) }if ((e & 62914560) === e && (s = Yo + 300 - we(), 10 < s)) { if (Vn(a, e, Re, !Dn), Ol(a, 0, !0) !== 0) break t; a.timeoutHandle = hm(Ld.bind(null, a, n, oe, gs, qo, e, Re, aa, qa, Dn, r, 2, -0, 0), s); break t } Ld(a, n, oe, gs, qo, e, Re, aa, qa, Dn, r, 0, -0, 0) } } break } while (!0); Ge(t) } function Ld(t, e, n, a, s, r, f, p, S, D, C, _, R, O) { if (t.timeoutHandle = -1, _ = e.subtreeFlags, (_ & 8192 || (_ & 16785408) === 16785408) && (Ii = { stylesheets: null, count: 0, unsuspend: Pv }, zd(e), _ = Wv(), _ !== null)) { t.cancelPendingCommit = _(Kd.bind(null, t, e, r, n, a, s, f, p, S, C, 1, R, O)), Vn(t, r, f, !D); return } Kd(t, e, r, n, a, s, f, p, S) } function mv(t) { for (var e = t; ;) { var n = e.tag; if ((n === 0 || n === 11 || n === 15) && e.flags & 16384 && (n = e.updateQueue, n !== null && (n = n.stores, n !== null))) for (var a = 0; a < n.length; a++) { var s = n[a], r = s.getSnapshot; s = s.value; try { if (!de(r(), s)) return !1 } catch { return !1 } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function Vn(t, e, n, a) { e &= ~Ho, e &= ~aa, t.suspendedLanes |= e, t.pingedLanes &= ~e, a && (t.warmLanes |= e), a = t.expirationTimes; for (var s = e; 0 < s;) { var r = 31 - he(s), f = 1 << r; a[r] = -1, s &= ~f } n !== 0 && kc(t, n, e) } function vs() { return (gt & 6) === 0 ? (Ji(0), !1) : !0 } function Ko() { if (rt !== null) { if (vt === 0) var t = rt.return; else t = rt, $e = Wn = null, uo(t), Ba = null, wi = 0, t = rt; for (; t !== null;)gd(t.alternate, t), t = t.return; rt = null } } function Xa(t, e) { var n = t.timeoutHandle; n !== -1 && (t.timeoutHandle = -1, Nv(n)), n = t.cancelPendingCommit, n !== null && (t.cancelPendingCommit = null, n()), Ko(), xt = t, rt = n = Pe(t.current, null), ht = e, vt = 0, ge = null, Dn = !1, Ha = ri(t, e), Lo = !1, qa = Re = Ho = aa = Rn = zt = 0, oe = Ki = null, qo = !1, (e & 8) !== 0 && (e |= e & 32); var a = t.entangledLanes; if (a !== 0) for (t = t.entanglements, a &= e; 0 < a;) { var s = 31 - he(a), r = 1 << s; e |= t[s], a &= ~r } return un = e, ql(), n } function Hd(t, e) { ut = null, z.H = ls, e === Oi || e === Pl ? (e = nh(), vt = 3) : e === If ? (e = nh(), vt = 4) : vt = e === ad ? 8 : e !== null && typeof e == "object" && typeof e.then == "function" ? 6 : 1, ge = e, rt === null && (zt = 1, cs(t, Ae(e, t.current))) } function qd() { var t = z.H; return z.H = ls, t === null ? ls : t } function Yd() { var t = z.A; return z.A = hv, t } function Qo() { zt = 4, Dn || (ht & 4194048) !== ht && De.current !== null || (Ha = !0), (Rn & 134217727) === 0 && (aa & 134217727) === 0 || xt === null || Vn(xt, ht, Re, !1) } function Jo(t, e, n) { var a = gt; gt |= 2; var s = qd(), r = Yd(); (xt !== t || ht !== e) && (gs = null, Xa(t, e)), e = !1; var f = zt; t: do try { if (vt !== 0 && rt !== null) { var p = rt, S = ge; switch (vt) { case 8: Ko(), f = 6; break t; case 3: case 2: case 9: case 6: De.current === null && (e = !0); var D = vt; if (vt = 0, ge = null, Za(t, p, S, D), n && Ha) { f = 0; break t } break; default: D = vt, vt = 0, ge = null, Za(t, p, S, D) } } pv(), f = zt; break } catch (C) { Hd(t, C) } while (!0); return e && t.shellSuspendCounter++, $e = Wn = null, gt = a, z.H = s, z.A = r, rt === null && (xt = null, ht = 0, ql()), f } function pv() { for (; rt !== null;)Gd(rt) } function yv(t, e) { var n = gt; gt |= 2; var a = qd(), s = Yd(); xt !== t || ht !== e ? (gs = null, ys = we() + 500, Xa(t, e)) : Ha = ri(t, e); t: do try { if (vt !== 0 && rt !== null) { e = rt; var r = ge; e: switch (vt) { case 1: vt = 0, ge = null, Za(t, e, r, 1); break; case 2: case 9: if (th(r)) { vt = 0, ge = null, Xd(e); break } e = function () { vt !== 2 && vt !== 9 || xt !== t || (vt = 7), Ge(t) }, r.then(e, e); break t; case 3: vt = 7; break t; case 4: vt = 5; break t; case 7: th(r) ? (vt = 0, ge = null, Xd(e)) : (vt = 0, ge = null, Za(t, e, r, 7)); break; case 5: var f = null; switch (rt.tag) { case 26: f = rt.memoizedState; case 5: case 27: var p = rt; if (!f || Em(f)) { vt = 0, ge = null; var S = p.sibling; if (S !== null) rt = S; else { var D = p.return; D !== null ? (rt = D, Ss(D)) : rt = null } break e } }vt = 0, ge = null, Za(t, e, r, 5); break; case 6: vt = 0, ge = null, Za(t, e, r, 6); break; case 8: Ko(), zt = 6; break t; default: throw Error(o(462)) } } gv(); break } catch (C) { Hd(t, C) } while (!0); return $e = Wn = null, z.H = a, z.A = s, gt = n, rt !== null ? 0 : (xt = null, ht = 0, ql(), zt) } function gv() { for (; rt !== null && !Hg();)Gd(rt) } function Gd(t) { var e = pd(t.alternate, t, un); t.memoizedProps = t.pendingProps, e === null ? Ss(t) : rt = e } function Xd(t) { var e = t, n = e.alternate; switch (e.tag) { case 15: case 0: e = rd(n, e, e.pendingProps, e.type, void 0, ht); break; case 11: e = rd(n, e, e.pendingProps, e.type.render, e.ref, ht); break; case 5: uo(e); default: gd(n, e), e = rt = Zf(e, un), e = pd(n, e, un) }t.memoizedProps = t.pendingProps, e === null ? Ss(t) : rt = e } function Za(t, e, n, a) { $e = Wn = null, uo(e), Ba = null, wi = 0; var s = e.return; try { if (sv(t, s, e, n, ht)) { zt = 1, cs(t, Ae(n, t.current)), rt = null; return } } catch (r) { if (s !== null) throw rt = s, r; zt = 1, cs(t, Ae(n, t.current)), rt = null; return } e.flags & 32768 ? (pt || a === 1 ? t = !0 : Ha || (ht & 536870912) !== 0 ? t = !1 : (Dn = t = !0, (a === 2 || a === 9 || a === 3 || a === 6) && (a = De.current, a !== null && a.tag === 13 && (a.flags |= 16384))), Zd(e, t)) : Ss(e) } function Ss(t) { var e = t; do { if ((e.flags & 32768) !== 0) { Zd(e, Dn); return } t = e.return; var n = ov(e.alternate, e, un); if (n !== null) { rt = n; return } if (e = e.sibling, e !== null) { rt = e; return } rt = e = t } while (e !== null); zt === 0 && (zt = 5) } function Zd(t, e) { do { var n = rv(t.alternate, t); if (n !== null) { n.flags &= 32767, rt = n; return } if (n = t.return, n !== null && (n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null), !e && (t = t.sibling, t !== null)) { rt = t; return } rt = t = n } while (t !== null); zt = 6, rt = null } function Kd(t, e, n, a, s, r, f, p, S) { t.cancelPendingCommit = null; do bs(); while (Pt !== 0); if ((gt & 6) !== 0) throw Error(o(327)); if (e !== null) { if (e === t.current) throw Error(o(177)); if (r = e.lanes | e.childLanes, r |= ju, Pg(t, n, r, f, p, S), t === xt && (rt = xt = null, ht = 0), Ya = e, Cn = t, Ga = n, Go = r, Xo = s, Bd = a, (e.subtreeFlags & 10256) !== 0 || (e.flags & 10256) !== 0 ? (t.callbackNode = null, t.callbackPriority = 0, Tv(Ml, function () { return Fd(), null })) : (t.callbackNode = null, t.callbackPriority = 0), a = (e.flags & 13878) !== 0, (e.subtreeFlags & 13878) !== 0 || a) { a = z.T, z.T = null, s = L.p, L.p = 2, f = gt, gt |= 4; try { cv(t, e, n) } finally { gt = f, L.p = s, z.T = a } } Pt = 1, Qd(), Jd(), kd() } } function Qd() { if (Pt === 1) { Pt = 0; var t = Cn, e = Ya, n = (e.flags & 13878) !== 0; if ((e.subtreeFlags & 13878) !== 0 || n) { n = z.T, z.T = null; var a = L.p; L.p = 2; var s = gt; gt |= 4; try { Od(e, t); var r = lr, f = _f(t.containerInfo), p = r.focusedElem, S = r.selectionRange; if (f !== p && p && p.ownerDocument && Uf(p.ownerDocument.documentElement, p)) { if (S !== null && zu(p)) { var D = S.start, C = S.end; if (C === void 0 && (C = D), "selectionStart" in p) p.selectionStart = D, p.selectionEnd = Math.min(C, p.value.length); else { var _ = p.ownerDocument || document, R = _ && _.defaultView || window; if (R.getSelection) { var O = R.getSelection(), at = p.textContent.length, I = Math.min(S.start, at), Tt = S.end === void 0 ? I : Math.min(S.end, at); !O.extend && I > Tt && (f = Tt, Tt = I, I = f); var E = Nf(p, I), A = Nf(p, Tt); if (E && A && (O.rangeCount !== 1 || O.anchorNode !== E.node || O.anchorOffset !== E.offset || O.focusNode !== A.node || O.focusOffset !== A.offset)) { var M = _.createRange(); M.setStart(E.node, E.offset), O.removeAllRanges(), I > Tt ? (O.addRange(M), O.extend(A.node, A.offset)) : (M.setEnd(A.node, A.offset), O.addRange(M)) } } } } for (_ = [], O = p; O = O.parentNode;)O.nodeType === 1 && _.push({ element: O, left: O.scrollLeft, top: O.scrollTop }); for (typeof p.focus == "function" && p.focus(), p = 0; p < _.length; p++) { var N = _[p]; N.element.scrollLeft = N.left, N.element.scrollTop = N.top } } Ns = !!ir, lr = ir = null } finally { gt = s, L.p = a, z.T = n } } t.current = e, Pt = 2 } } function Jd() { if (Pt === 2) { Pt = 0; var t = Cn, e = Ya, n = (e.flags & 8772) !== 0; if ((e.subtreeFlags & 8772) !== 0 || n) { n = z.T, z.T = null; var a = L.p; L.p = 2; var s = gt; gt |= 4; try { Ed(t, e.alternate, e) } finally { gt = s, L.p = a, z.T = n } } Pt = 3 } } function kd() { if (Pt === 4 || Pt === 3) { Pt = 0, qg(); var t = Cn, e = Ya, n = Ga, a = Bd; (e.subtreeFlags & 10256) !== 0 || (e.flags & 10256) !== 0 ? Pt = 5 : (Pt = 0, Ya = Cn = null, Pd(t, t.pendingLanes)); var s = t.pendingLanes; if (s === 0 && (On = null), cu(n), e = e.stateNode, fe && typeof fe.onCommitFiberRoot == "function") try { fe.onCommitFiberRoot(oi, e, void 0, (e.current.flags & 128) === 128) } catch { } if (a !== null) { e = z.T, s = L.p, L.p = 2, z.T = null; try { for (var r = t.onRecoverableError, f = 0; f < a.length; f++) { var p = a[f]; r(p.value, { componentStack: p.stack }) } } finally { z.T = e, L.p = s } } (Ga & 3) !== 0 && bs(), Ge(t), s = t.pendingLanes, (n & 4194090) !== 0 && (s & 42) !== 0 ? t === Zo ? Qi++ : (Qi = 0, Zo = t) : Qi = 0, Ji(0) } } function Pd(t, e) { (t.pooledCacheLanes &= e) === 0 && (e = t.pooledCache, e != null && (t.pooledCache = null, Di(e))) } function bs(t) { return Qd(), Jd(), kd(), Fd() } function Fd() { if (Pt !== 5) return !1; var t = Cn, e = Go; Go = 0; var n = cu(Ga), a = z.T, s = L.p; try { L.p = 32 > n ? 32 : n, z.T = null, n = Xo, Xo = null; var r = Cn, f = Ga; if (Pt = 0, Ya = Cn = null, Ga = 0, (gt & 6) !== 0) throw Error(o(331)); var p = gt; if (gt |= 4, Ud(r.current), Vd(r, r.current, f, n), gt = p, Ji(0, !1), fe && typeof fe.onPostCommitFiberRoot == "function") try { fe.onPostCommitFiberRoot(oi, r) } catch { } return !0 } finally { L.p = s, z.T = a, Pd(t, e) } } function Wd(t, e, n) { e = Ae(n, e), e = Ao(t.stateNode, e, 2), t = Sn(t, e, 2), t !== null && (ci(t, 2), Ge(t)) } function At(t, e, n) { if (t.tag === 3) Wd(t, t, n); else for (; e !== null;) { if (e.tag === 3) { Wd(e, t, n); break } else if (e.tag === 1) { var a = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof a.componentDidCatch == "function" && (On === null || !On.has(a))) { t = Ae(n, t), n = ed(2), a = Sn(e, n, 2), a !== null && (nd(n, a, e, t), ci(a, 2), Ge(a)); break } } e = e.return } } function ko(t, e, n) { var a = t.pingCache; if (a === null) { a = t.pingCache = new dv; var s = new Set; a.set(e, s) } else s = a.get(e), s === void 0 && (s = new Set, a.set(e, s)); s.has(n) || (Lo = !0, s.add(n), t = vv.bind(null, t, e, n), e.then(t, t)) } function vv(t, e, n) { var a = t.pingCache; a !== null && a.delete(e), t.pingedLanes |= t.suspendedLanes & n, t.warmLanes &= ~n, xt === t && (ht & n) === n && (zt === 4 || zt === 3 && (ht & 62914560) === ht && 300 > we() - Yo ? (gt & 2) === 0 && Xa(t, 0) : Ho |= n, qa === ht && (qa = 0)), Ge(t) } function $d(t, e) { e === 0 && (e = Jc()), t = Ma(t, e), t !== null && (ci(t, e), Ge(t)) } function Sv(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), $d(t, n) } function bv(t, e) { var n = 0; switch (t.tag) { case 13: var a = t.stateNode, s = t.memoizedState; s !== null && (n = s.retryLane); break; case 19: a = t.stateNode; break; case 22: a = t.stateNode._retryCache; break; default: throw Error(o(314)) }a !== null && a.delete(e), $d(t, n) } function Tv(t, e) { return su(t, e) } var Ts = null, Ka = null, Po = !1, As = !1, Fo = !1, ia = 0; function Ge(t) { t !== Ka && t.next === null && (Ka === null ? Ts = Ka = t : Ka = Ka.next = t), As = !0, Po || (Po = !0, xv()) } function Ji(t, e) { if (!Fo && As) { Fo = !0; do for (var n = !1, a = Ts; a !== null;) { if (t !== 0) { var s = a.pendingLanes; if (s === 0) var r = 0; else { var f = a.suspendedLanes, p = a.pingedLanes; r = (1 << 31 - he(42 | t) + 1) - 1, r &= s & ~(f & ~p), r = r & 201326741 ? r & 201326741 | 1 : r ? r | 2 : 0 } r !== 0 && (n = !0, nm(a, r)) } else r = ht, r = Ol(a, a === xt ? r : 0, a.cancelPendingCommit !== null || a.timeoutHandle !== -1), (r & 3) === 0 || ri(a, r) || (n = !0, nm(a, r)); a = a.next } while (n); Fo = !1 } } function Av() { Id() } function Id() { As = Po = !1; var t = 0; ia !== 0 && (zv() && (t = ia), ia = 0); for (var e = we(), n = null, a = Ts; a !== null;) { var s = a.next, r = tm(a, e); r === 0 ? (a.next = null, n === null ? Ts = s : n.next = s, s === null && (Ka = n)) : (n = a, (t !== 0 || (r & 3) !== 0) && (As = !0)), a = s } Ji(t) } function tm(t, e) { for (var n = t.suspendedLanes, a = t.pingedLanes, s = t.expirationTimes, r = t.pendingLanes & -62914561; 0 < r;) { var f = 31 - he(r), p = 1 << f, S = s[f]; S === -1 ? ((p & n) === 0 || (p & a) !== 0) && (s[f] = kg(p, e)) : S <= e && (t.expiredLanes |= p), r &= ~p } if (e = xt, n = ht, n = Ol(t, t === e ? n : 0, t.cancelPendingCommit !== null || t.timeoutHandle !== -1), a = t.callbackNode, n === 0 || t === e && (vt === 2 || vt === 9) || t.cancelPendingCommit !== null) return a !== null && a !== null && uu(a), t.callbackNode = null, t.callbackPriority = 0; if ((n & 3) === 0 || ri(t, n)) { if (e = n & -n, e === t.callbackPriority) return e; switch (a !== null && uu(a), cu(n)) { case 2: case 8: n = Zc; break; case 32: n = Ml; break; case 268435456: n = Kc; break; default: n = Ml }return a = em.bind(null, t), n = su(n, a), t.callbackPriority = e, t.callbackNode = n, e } return a !== null && a !== null && uu(a), t.callbackPriority = 2, t.callbackNode = null, 2 } function em(t, e) { if (Pt !== 0 && Pt !== 5) return t.callbackNode = null, t.callbackPriority = 0, null; var n = t.callbackNode; if (bs() && t.callbackNode !== n) return null; var a = ht; return a = Ol(t, t === xt ? a : 0, t.cancelPendingCommit !== null || t.timeoutHandle !== -1), a === 0 ? null : (wd(t, a, e), tm(t, we()), t.callbackNode != null && t.callbackNode === n ? em.bind(null, t) : null) } function nm(t, e) { if (bs()) return null; wd(t, e, !0) } function xv() { Uv(function () { (gt & 6) !== 0 ? su(Xc, Av) : Id() }) } function Wo() { return ia === 0 && (ia = Qc()), ia } function am(t) { return t == null || typeof t == "symbol" || typeof t == "boolean" ? null : typeof t == "function" ? t : Ul("" + t) } function im(t, e) { var n = e.ownerDocument.createElement("input"); return n.name = e.name, n.value = e.value, t.id && n.setAttribute("form", t.id), e.parentNode.insertBefore(n, e), t = new FormData(t), n.parentNode.removeChild(n), t } function Ev(t, e, n, a, s) { if (e === "submit" && n && n.stateNode === s) { var r = am((s[ie] || null).action), f = a.submitter; f && (e = (e = f[ie] || null) ? am(e.formAction) : f.getAttribute("formAction"), e !== null && (r = e, f = null)); var p = new wl("action", "action", null, a, s); t.push({ event: p, listeners: [{ instance: null, listener: function () { if (a.defaultPrevented) { if (ia !== 0) { var S = f ? im(s, f) : new FormData(s); go(n, { pending: !0, data: S, method: s.method, action: r }, null, S) } } else typeof r == "function" && (p.preventDefault(), S = f ? im(s, f) : new FormData(s), go(n, { pending: !0, data: S, method: s.method, action: r }, r, S)) }, currentTarget: s }] }) } } for (var $o = 0; $o < Bu.length; $o++) { var Io = Bu[$o], Mv = Io.toLowerCase(), Dv = Io[0].toUpperCase() + Io.slice(1); Ne(Mv, "on" + Dv) } Ne(wf, "onAnimationEnd"), Ne(Lf, "onAnimationIteration"), Ne(Hf, "onAnimationStart"), Ne("dblclick", "onDoubleClick"), Ne("focusin", "onFocus"), Ne("focusout", "onBlur"), Ne(X0, "onTransitionRun"), Ne(Z0, "onTransitionStart"), Ne(K0, "onTransitionCancel"), Ne(qf, "onTransitionEnd"), pa("onMouseEnter", ["mouseout", "mouseover"]), pa("onMouseLeave", ["mouseout", "mouseover"]), pa("onPointerEnter", ["pointerout", "pointerover"]), pa("onPointerLeave", ["pointerout", "pointerover"]), Gn("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), Gn("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), Gn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Gn("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), Gn("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), Gn("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ki = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Rv = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ki)); function lm(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var a = t[n], s = a.event; a = a.listeners; t: { var r = void 0; if (e) for (var f = a.length - 1; 0 <= f; f--) { var p = a[f], S = p.instance, D = p.currentTarget; if (p = p.listener, S !== r && s.isPropagationStopped()) break t; r = p, s.currentTarget = D; try { r(s) } catch (C) { rs(C) } s.currentTarget = null, r = S } else for (f = 0; f < a.length; f++) { if (p = a[f], S = p.instance, D = p.currentTarget, p = p.listener, S !== r && s.isPropagationStopped()) break t; r = p, s.currentTarget = D; try { r(s) } catch (C) { rs(C) } s.currentTarget = null, r = S } } } } function ct(t, e) { var n = e[fu]; n === void 0 && (n = e[fu] = new Set); var a = t + "__bubble"; n.has(a) || (sm(e, t, 2, !1), n.add(a)) } function tr(t, e, n) { var a = 0; e && (a |= 4), sm(n, t, a, e) } var xs = "_reactListening" + Math.random().toString(36).slice(2); function er(t) { if (!t[xs]) { t[xs] = !0, $c.forEach(function (n) { n !== "selectionchange" && (Rv.has(n) || tr(n, !1, t), tr(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[xs] || (e[xs] = !0, tr("selectionchange", !1, e)) } } function sm(t, e, n, a) { switch (Vm(e)) { case 2: var s = t1; break; case 8: s = e1; break; default: s = pr }n = s.bind(null, e, n, t), s = void 0, !Au || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (s = !0), a ? s !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: s }) : t.addEventListener(e, n, !0) : s !== void 0 ? t.addEventListener(e, n, { passive: s }) : t.addEventListener(e, n, !1) } function nr(t, e, n, a, s) { var r = a; if ((e & 1) === 0 && (e & 2) === 0 && a !== null) t: for (; ;) { if (a === null) return; var f = a.tag; if (f === 3 || f === 4) { var p = a.stateNode.containerInfo; if (p === s) break; if (f === 4) for (f = a.return; f !== null;) { var S = f.tag; if ((S === 3 || S === 4) && f.stateNode.containerInfo === s) return; f = f.return } for (; p !== null;) { if (f = ha(p), f === null) return; if (S = f.tag, S === 5 || S === 6 || S === 26 || S === 27) { a = r = f; continue t } p = p.parentNode } } a = a.return } df(function () { var D = r, C = bu(n), _ = []; t: { var R = Yf.get(t); if (R !== void 0) { var O = wl, at = t; switch (t) { case "keypress": if (Bl(n) === 0) break t; case "keydown": case "keyup": O = T0; break; case "focusin": at = "focus", O = Du; break; case "focusout": at = "blur", O = Du; break; case "beforeblur": case "afterblur": O = Du; break; case "click": if (n.button === 2) break t; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": O = yf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": O = r0; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": O = E0; break; case wf: case Lf: case Hf: O = h0; break; case qf: O = D0; break; case "scroll": case "scrollend": O = u0; break; case "wheel": O = O0; break; case "copy": case "cut": case "paste": O = m0; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": O = vf; break; case "toggle": case "beforetoggle": O = V0 }var I = (e & 4) !== 0, Tt = !I && (t === "scroll" || t === "scrollend"), E = I ? R !== null ? R + "Capture" : null : R; I = []; for (var A = D, M; A !== null;) { var N = A; if (M = N.stateNode, N = N.tag, N !== 5 && N !== 26 && N !== 27 || M === null || E === null || (N = di(A, E), N != null && I.push(Pi(A, N, M))), Tt) break; A = A.return } 0 < I.length && (R = new O(R, at, null, n, C), _.push({ event: R, listeners: I })) } } if ((e & 7) === 0) { t: { if (R = t === "mouseover" || t === "pointerover", O = t === "mouseout" || t === "pointerout", R && n !== Su && (at = n.relatedTarget || n.fromElement) && (ha(at) || at[fa])) break t; if ((O || R) && (R = C.window === C ? C : (R = C.ownerDocument) ? R.defaultView || R.parentWindow : window, O ? (at = n.relatedTarget || n.toElement, O = D, at = at ? ha(at) : null, at !== null && (Tt = d(at), I = at.tag, at !== Tt || I !== 5 && I !== 27 && I !== 6) && (at = null)) : (O = null, at = D), O !== at)) { if (I = yf, N = "onMouseLeave", E = "onMouseEnter", A = "mouse", (t === "pointerout" || t === "pointerover") && (I = vf, N = "onPointerLeave", E = "onPointerEnter", A = "pointer"), Tt = O == null ? R : hi(O), M = at == null ? R : hi(at), R = new I(N, A + "leave", O, n, C), R.target = Tt, R.relatedTarget = M, N = null, ha(C) === D && (I = new I(E, A + "enter", at, n, C), I.target = M, I.relatedTarget = Tt, N = I), Tt = N, O && at) e: { for (I = O, E = at, A = 0, M = I; M; M = Qa(M))A++; for (M = 0, N = E; N; N = Qa(N))M++; for (; 0 < A - M;)I = Qa(I), A--; for (; 0 < M - A;)E = Qa(E), M--; for (; A--;) { if (I === E || E !== null && I === E.alternate) break e; I = Qa(I), E = Qa(E) } I = null } else I = null; O !== null && um(_, R, O, I, !1), at !== null && Tt !== null && um(_, Tt, at, I, !0) } } t: { if (R = D ? hi(D) : window, O = R.nodeName && R.nodeName.toLowerCase(), O === "select" || O === "input" && R.type === "file") var Q = Df; else if (Ef(R)) if (Rf) Q = q0; else { Q = L0; var ot = w0 } else O = R.nodeName, !O || O.toLowerCase() !== "input" || R.type !== "checkbox" && R.type !== "radio" ? D && vu(D.elementType) && (Q = Df) : Q = H0; if (Q && (Q = Q(t, D))) { Mf(_, Q, n, C); break t } ot && ot(t, R, D), t === "focusout" && D && R.type === "number" && D.memoizedProps.value != null && gu(R, "number", R.value) } switch (ot = D ? hi(D) : window, t) { case "focusin": (Ef(ot) || ot.contentEditable === "true") && (Aa = ot, Nu = D, Ti = null); break; case "focusout": Ti = Nu = Aa = null; break; case "mousedown": Uu = !0; break; case "contextmenu": case "mouseup": case "dragend": Uu = !1, Bf(_, n, C); break; case "selectionchange": if (G0) break; case "keydown": case "keyup": Bf(_, n, C) }var F; if (Ou) t: { switch (t) { case "compositionstart": var tt = "onCompositionStart"; break t; case "compositionend": tt = "onCompositionEnd"; break t; case "compositionupdate": tt = "onCompositionUpdate"; break t }tt = void 0 } else Ta ? Af(t, n) && (tt = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (tt = "onCompositionStart"); tt && (Sf && n.locale !== "ko" && (Ta || tt !== "onCompositionStart" ? tt === "onCompositionEnd" && Ta && (F = mf()) : (pn = C, xu = "value" in pn ? pn.value : pn.textContent, Ta = !0)), ot = Es(D, tt), 0 < ot.length && (tt = new gf(tt, t, null, n, C), _.push({ event: tt, listeners: ot }), F ? tt.data = F : (F = xf(n), F !== null && (tt.data = F)))), (F = N0 ? U0(t, n) : _0(t, n)) && (tt = Es(D, "onBeforeInput"), 0 < tt.length && (ot = new gf("onBeforeInput", "beforeinput", null, n, C), _.push({ event: ot, listeners: tt }), ot.data = F)), Ev(_, t, D, n, C) } lm(_, e) }) } function Pi(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function Es(t, e) { for (var n = e + "Capture", a = []; t !== null;) { var s = t, r = s.stateNode; if (s = s.tag, s !== 5 && s !== 26 && s !== 27 || r === null || (s = di(t, n), s != null && a.unshift(Pi(t, s, r)), s = di(t, e), s != null && a.push(Pi(t, s, r))), t.tag === 3) return a; t = t.return } return [] } function Qa(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5 && t.tag !== 27); return t || null } function um(t, e, n, a, s) { for (var r = e._reactName, f = []; n !== null && n !== a;) { var p = n, S = p.alternate, D = p.stateNode; if (p = p.tag, S !== null && S === a) break; p !== 5 && p !== 26 && p !== 27 || D === null || (S = D, s ? (D = di(n, r), D != null && f.unshift(Pi(n, D, S))) : s || (D = di(n, r), D != null && f.push(Pi(n, D, S)))), n = n.return } f.length !== 0 && t.push({ event: e, listeners: f }) } var Ov = /\r\n?/g, Cv = /\u0000|\uFFFD/g; function om(t) {
    return (typeof t == "string" ? t : "" + t).replace(Ov, `
`).replace(Cv, "")
  } function rm(t, e) { return e = om(e), om(t) === e } function Ms() { } function bt(t, e, n, a, s, r) { switch (n) { case "children": typeof a == "string" ? e === "body" || e === "textarea" && a === "" || va(t, a) : (typeof a == "number" || typeof a == "bigint") && e !== "body" && va(t, "" + a); break; case "className": Vl(t, "class", a); break; case "tabIndex": Vl(t, "tabindex", a); break; case "dir": case "role": case "viewBox": case "width": case "height": Vl(t, n, a); break; case "style": ff(t, a, r); break; case "data": if (e !== "object") { Vl(t, "data", a); break } case "src": case "href": if (a === "" && (e !== "a" || n !== "href")) { t.removeAttribute(n); break } if (a == null || typeof a == "function" || typeof a == "symbol" || typeof a == "boolean") { t.removeAttribute(n); break } a = Ul("" + a), t.setAttribute(n, a); break; case "action": case "formAction": if (typeof a == "function") { t.setAttribute(n, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof r == "function" && (n === "formAction" ? (e !== "input" && bt(t, e, "name", s.name, s, null), bt(t, e, "formEncType", s.formEncType, s, null), bt(t, e, "formMethod", s.formMethod, s, null), bt(t, e, "formTarget", s.formTarget, s, null)) : (bt(t, e, "encType", s.encType, s, null), bt(t, e, "method", s.method, s, null), bt(t, e, "target", s.target, s, null))); if (a == null || typeof a == "symbol" || typeof a == "boolean") { t.removeAttribute(n); break } a = Ul("" + a), t.setAttribute(n, a); break; case "onClick": a != null && (t.onclick = Ms); break; case "onScroll": a != null && ct("scroll", t); break; case "onScrollEnd": a != null && ct("scrollend", t); break; case "dangerouslySetInnerHTML": if (a != null) { if (typeof a != "object" || !("__html" in a)) throw Error(o(61)); if (n = a.__html, n != null) { if (s.children != null) throw Error(o(60)); t.innerHTML = n } } break; case "multiple": t.multiple = a && typeof a != "function" && typeof a != "symbol"; break; case "muted": t.muted = a && typeof a != "function" && typeof a != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (a == null || typeof a == "function" || typeof a == "boolean" || typeof a == "symbol") { t.removeAttribute("xlink:href"); break } n = Ul("" + a), t.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", n); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": a != null && typeof a != "function" && typeof a != "symbol" ? t.setAttribute(n, "" + a) : t.removeAttribute(n); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": a && typeof a != "function" && typeof a != "symbol" ? t.setAttribute(n, "") : t.removeAttribute(n); break; case "capture": case "download": a === !0 ? t.setAttribute(n, "") : a !== !1 && a != null && typeof a != "function" && typeof a != "symbol" ? t.setAttribute(n, a) : t.removeAttribute(n); break; case "cols": case "rows": case "size": case "span": a != null && typeof a != "function" && typeof a != "symbol" && !isNaN(a) && 1 <= a ? t.setAttribute(n, a) : t.removeAttribute(n); break; case "rowSpan": case "start": a == null || typeof a == "function" || typeof a == "symbol" || isNaN(a) ? t.removeAttribute(n) : t.setAttribute(n, a); break; case "popover": ct("beforetoggle", t), ct("toggle", t), Cl(t, "popover", a); break; case "xlinkActuate": Je(t, "http://www.w3.org/1999/xlink", "xlink:actuate", a); break; case "xlinkArcrole": Je(t, "http://www.w3.org/1999/xlink", "xlink:arcrole", a); break; case "xlinkRole": Je(t, "http://www.w3.org/1999/xlink", "xlink:role", a); break; case "xlinkShow": Je(t, "http://www.w3.org/1999/xlink", "xlink:show", a); break; case "xlinkTitle": Je(t, "http://www.w3.org/1999/xlink", "xlink:title", a); break; case "xlinkType": Je(t, "http://www.w3.org/1999/xlink", "xlink:type", a); break; case "xmlBase": Je(t, "http://www.w3.org/XML/1998/namespace", "xml:base", a); break; case "xmlLang": Je(t, "http://www.w3.org/XML/1998/namespace", "xml:lang", a); break; case "xmlSpace": Je(t, "http://www.w3.org/XML/1998/namespace", "xml:space", a); break; case "is": Cl(t, "is", a); break; case "innerText": case "textContent": break; default: (!(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (n = l0.get(n) || n, Cl(t, n, a)) } } function ar(t, e, n, a, s, r) { switch (n) { case "style": ff(t, a, r); break; case "dangerouslySetInnerHTML": if (a != null) { if (typeof a != "object" || !("__html" in a)) throw Error(o(61)); if (n = a.__html, n != null) { if (s.children != null) throw Error(o(60)); t.innerHTML = n } } break; case "children": typeof a == "string" ? va(t, a) : (typeof a == "number" || typeof a == "bigint") && va(t, "" + a); break; case "onScroll": a != null && ct("scroll", t); break; case "onScrollEnd": a != null && ct("scrollend", t); break; case "onClick": a != null && (t.onclick = Ms); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!Ic.hasOwnProperty(n)) t: { if (n[0] === "o" && n[1] === "n" && (s = n.endsWith("Capture"), e = n.slice(2, s ? n.length - 7 : void 0), r = t[ie] || null, r = r != null ? r[n] : null, typeof r == "function" && t.removeEventListener(e, r, s), typeof a == "function")) { typeof r != "function" && r !== null && (n in t ? t[n] = null : t.hasAttribute(n) && t.removeAttribute(n)), t.addEventListener(e, a, s); break t } n in t ? t[n] = a : a === !0 ? t.setAttribute(n, "") : Cl(t, n, a) } } } function Ft(t, e, n) { switch (e) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": ct("error", t), ct("load", t); var a = !1, s = !1, r; for (r in n) if (n.hasOwnProperty(r)) { var f = n[r]; if (f != null) switch (r) { case "src": a = !0; break; case "srcSet": s = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(o(137, e)); default: bt(t, e, r, f, n, null) } } s && bt(t, e, "srcSet", n.srcSet, n, null), a && bt(t, e, "src", n.src, n, null); return; case "input": ct("invalid", t); var p = r = f = s = null, S = null, D = null; for (a in n) if (n.hasOwnProperty(a)) { var C = n[a]; if (C != null) switch (a) { case "name": s = C; break; case "type": f = C; break; case "checked": S = C; break; case "defaultChecked": D = C; break; case "value": r = C; break; case "defaultValue": p = C; break; case "children": case "dangerouslySetInnerHTML": if (C != null) throw Error(o(137, e)); break; default: bt(t, e, a, C, n, null) } } uf(t, r, p, S, D, f, s, !1), zl(t); return; case "select": ct("invalid", t), a = f = r = null; for (s in n) if (n.hasOwnProperty(s) && (p = n[s], p != null)) switch (s) { case "value": r = p; break; case "defaultValue": f = p; break; case "multiple": a = p; default: bt(t, e, s, p, n, null) }e = r, n = f, t.multiple = !!a, e != null ? ga(t, !!a, e, !1) : n != null && ga(t, !!a, n, !0); return; case "textarea": ct("invalid", t), r = s = a = null; for (f in n) if (n.hasOwnProperty(f) && (p = n[f], p != null)) switch (f) { case "value": a = p; break; case "defaultValue": s = p; break; case "children": r = p; break; case "dangerouslySetInnerHTML": if (p != null) throw Error(o(91)); break; default: bt(t, e, f, p, n, null) }rf(t, a, s, r), zl(t); return; case "option": for (S in n) if (n.hasOwnProperty(S) && (a = n[S], a != null)) switch (S) { case "selected": t.selected = a && typeof a != "function" && typeof a != "symbol"; break; default: bt(t, e, S, a, n, null) }return; case "dialog": ct("beforetoggle", t), ct("toggle", t), ct("cancel", t), ct("close", t); break; case "iframe": case "object": ct("load", t); break; case "video": case "audio": for (a = 0; a < ki.length; a++)ct(ki[a], t); break; case "image": ct("error", t), ct("load", t); break; case "details": ct("toggle", t); break; case "embed": case "source": case "link": ct("error", t), ct("load", t); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (D in n) if (n.hasOwnProperty(D) && (a = n[D], a != null)) switch (D) { case "children": case "dangerouslySetInnerHTML": throw Error(o(137, e)); default: bt(t, e, D, a, n, null) }return; default: if (vu(e)) { for (C in n) n.hasOwnProperty(C) && (a = n[C], a !== void 0 && ar(t, e, C, a, n, void 0)); return } }for (p in n) n.hasOwnProperty(p) && (a = n[p], a != null && bt(t, e, p, a, n, null)) } function Vv(t, e, n, a) { switch (e) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var s = null, r = null, f = null, p = null, S = null, D = null, C = null; for (O in n) { var _ = n[O]; if (n.hasOwnProperty(O) && _ != null) switch (O) { case "checked": break; case "value": break; case "defaultValue": S = _; default: a.hasOwnProperty(O) || bt(t, e, O, null, a, _) } } for (var R in a) { var O = a[R]; if (_ = n[R], a.hasOwnProperty(R) && (O != null || _ != null)) switch (R) { case "type": r = O; break; case "name": s = O; break; case "checked": D = O; break; case "defaultChecked": C = O; break; case "value": f = O; break; case "defaultValue": p = O; break; case "children": case "dangerouslySetInnerHTML": if (O != null) throw Error(o(137, e)); break; default: O !== _ && bt(t, e, R, O, a, _) } } yu(t, f, p, S, D, C, r, s); return; case "select": O = f = p = R = null; for (r in n) if (S = n[r], n.hasOwnProperty(r) && S != null) switch (r) { case "value": break; case "multiple": O = S; default: a.hasOwnProperty(r) || bt(t, e, r, null, a, S) }for (s in a) if (r = a[s], S = n[s], a.hasOwnProperty(s) && (r != null || S != null)) switch (s) { case "value": R = r; break; case "defaultValue": p = r; break; case "multiple": f = r; default: r !== S && bt(t, e, s, r, a, S) }e = p, n = f, a = O, R != null ? ga(t, !!n, R, !1) : !!a != !!n && (e != null ? ga(t, !!n, e, !0) : ga(t, !!n, n ? [] : "", !1)); return; case "textarea": O = R = null; for (p in n) if (s = n[p], n.hasOwnProperty(p) && s != null && !a.hasOwnProperty(p)) switch (p) { case "value": break; case "children": break; default: bt(t, e, p, null, a, s) }for (f in a) if (s = a[f], r = n[f], a.hasOwnProperty(f) && (s != null || r != null)) switch (f) { case "value": R = s; break; case "defaultValue": O = s; break; case "children": break; case "dangerouslySetInnerHTML": if (s != null) throw Error(o(91)); break; default: s !== r && bt(t, e, f, s, a, r) }of(t, R, O); return; case "option": for (var at in n) if (R = n[at], n.hasOwnProperty(at) && R != null && !a.hasOwnProperty(at)) switch (at) { case "selected": t.selected = !1; break; default: bt(t, e, at, null, a, R) }for (S in a) if (R = a[S], O = n[S], a.hasOwnProperty(S) && R !== O && (R != null || O != null)) switch (S) { case "selected": t.selected = R && typeof R != "function" && typeof R != "symbol"; break; default: bt(t, e, S, R, a, O) }return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var I in n) R = n[I], n.hasOwnProperty(I) && R != null && !a.hasOwnProperty(I) && bt(t, e, I, null, a, R); for (D in a) if (R = a[D], O = n[D], a.hasOwnProperty(D) && R !== O && (R != null || O != null)) switch (D) { case "children": case "dangerouslySetInnerHTML": if (R != null) throw Error(o(137, e)); break; default: bt(t, e, D, R, a, O) }return; default: if (vu(e)) { for (var Tt in n) R = n[Tt], n.hasOwnProperty(Tt) && R !== void 0 && !a.hasOwnProperty(Tt) && ar(t, e, Tt, void 0, a, R); for (C in a) R = a[C], O = n[C], !a.hasOwnProperty(C) || R === O || R === void 0 && O === void 0 || ar(t, e, C, R, a, O); return } }for (var E in n) R = n[E], n.hasOwnProperty(E) && R != null && !a.hasOwnProperty(E) && bt(t, e, E, null, a, R); for (_ in a) R = a[_], O = n[_], !a.hasOwnProperty(_) || R === O || R == null && O == null || bt(t, e, _, R, a, O) } var ir = null, lr = null; function Ds(t) { return t.nodeType === 9 ? t : t.ownerDocument } function cm(t) { switch (t) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function fm(t, e) { if (t === 0) switch (e) { case "svg": return 1; case "math": return 2; default: return 0 }return t === 1 && e === "foreignObject" ? 0 : t } function sr(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.children == "bigint" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var ur = null; function zv() { var t = window.event; return t && t.type === "popstate" ? t === ur ? !1 : (ur = t, !0) : (ur = null, !1) } var hm = typeof setTimeout == "function" ? setTimeout : void 0, Nv = typeof clearTimeout == "function" ? clearTimeout : void 0, dm = typeof Promise == "function" ? Promise : void 0, Uv = typeof queueMicrotask == "function" ? queueMicrotask : typeof dm < "u" ? function (t) { return dm.resolve(null).then(t).catch(_v) } : hm; function _v(t) { setTimeout(function () { throw t }) } function zn(t) { return t === "head" } function mm(t, e) { var n = e, a = 0, s = 0; do { var r = n.nextSibling; if (t.removeChild(n), r && r.nodeType === 8) if (n = r.data, n === "/$") { if (0 < a && 8 > a) { n = a; var f = t.ownerDocument; if (n & 1 && Fi(f.documentElement), n & 2 && Fi(f.body), n & 4) for (n = f.head, Fi(n), f = n.firstChild; f;) { var p = f.nextSibling, S = f.nodeName; f[fi] || S === "SCRIPT" || S === "STYLE" || S === "LINK" && f.rel.toLowerCase() === "stylesheet" || n.removeChild(f), f = p } } if (s === 0) { t.removeChild(r), il(e); return } s-- } else n === "$" || n === "$?" || n === "$!" ? s++ : a = n.charCodeAt(0) - 48; else a = 0; n = r } while (n); il(e) } function or(t) { var e = t.firstChild; for (e && e.nodeType === 10 && (e = e.nextSibling); e;) { var n = e; switch (e = e.nextSibling, n.nodeName) { case "HTML": case "HEAD": case "BODY": or(n), hu(n); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (n.rel.toLowerCase() === "stylesheet") continue }t.removeChild(n) } } function Bv(t, e, n, a) { for (; t.nodeType === 1;) { var s = n; if (t.nodeName.toLowerCase() !== e.toLowerCase()) { if (!a && (t.nodeName !== "INPUT" || t.type !== "hidden")) break } else if (a) { if (!t[fi]) switch (e) { case "meta": if (!t.hasAttribute("itemprop")) break; return t; case "link": if (r = t.getAttribute("rel"), r === "stylesheet" && t.hasAttribute("data-precedence")) break; if (r !== s.rel || t.getAttribute("href") !== (s.href == null || s.href === "" ? null : s.href) || t.getAttribute("crossorigin") !== (s.crossOrigin == null ? null : s.crossOrigin) || t.getAttribute("title") !== (s.title == null ? null : s.title)) break; return t; case "style": if (t.hasAttribute("data-precedence")) break; return t; case "script": if (r = t.getAttribute("src"), (r !== (s.src == null ? null : s.src) || t.getAttribute("type") !== (s.type == null ? null : s.type) || t.getAttribute("crossorigin") !== (s.crossOrigin == null ? null : s.crossOrigin)) && r && t.hasAttribute("async") && !t.hasAttribute("itemprop")) break; return t; default: return t } } else if (e === "input" && t.type === "hidden") { var r = s.name == null ? null : "" + s.name; if (s.type === "hidden" && t.getAttribute("name") === r) return t } else return t; if (t = _e(t.nextSibling), t === null) break } return null } function jv(t, e, n) { if (e === "") return null; for (; t.nodeType !== 3;)if ((t.nodeType !== 1 || t.nodeName !== "INPUT" || t.type !== "hidden") && !n || (t = _e(t.nextSibling), t === null)) return null; return t } function rr(t) { return t.data === "$!" || t.data === "$?" && t.ownerDocument.readyState === "complete" } function wv(t, e) { var n = t.ownerDocument; if (t.data !== "$?" || n.readyState === "complete") e(); else { var a = function () { e(), n.removeEventListener("DOMContentLoaded", a) }; n.addEventListener("DOMContentLoaded", a), t._reactRetry = a } } function _e(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?" || e === "F!" || e === "F") break; if (e === "/$") return null } } return t } var cr = null; function pm(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } function ym(t, e, n) { switch (e = Ds(n), t) { case "html": if (t = e.documentElement, !t) throw Error(o(452)); return t; case "head": if (t = e.head, !t) throw Error(o(453)); return t; case "body": if (t = e.body, !t) throw Error(o(454)); return t; default: throw Error(o(451)) } } function Fi(t) { for (var e = t.attributes; e.length;)t.removeAttributeNode(e[0]); hu(t) } var Oe = new Map, gm = new Set; function Rs(t) { return typeof t.getRootNode == "function" ? t.getRootNode() : t.nodeType === 9 ? t : t.ownerDocument } var on = L.d; L.d = { f: Lv, r: Hv, D: qv, C: Yv, L: Gv, m: Xv, X: Kv, S: Zv, M: Qv }; function Lv() { var t = on.f(), e = vs(); return t || e } function Hv(t) { var e = da(t); e !== null && e.tag === 5 && e.type === "form" ? wh(e) : on.r(t) } var Ja = typeof document > "u" ? null : document; function vm(t, e, n) { var a = Ja; if (a && typeof e == "string" && e) { var s = Te(e); s = 'link[rel="' + t + '"][href="' + s + '"]', typeof n == "string" && (s += '[crossorigin="' + n + '"]'), gm.has(s) || (gm.add(s), t = { rel: t, crossOrigin: n, href: e }, a.querySelector(s) === null && (e = a.createElement("link"), Ft(e, "link", t), Zt(e), a.head.appendChild(e))) } } function qv(t) { on.D(t), vm("dns-prefetch", t, null) } function Yv(t, e) { on.C(t, e), vm("preconnect", t, e) } function Gv(t, e, n) { on.L(t, e, n); var a = Ja; if (a && t && e) { var s = 'link[rel="preload"][as="' + Te(e) + '"]'; e === "image" && n && n.imageSrcSet ? (s += '[imagesrcset="' + Te(n.imageSrcSet) + '"]', typeof n.imageSizes == "string" && (s += '[imagesizes="' + Te(n.imageSizes) + '"]')) : s += '[href="' + Te(t) + '"]'; var r = s; switch (e) { case "style": r = ka(t); break; case "script": r = Pa(t) }Oe.has(r) || (t = v({ rel: "preload", href: e === "image" && n && n.imageSrcSet ? void 0 : t, as: e }, n), Oe.set(r, t), a.querySelector(s) !== null || e === "style" && a.querySelector(Wi(r)) || e === "script" && a.querySelector($i(r)) || (e = a.createElement("link"), Ft(e, "link", t), Zt(e), a.head.appendChild(e))) } } function Xv(t, e) { on.m(t, e); var n = Ja; if (n && t) { var a = e && typeof e.as == "string" ? e.as : "script", s = 'link[rel="modulepreload"][as="' + Te(a) + '"][href="' + Te(t) + '"]', r = s; switch (a) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": r = Pa(t) }if (!Oe.has(r) && (t = v({ rel: "modulepreload", href: t }, e), Oe.set(r, t), n.querySelector(s) === null)) { switch (a) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (n.querySelector($i(r))) return }a = n.createElement("link"), Ft(a, "link", t), Zt(a), n.head.appendChild(a) } } } function Zv(t, e, n) { on.S(t, e, n); var a = Ja; if (a && t) { var s = ma(a).hoistableStyles, r = ka(t); e = e || "default"; var f = s.get(r); if (!f) { var p = { loading: 0, preload: null }; if (f = a.querySelector(Wi(r))) p.loading = 5; else { t = v({ rel: "stylesheet", href: t, "data-precedence": e }, n), (n = Oe.get(r)) && fr(t, n); var S = f = a.createElement("link"); Zt(S), Ft(S, "link", t), S._p = new Promise(function (D, C) { S.onload = D, S.onerror = C }), S.addEventListener("load", function () { p.loading |= 1 }), S.addEventListener("error", function () { p.loading |= 2 }), p.loading |= 4, Os(f, e, a) } f = { type: "stylesheet", instance: f, count: 1, state: p }, s.set(r, f) } } } function Kv(t, e) { on.X(t, e); var n = Ja; if (n && t) { var a = ma(n).hoistableScripts, s = Pa(t), r = a.get(s); r || (r = n.querySelector($i(s)), r || (t = v({ src: t, async: !0 }, e), (e = Oe.get(s)) && hr(t, e), r = n.createElement("script"), Zt(r), Ft(r, "link", t), n.head.appendChild(r)), r = { type: "script", instance: r, count: 1, state: null }, a.set(s, r)) } } function Qv(t, e) { on.M(t, e); var n = Ja; if (n && t) { var a = ma(n).hoistableScripts, s = Pa(t), r = a.get(s); r || (r = n.querySelector($i(s)), r || (t = v({ src: t, async: !0, type: "module" }, e), (e = Oe.get(s)) && hr(t, e), r = n.createElement("script"), Zt(r), Ft(r, "link", t), n.head.appendChild(r)), r = { type: "script", instance: r, count: 1, state: null }, a.set(s, r)) } } function Sm(t, e, n, a) { var s = (s = lt.current) ? Rs(s) : null; if (!s) throw Error(o(446)); switch (t) { case "meta": case "title": return null; case "style": return typeof n.precedence == "string" && typeof n.href == "string" ? (e = ka(n.href), n = ma(s).hoistableStyles, a = n.get(e), a || (a = { type: "style", instance: null, count: 0, state: null }, n.set(e, a)), a) : { type: "void", instance: null, count: 0, state: null }; case "link": if (n.rel === "stylesheet" && typeof n.href == "string" && typeof n.precedence == "string") { t = ka(n.href); var r = ma(s).hoistableStyles, f = r.get(t); if (f || (s = s.ownerDocument || s, f = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, r.set(t, f), (r = s.querySelector(Wi(t))) && !r._p && (f.instance = r, f.state.loading = 5), Oe.has(t) || (n = { rel: "preload", as: "style", href: n.href, crossOrigin: n.crossOrigin, integrity: n.integrity, media: n.media, hrefLang: n.hrefLang, referrerPolicy: n.referrerPolicy }, Oe.set(t, n), r || Jv(s, t, n, f.state))), e && a === null) throw Error(o(528, "")); return f } if (e && a !== null) throw Error(o(529, "")); return null; case "script": return e = n.async, n = n.src, typeof n == "string" && e && typeof e != "function" && typeof e != "symbol" ? (e = Pa(n), n = ma(s).hoistableScripts, a = n.get(e), a || (a = { type: "script", instance: null, count: 0, state: null }, n.set(e, a)), a) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(o(444, t)) } } function ka(t) { return 'href="' + Te(t) + '"' } function Wi(t) { return 'link[rel="stylesheet"][' + t + "]" } function bm(t) { return v({}, t, { "data-precedence": t.precedence, precedence: null }) } function Jv(t, e, n, a) { t.querySelector('link[rel="preload"][as="style"][' + e + "]") ? a.loading = 1 : (e = t.createElement("link"), a.preload = e, e.addEventListener("load", function () { return a.loading |= 1 }), e.addEventListener("error", function () { return a.loading |= 2 }), Ft(e, "link", n), Zt(e), t.head.appendChild(e)) } function Pa(t) { return '[src="' + Te(t) + '"]' } function $i(t) { return "script[async]" + t } function Tm(t, e, n) { if (e.count++, e.instance === null) switch (e.type) { case "style": var a = t.querySelector('style[data-href~="' + Te(n.href) + '"]'); if (a) return e.instance = a, Zt(a), a; var s = v({}, n, { "data-href": n.href, "data-precedence": n.precedence, href: null, precedence: null }); return a = (t.ownerDocument || t).createElement("style"), Zt(a), Ft(a, "style", s), Os(a, n.precedence, t), e.instance = a; case "stylesheet": s = ka(n.href); var r = t.querySelector(Wi(s)); if (r) return e.state.loading |= 4, e.instance = r, Zt(r), r; a = bm(n), (s = Oe.get(s)) && fr(a, s), r = (t.ownerDocument || t).createElement("link"), Zt(r); var f = r; return f._p = new Promise(function (p, S) { f.onload = p, f.onerror = S }), Ft(r, "link", a), e.state.loading |= 4, Os(r, n.precedence, t), e.instance = r; case "script": return r = Pa(n.src), (s = t.querySelector($i(r))) ? (e.instance = s, Zt(s), s) : (a = n, (s = Oe.get(r)) && (a = v({}, n), hr(a, s)), t = t.ownerDocument || t, s = t.createElement("script"), Zt(s), Ft(s, "link", a), t.head.appendChild(s), e.instance = s); case "void": return null; default: throw Error(o(443, e.type)) } else e.type === "stylesheet" && (e.state.loading & 4) === 0 && (a = e.instance, e.state.loading |= 4, Os(a, n.precedence, t)); return e.instance } function Os(t, e, n) { for (var a = n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), s = a.length ? a[a.length - 1] : null, r = s, f = 0; f < a.length; f++) { var p = a[f]; if (p.dataset.precedence === e) r = p; else if (r !== s) break } r ? r.parentNode.insertBefore(t, r.nextSibling) : (e = n.nodeType === 9 ? n.head : n, e.insertBefore(t, e.firstChild)) } function fr(t, e) { t.crossOrigin == null && (t.crossOrigin = e.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = e.referrerPolicy), t.title == null && (t.title = e.title) } function hr(t, e) { t.crossOrigin == null && (t.crossOrigin = e.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = e.referrerPolicy), t.integrity == null && (t.integrity = e.integrity) } var Cs = null; function Am(t, e, n) { if (Cs === null) { var a = new Map, s = Cs = new Map; s.set(n, a) } else s = Cs, a = s.get(n), a || (a = new Map, s.set(n, a)); if (a.has(t)) return a; for (a.set(t, null), n = n.getElementsByTagName(t), s = 0; s < n.length; s++) { var r = n[s]; if (!(r[fi] || r[$t] || t === "link" && r.getAttribute("rel") === "stylesheet") && r.namespaceURI !== "http://www.w3.org/2000/svg") { var f = r.getAttribute(e) || ""; f = t + f; var p = a.get(f); p ? p.push(r) : a.set(f, [r]) } } return a } function xm(t, e, n) { t = t.ownerDocument || t, t.head.insertBefore(n, e === "title" ? t.querySelector("head > title") : null) } function kv(t, e, n) { if (n === 1 || e.itemProp != null) return !1; switch (t) { case "meta": case "title": return !0; case "style": if (typeof e.precedence != "string" || typeof e.href != "string" || e.href === "") break; return !0; case "link": if (typeof e.rel != "string" || typeof e.href != "string" || e.href === "" || e.onLoad || e.onError) break; switch (e.rel) { case "stylesheet": return t = e.disabled, typeof e.precedence == "string" && t == null; default: return !0 }case "script": if (e.async && typeof e.async != "function" && typeof e.async != "symbol" && !e.onLoad && !e.onError && e.src && typeof e.src == "string") return !0 }return !1 } function Em(t) { return !(t.type === "stylesheet" && (t.state.loading & 3) === 0) } var Ii = null; function Pv() { } function Fv(t, e, n) { if (Ii === null) throw Error(o(475)); var a = Ii; if (e.type === "stylesheet" && (typeof n.media != "string" || matchMedia(n.media).matches !== !1) && (e.state.loading & 4) === 0) { if (e.instance === null) { var s = ka(n.href), r = t.querySelector(Wi(s)); if (r) { t = r._p, t !== null && typeof t == "object" && typeof t.then == "function" && (a.count++, a = Vs.bind(a), t.then(a, a)), e.state.loading |= 4, e.instance = r, Zt(r); return } r = t.ownerDocument || t, n = bm(n), (s = Oe.get(s)) && fr(n, s), r = r.createElement("link"), Zt(r); var f = r; f._p = new Promise(function (p, S) { f.onload = p, f.onerror = S }), Ft(r, "link", n), e.instance = r } a.stylesheets === null && (a.stylesheets = new Map), a.stylesheets.set(e, t), (t = e.state.preload) && (e.state.loading & 3) === 0 && (a.count++, e = Vs.bind(a), t.addEventListener("load", e), t.addEventListener("error", e)) } } function Wv() { if (Ii === null) throw Error(o(475)); var t = Ii; return t.stylesheets && t.count === 0 && dr(t, t.stylesheets), 0 < t.count ? function (e) { var n = setTimeout(function () { if (t.stylesheets && dr(t, t.stylesheets), t.unsuspend) { var a = t.unsuspend; t.unsuspend = null, a() } }, 6e4); return t.unsuspend = e, function () { t.unsuspend = null, clearTimeout(n) } } : null } function Vs() { if (this.count--, this.count === 0) { if (this.stylesheets) dr(this, this.stylesheets); else if (this.unsuspend) { var t = this.unsuspend; this.unsuspend = null, t() } } } var zs = null; function dr(t, e) { t.stylesheets = null, t.unsuspend !== null && (t.count++, zs = new Map, e.forEach($v, t), zs = null, Vs.call(t)) } function $v(t, e) { if (!(e.state.loading & 4)) { var n = zs.get(t); if (n) var a = n.get(null); else { n = new Map, zs.set(t, n); for (var s = t.querySelectorAll("link[data-precedence],style[data-precedence]"), r = 0; r < s.length; r++) { var f = s[r]; (f.nodeName === "LINK" || f.getAttribute("media") !== "not all") && (n.set(f.dataset.precedence, f), a = f) } a && n.set(null, a) } s = e.instance, f = s.getAttribute("data-precedence"), r = n.get(f) || a, r === a && n.set(null, s), n.set(f, s), this.count++, a = Vs.bind(this), s.addEventListener("load", a), s.addEventListener("error", a), r ? r.parentNode.insertBefore(s, r.nextSibling) : (t = t.nodeType === 9 ? t.head : t, t.insertBefore(s, t.firstChild)), e.state.loading |= 4 } } var tl = { $$typeof: Y, Provider: null, Consumer: null, _currentValue: J, _currentValue2: J, _threadCount: 0 }; function Iv(t, e, n, a, s, r, f, p) { this.tag = 1, this.containerInfo = t, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = ou(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ou(0), this.hiddenUpdates = ou(null), this.identifierPrefix = a, this.onUncaughtError = s, this.onCaughtError = r, this.onRecoverableError = f, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = p, this.incompleteTransitions = new Map } function Mm(t, e, n, a, s, r, f, p, S, D, C, _) { return t = new Iv(t, e, n, f, p, S, D, _), e = 1, r === !0 && (e |= 24), r = me(3, null, null, e), t.current = r, r.stateNode = t, e = Ju(), e.refCount++, t.pooledCache = e, e.refCount++, r.memoizedState = { element: a, isDehydrated: n, cache: e }, Wu(r), t } function Dm(t) { return t ? (t = Da, t) : Da } function Rm(t, e, n, a, s, r) { s = Dm(s), a.context === null ? a.context = s : a.pendingContext = s, a = vn(e), a.payload = { element: n }, r = r === void 0 ? null : r, r !== null && (a.callback = r), n = Sn(t, a, e), n !== null && (Se(n, t, e), Vi(n, t, e)) } function Om(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function mr(t, e) { Om(t, e), (t = t.alternate) && Om(t, e) } function Cm(t) { if (t.tag === 13) { var e = Ma(t, 67108864); e !== null && Se(e, t, 67108864), mr(t, 67108864) } } var Ns = !0; function t1(t, e, n, a) { var s = z.T; z.T = null; var r = L.p; try { L.p = 2, pr(t, e, n, a) } finally { L.p = r, z.T = s } } function e1(t, e, n, a) { var s = z.T; z.T = null; var r = L.p; try { L.p = 8, pr(t, e, n, a) } finally { L.p = r, z.T = s } } function pr(t, e, n, a) { if (Ns) { var s = yr(a); if (s === null) nr(t, e, a, Us, n), zm(t, a); else if (a1(s, t, e, n, a)) a.stopPropagation(); else if (zm(t, a), e & 4 && -1 < n1.indexOf(t)) { for (; s !== null;) { var r = da(s); if (r !== null) switch (r.tag) { case 3: if (r = r.stateNode, r.current.memoizedState.isDehydrated) { var f = Yn(r.pendingLanes); if (f !== 0) { var p = r; for (p.pendingLanes |= 2, p.entangledLanes |= 2; f;) { var S = 1 << 31 - he(f); p.entanglements[1] |= S, f &= ~S } Ge(r), (gt & 6) === 0 && (ys = we() + 500, Ji(0)) } } break; case 13: p = Ma(r, 2), p !== null && Se(p, r, 2), vs(), mr(r, 2) }if (r = yr(a), r === null && nr(t, e, a, Us, n), r === s) break; s = r } s !== null && a.stopPropagation() } else nr(t, e, a, null, n) } } function yr(t) { return t = bu(t), gr(t) } var Us = null; function gr(t) { if (Us = null, t = ha(t), t !== null) { var e = d(t); if (e === null) t = null; else { var n = e.tag; if (n === 13) { if (t = h(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null) } } return Us = t, null } function Vm(t) { switch (t) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch (Yg()) { case Xc: return 2; case Zc: return 8; case Ml: case Gg: return 32; case Kc: return 268435456; default: return 32 }default: return 32 } } var vr = !1, Nn = null, Un = null, _n = null, el = new Map, nl = new Map, Bn = [], n1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function zm(t, e) { switch (t) { case "focusin": case "focusout": Nn = null; break; case "dragenter": case "dragleave": Un = null; break; case "mouseover": case "mouseout": _n = null; break; case "pointerover": case "pointerout": el.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": nl.delete(e.pointerId) } } function al(t, e, n, a, s, r) { return t === null || t.nativeEvent !== r ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: a, nativeEvent: r, targetContainers: [s] }, e !== null && (e = da(e), e !== null && Cm(e)), t) : (t.eventSystemFlags |= a, e = t.targetContainers, s !== null && e.indexOf(s) === -1 && e.push(s), t) } function a1(t, e, n, a, s) { switch (e) { case "focusin": return Nn = al(Nn, t, e, n, a, s), !0; case "dragenter": return Un = al(Un, t, e, n, a, s), !0; case "mouseover": return _n = al(_n, t, e, n, a, s), !0; case "pointerover": var r = s.pointerId; return el.set(r, al(el.get(r) || null, t, e, n, a, s)), !0; case "gotpointercapture": return r = s.pointerId, nl.set(r, al(nl.get(r) || null, t, e, n, a, s)), !0 }return !1 } function Nm(t) { var e = ha(t.target); if (e !== null) { var n = d(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = h(n), e !== null) { t.blockedOn = e, Fg(t.priority, function () { if (n.tag === 13) { var a = ve(); a = ru(a); var s = Ma(n, a); s !== null && Se(s, n, a), mr(n, a) } }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function _s(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = yr(t.nativeEvent); if (n === null) { n = t.nativeEvent; var a = new n.constructor(n.type, n); Su = a, n.target.dispatchEvent(a), Su = null } else return e = da(n), e !== null && Cm(e), t.blockedOn = n, !1; e.shift() } return !0 } function Um(t, e, n) { _s(t) && n.delete(e) } function i1() { vr = !1, Nn !== null && _s(Nn) && (Nn = null), Un !== null && _s(Un) && (Un = null), _n !== null && _s(_n) && (_n = null), el.forEach(Um), nl.forEach(Um) } function Bs(t, e) { t.blockedOn === e && (t.blockedOn = null, vr || (vr = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, i1))) } var js = null; function _m(t) { js !== t && (js = t, i.unstable_scheduleCallback(i.unstable_NormalPriority, function () { js === t && (js = null); for (var e = 0; e < t.length; e += 3) { var n = t[e], a = t[e + 1], s = t[e + 2]; if (typeof a != "function") { if (gr(a || n) === null) continue; break } var r = da(n); r !== null && (t.splice(e, 3), e -= 3, go(r, { pending: !0, data: s, method: n.method, action: a }, a, s)) } })) } function il(t) { function e(S) { return Bs(S, t) } Nn !== null && Bs(Nn, t), Un !== null && Bs(Un, t), _n !== null && Bs(_n, t), el.forEach(e), nl.forEach(e); for (var n = 0; n < Bn.length; n++) { var a = Bn[n]; a.blockedOn === t && (a.blockedOn = null) } for (; 0 < Bn.length && (n = Bn[0], n.blockedOn === null);)Nm(n), n.blockedOn === null && Bn.shift(); if (n = (t.ownerDocument || t).$$reactFormReplay, n != null) for (a = 0; a < n.length; a += 3) { var s = n[a], r = n[a + 1], f = s[ie] || null; if (typeof r == "function") f || _m(n); else if (f) { var p = null; if (r && r.hasAttribute("formAction")) { if (s = r, f = r[ie] || null) p = f.formAction; else if (gr(s) !== null) continue } else p = f.action; typeof p == "function" ? n[a + 1] = p : (n.splice(a, 3), a -= 3), _m(n) } } } function Sr(t) { this._internalRoot = t } ws.prototype.render = Sr.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(o(409)); var n = e.current, a = ve(); Rm(n, a, t, e, null, null) }, ws.prototype.unmount = Sr.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; Rm(t.current, 2, null, t, null, null), vs(), e[fa] = null } }; function ws(t) { this._internalRoot = t } ws.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = Fc(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < Bn.length && e !== 0 && e < Bn[n].priority; n++); Bn.splice(n, 0, t), n === 0 && Nm(t) } }; var Bm = l.version; if (Bm !== "19.1.1") throw Error(o(527, Bm, "19.1.1")); L.findDOMNode = function (t) { var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(o(188)) : (t = Object.keys(t).join(","), Error(o(268, t))); return t = y(e), t = t !== null ? m(t) : null, t = t === null ? null : t.stateNode, t }; var l1 = { bundleType: 0, version: "19.1.1", rendererPackageName: "react-dom", currentDispatcherRef: z, reconcilerVersion: "19.1.1" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Ls = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Ls.isDisabled && Ls.supportsFiber) try { oi = Ls.inject(l1), fe = Ls } catch { } } return sl.createRoot = function (t, e) { if (!c(t)) throw Error(o(299)); var n = !1, a = "", s = Wh, r = $h, f = Ih, p = null; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (a = e.identifierPrefix), e.onUncaughtError !== void 0 && (s = e.onUncaughtError), e.onCaughtError !== void 0 && (r = e.onCaughtError), e.onRecoverableError !== void 0 && (f = e.onRecoverableError), e.unstable_transitionCallbacks !== void 0 && (p = e.unstable_transitionCallbacks)), e = Mm(t, 1, !1, null, null, n, a, s, r, f, p, null), t[fa] = e.current, er(t), new Sr(e) }, sl.hydrateRoot = function (t, e, n) { if (!c(t)) throw Error(o(299)); var a = !1, s = "", r = Wh, f = $h, p = Ih, S = null, D = null; return n != null && (n.unstable_strictMode === !0 && (a = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onUncaughtError !== void 0 && (r = n.onUncaughtError), n.onCaughtError !== void 0 && (f = n.onCaughtError), n.onRecoverableError !== void 0 && (p = n.onRecoverableError), n.unstable_transitionCallbacks !== void 0 && (S = n.unstable_transitionCallbacks), n.formState !== void 0 && (D = n.formState)), e = Mm(t, 1, !0, e, n ?? null, a, s, r, f, p, S, D), e.context = Dm(null), n = e.current, a = ve(), a = ru(a), s = vn(a), s.callback = null, Sn(n, s, a), n = a, e.current.lanes = n, ci(e, n), Ge(e), t[fa] = e.current, er(t), new ws(e) }, sl.version = "19.1.1", sl
} var Km; function p1() { if (Km) return Ar.exports; Km = 1; function i() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i) } catch (l) { console.error(l) } } return i(), Ar.exports = m1(), Ar.exports } var y1 = p1(); const rc = X.createContext({}); function cc(i) { const l = X.useRef(null); return l.current === null && (l.current = i()), l.current } const fc = typeof window < "u", uy = fc ? X.useLayoutEffect : X.useEffect, Is = X.createContext(null); function hc(i, l) { i.indexOf(l) === -1 && i.push(l) } function dc(i, l) { const u = i.indexOf(l); u > -1 && i.splice(u, 1) } const cn = (i, l, u) => u > l ? l : u < i ? i : u; let mc = () => { }; const fn = {}, oy = i => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(i); function ry(i) { return typeof i == "object" && i !== null } const cy = i => /^0[^.\s]+$/u.test(i); function pc(i) { let l; return () => (l === void 0 && (l = i()), l) } const ze = i => i, g1 = (i, l) => u => l(i(u)), bl = (...i) => i.reduce(g1), ml = (i, l, u) => { const o = l - i; return o === 0 ? 1 : (u - i) / o }; class yc { constructor() { this.subscriptions = [] } add(l) { return hc(this.subscriptions, l), () => dc(this.subscriptions, l) } notify(l, u, o) { const c = this.subscriptions.length; if (c) if (c === 1) this.subscriptions[0](l, u, o); else for (let d = 0; d < c; d++) { const h = this.subscriptions[d]; h && h(l, u, o) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Xe = i => i * 1e3, Ze = i => i / 1e3; function fy(i, l) { return l ? i * (1e3 / l) : 0 } const hy = (i, l, u) => (((1 - 3 * u + 3 * l) * i + (3 * u - 6 * l)) * i + 3 * l) * i, v1 = 1e-7, S1 = 12; function b1(i, l, u, o, c) { let d, h, g = 0; do h = l + (u - l) / 2, d = hy(h, o, c) - i, d > 0 ? u = h : l = h; while (Math.abs(d) > v1 && ++g < S1); return h } function Tl(i, l, u, o) { if (i === l && u === o) return ze; const c = d => b1(d, 0, 1, i, u); return d => d === 0 || d === 1 ? d : hy(c(d), l, o) } const dy = i => l => l <= .5 ? i(2 * l) / 2 : (2 - i(2 * (1 - l))) / 2, my = i => l => 1 - i(1 - l), py = Tl(.33, 1.53, .69, .99), gc = my(py), yy = dy(gc), gy = i => (i *= 2) < 1 ? .5 * gc(i) : .5 * (2 - Math.pow(2, -10 * (i - 1))), vc = i => 1 - Math.sin(Math.acos(i)), vy = my(vc), Sy = dy(vc), T1 = Tl(.42, 0, 1, 1), A1 = Tl(0, 0, .58, 1), by = Tl(.42, 0, .58, 1), x1 = i => Array.isArray(i) && typeof i[0] != "number", Ty = i => Array.isArray(i) && typeof i[0] == "number", E1 = { linear: ze, easeIn: T1, easeInOut: by, easeOut: A1, circIn: vc, circInOut: Sy, circOut: vy, backIn: gc, backInOut: yy, backOut: py, anticipate: gy }, M1 = i => typeof i == "string", Qm = i => { if (Ty(i)) { mc(i.length === 4); const [l, u, o, c] = i; return Tl(l, u, o, c) } else if (M1(i)) return E1[i]; return i }, Hs = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function D1(i, l) { let u = new Set, o = new Set, c = !1, d = !1; const h = new WeakSet; let g = { delta: 0, timestamp: 0, isProcessing: !1 }; function y(v) { h.has(v) && (m.schedule(v), i()), v(g) } const m = { schedule: (v, b = !1, x = !1) => { const w = x && c ? u : o; return b && h.add(v), w.has(v) || w.add(v), v }, cancel: v => { o.delete(v), h.delete(v) }, process: v => { if (g = v, c) { d = !0; return } c = !0, [u, o] = [o, u], u.forEach(y), u.clear(), c = !1, d && (d = !1, m.process(v)) } }; return m } const R1 = 40; function Ay(i, l) { let u = !1, o = !0; const c = { delta: 0, timestamp: 0, isProcessing: !1 }, d = () => u = !0, h = Hs.reduce((Y, et) => (Y[et] = D1(d), Y), {}), { setup: g, read: y, resolveKeyframes: m, preUpdate: v, update: b, preRender: x, render: V, postRender: w } = h, U = () => { const Y = fn.useManualTiming ? c.timestamp : performance.now(); u = !1, fn.useManualTiming || (c.delta = o ? 1e3 / 60 : Math.max(Math.min(Y - c.timestamp, R1), 1)), c.timestamp = Y, c.isProcessing = !0, g.process(c), y.process(c), m.process(c), v.process(c), b.process(c), x.process(c), V.process(c), w.process(c), c.isProcessing = !1, u && l && (o = !1, i(U)) }, B = () => { u = !0, o = !0, c.isProcessing || i(U) }; return { schedule: Hs.reduce((Y, et) => { const H = h[et]; return Y[et] = (W, nt = !1, P = !1) => (u || B(), H.schedule(W, nt, P)), Y }, {}), cancel: Y => { for (let et = 0; et < Hs.length; et++)h[Hs[et]].cancel(Y) }, state: c, steps: h } } const { schedule: Dt, cancel: Ln, state: Wt, steps: Dr } = Ay(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ze, !0); let Xs; function O1() { Xs = void 0 } const re = { now: () => (Xs === void 0 && re.set(Wt.isProcessing || fn.useManualTiming ? Wt.timestamp : performance.now()), Xs), set: i => { Xs = i, queueMicrotask(O1) } }, xy = i => l => typeof l == "string" && l.startsWith(i), Sc = xy("--"), C1 = xy("var(--"), bc = i => C1(i) ? V1.test(i.split("/*")[0].trim()) : !1, V1 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, li = { test: i => typeof i == "number", parse: parseFloat, transform: i => i }, pl = { ...li, transform: i => cn(0, 1, i) }, qs = { ...li, default: 1 }, rl = i => Math.round(i * 1e5) / 1e5, Tc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function z1(i) { return i == null } const N1 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Ac = (i, l) => u => !!(typeof u == "string" && N1.test(u) && u.startsWith(i) || l && !z1(u) && Object.prototype.hasOwnProperty.call(u, l)), Ey = (i, l, u) => o => { if (typeof o != "string") return o; const [c, d, h, g] = o.match(Tc); return { [i]: parseFloat(c), [l]: parseFloat(d), [u]: parseFloat(h), alpha: g !== void 0 ? parseFloat(g) : 1 } }, U1 = i => cn(0, 255, i), Rr = { ...li, transform: i => Math.round(U1(i)) }, ua = { test: Ac("rgb", "red"), parse: Ey("red", "green", "blue"), transform: ({ red: i, green: l, blue: u, alpha: o = 1 }) => "rgba(" + Rr.transform(i) + ", " + Rr.transform(l) + ", " + Rr.transform(u) + ", " + rl(pl.transform(o)) + ")" }; function _1(i) { let l = "", u = "", o = "", c = ""; return i.length > 5 ? (l = i.substring(1, 3), u = i.substring(3, 5), o = i.substring(5, 7), c = i.substring(7, 9)) : (l = i.substring(1, 2), u = i.substring(2, 3), o = i.substring(3, 4), c = i.substring(4, 5), l += l, u += u, o += o, c += c), { red: parseInt(l, 16), green: parseInt(u, 16), blue: parseInt(o, 16), alpha: c ? parseInt(c, 16) / 255 : 1 } } const Yr = { test: Ac("#"), parse: _1, transform: ua.transform }, Al = i => ({ test: l => typeof l == "string" && l.endsWith(i) && l.split(" ").length === 1, parse: parseFloat, transform: l => `${l}${i}` }), wn = Al("deg"), Ke = Al("%"), it = Al("px"), B1 = Al("vh"), j1 = Al("vw"), Jm = { ...Ke, parse: i => Ke.parse(i) / 100, transform: i => Ke.transform(i * 100) }, Wa = { test: Ac("hsl", "hue"), parse: Ey("hue", "saturation", "lightness"), transform: ({ hue: i, saturation: l, lightness: u, alpha: o = 1 }) => "hsla(" + Math.round(i) + ", " + Ke.transform(rl(l)) + ", " + Ke.transform(rl(u)) + ", " + rl(pl.transform(o)) + ")" }, Lt = { test: i => ua.test(i) || Yr.test(i) || Wa.test(i), parse: i => ua.test(i) ? ua.parse(i) : Wa.test(i) ? Wa.parse(i) : Yr.parse(i), transform: i => typeof i == "string" ? i : i.hasOwnProperty("red") ? ua.transform(i) : Wa.transform(i), getAnimatableNone: i => { const l = Lt.parse(i); return l.alpha = 0, Lt.transform(l) } }, w1 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function L1(i) { return isNaN(i) && typeof i == "string" && (i.match(Tc)?.length || 0) + (i.match(w1)?.length || 0) > 0 } const My = "number", Dy = "color", H1 = "var", q1 = "var(", km = "${}", Y1 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function yl(i) { const l = i.toString(), u = [], o = { color: [], number: [], var: [] }, c = []; let d = 0; const g = l.replace(Y1, y => (Lt.test(y) ? (o.color.push(d), c.push(Dy), u.push(Lt.parse(y))) : y.startsWith(q1) ? (o.var.push(d), c.push(H1), u.push(y)) : (o.number.push(d), c.push(My), u.push(parseFloat(y))), ++d, km)).split(km); return { values: u, split: g, indexes: o, types: c } } function Ry(i) { return yl(i).values } function Oy(i) { const { split: l, types: u } = yl(i), o = l.length; return c => { let d = ""; for (let h = 0; h < o; h++)if (d += l[h], c[h] !== void 0) { const g = u[h]; g === My ? d += rl(c[h]) : g === Dy ? d += Lt.transform(c[h]) : d += c[h] } return d } } const G1 = i => typeof i == "number" ? 0 : Lt.test(i) ? Lt.getAnimatableNone(i) : i; function X1(i) { const l = Ry(i); return Oy(i)(l.map(G1)) } const Hn = { test: L1, parse: Ry, createTransformer: Oy, getAnimatableNone: X1 }; function Or(i, l, u) { return u < 0 && (u += 1), u > 1 && (u -= 1), u < 1 / 6 ? i + (l - i) * 6 * u : u < 1 / 2 ? l : u < 2 / 3 ? i + (l - i) * (2 / 3 - u) * 6 : i } function Z1({ hue: i, saturation: l, lightness: u, alpha: o }) { i /= 360, l /= 100, u /= 100; let c = 0, d = 0, h = 0; if (!l) c = d = h = u; else { const g = u < .5 ? u * (1 + l) : u + l - u * l, y = 2 * u - g; c = Or(y, g, i + 1 / 3), d = Or(y, g, i), h = Or(y, g, i - 1 / 3) } return { red: Math.round(c * 255), green: Math.round(d * 255), blue: Math.round(h * 255), alpha: o } } function ks(i, l) { return u => u > 0 ? l : i } const Ot = (i, l, u) => i + (l - i) * u, Cr = (i, l, u) => { const o = i * i, c = u * (l * l - o) + o; return c < 0 ? 0 : Math.sqrt(c) }, K1 = [Yr, ua, Wa], Q1 = i => K1.find(l => l.test(i)); function Pm(i) { const l = Q1(i); if (!l) return !1; let u = l.parse(i); return l === Wa && (u = Z1(u)), u } const Fm = (i, l) => { const u = Pm(i), o = Pm(l); if (!u || !o) return ks(i, l); const c = { ...u }; return d => (c.red = Cr(u.red, o.red, d), c.green = Cr(u.green, o.green, d), c.blue = Cr(u.blue, o.blue, d), c.alpha = Ot(u.alpha, o.alpha, d), ua.transform(c)) }, Gr = new Set(["none", "hidden"]); function J1(i, l) { return Gr.has(i) ? u => u <= 0 ? i : l : u => u >= 1 ? l : i } function k1(i, l) { return u => Ot(i, l, u) } function xc(i) { return typeof i == "number" ? k1 : typeof i == "string" ? bc(i) ? ks : Lt.test(i) ? Fm : W1 : Array.isArray(i) ? Cy : typeof i == "object" ? Lt.test(i) ? Fm : P1 : ks } function Cy(i, l) { const u = [...i], o = u.length, c = i.map((d, h) => xc(d)(d, l[h])); return d => { for (let h = 0; h < o; h++)u[h] = c[h](d); return u } } function P1(i, l) { const u = { ...i, ...l }, o = {}; for (const c in u) i[c] !== void 0 && l[c] !== void 0 && (o[c] = xc(i[c])(i[c], l[c])); return c => { for (const d in o) u[d] = o[d](c); return u } } function F1(i, l) { const u = [], o = { color: 0, var: 0, number: 0 }; for (let c = 0; c < l.values.length; c++) { const d = l.types[c], h = i.indexes[d][o[d]], g = i.values[h] ?? 0; u[c] = g, o[d]++ } return u } const W1 = (i, l) => { const u = Hn.createTransformer(l), o = yl(i), c = yl(l); return o.indexes.var.length === c.indexes.var.length && o.indexes.color.length === c.indexes.color.length && o.indexes.number.length >= c.indexes.number.length ? Gr.has(i) && !c.values.length || Gr.has(l) && !o.values.length ? J1(i, l) : bl(Cy(F1(o, c), c.values), u) : ks(i, l) }; function Vy(i, l, u) { return typeof i == "number" && typeof l == "number" && typeof u == "number" ? Ot(i, l, u) : xc(i)(i, l) } const $1 = i => { const l = ({ timestamp: u }) => i(u); return { start: (u = !0) => Dt.update(l, u), stop: () => Ln(l), now: () => Wt.isProcessing ? Wt.timestamp : re.now() } }, zy = (i, l, u = 10) => { let o = ""; const c = Math.max(Math.round(l / u), 2); for (let d = 0; d < c; d++)o += Math.round(i(d / (c - 1)) * 1e4) / 1e4 + ", "; return `linear(${o.substring(0, o.length - 2)})` }, Ps = 2e4; function Ec(i) { let l = 0; const u = 50; let o = i.next(l); for (; !o.done && l < Ps;)l += u, o = i.next(l); return l >= Ps ? 1 / 0 : l } function I1(i, l = 100, u) { const o = u({ ...i, keyframes: [0, l] }), c = Math.min(Ec(o), Ps); return { type: "keyframes", ease: d => o.next(c * d).value / l, duration: Ze(c) } } const tS = 5; function Ny(i, l, u) { const o = Math.max(l - tS, 0); return fy(u - i(o), l - o) } const Nt = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Vr = .001; function eS({ duration: i = Nt.duration, bounce: l = Nt.bounce, velocity: u = Nt.velocity, mass: o = Nt.mass }) { let c, d, h = 1 - l; h = cn(Nt.minDamping, Nt.maxDamping, h), i = cn(Nt.minDuration, Nt.maxDuration, Ze(i)), h < 1 ? (c = m => { const v = m * h, b = v * i, x = v - u, V = Xr(m, h), w = Math.exp(-b); return Vr - x / V * w }, d = m => { const b = m * h * i, x = b * u + u, V = Math.pow(h, 2) * Math.pow(m, 2) * i, w = Math.exp(-b), U = Xr(Math.pow(m, 2), h); return (-c(m) + Vr > 0 ? -1 : 1) * ((x - V) * w) / U }) : (c = m => { const v = Math.exp(-m * i), b = (m - u) * i + 1; return -Vr + v * b }, d = m => { const v = Math.exp(-m * i), b = (u - m) * (i * i); return v * b }); const g = 5 / i, y = aS(c, d, g); if (i = Xe(i), isNaN(y)) return { stiffness: Nt.stiffness, damping: Nt.damping, duration: i }; { const m = Math.pow(y, 2) * o; return { stiffness: m, damping: h * 2 * Math.sqrt(o * m), duration: i } } } const nS = 12; function aS(i, l, u) { let o = u; for (let c = 1; c < nS; c++)o = o - i(o) / l(o); return o } function Xr(i, l) { return i * Math.sqrt(1 - l * l) } const iS = ["duration", "bounce"], lS = ["stiffness", "damping", "mass"]; function Wm(i, l) { return l.some(u => i[u] !== void 0) } function sS(i) { let l = { velocity: Nt.velocity, stiffness: Nt.stiffness, damping: Nt.damping, mass: Nt.mass, isResolvedFromDuration: !1, ...i }; if (!Wm(i, lS) && Wm(i, iS)) if (i.visualDuration) { const u = i.visualDuration, o = 2 * Math.PI / (u * 1.2), c = o * o, d = 2 * cn(.05, 1, 1 - (i.bounce || 0)) * Math.sqrt(c); l = { ...l, mass: Nt.mass, stiffness: c, damping: d } } else { const u = eS(i); l = { ...l, ...u, mass: Nt.mass }, l.isResolvedFromDuration = !0 } return l } function Fs(i = Nt.visualDuration, l = Nt.bounce) { const u = typeof i != "object" ? { visualDuration: i, keyframes: [0, 1], bounce: l } : i; let { restSpeed: o, restDelta: c } = u; const d = u.keyframes[0], h = u.keyframes[u.keyframes.length - 1], g = { done: !1, value: d }, { stiffness: y, damping: m, mass: v, duration: b, velocity: x, isResolvedFromDuration: V } = sS({ ...u, velocity: -Ze(u.velocity || 0) }), w = x || 0, U = m / (2 * Math.sqrt(y * v)), B = h - d, q = Ze(Math.sqrt(y / v)), Z = Math.abs(B) < 5; o || (o = Z ? Nt.restSpeed.granular : Nt.restSpeed.default), c || (c = Z ? Nt.restDelta.granular : Nt.restDelta.default); let Y; if (U < 1) { const H = Xr(q, U); Y = W => { const nt = Math.exp(-U * q * W); return h - nt * ((w + U * q * B) / H * Math.sin(H * W) + B * Math.cos(H * W)) } } else if (U === 1) Y = H => h - Math.exp(-q * H) * (B + (w + q * B) * H); else { const H = q * Math.sqrt(U * U - 1); Y = W => { const nt = Math.exp(-U * q * W), P = Math.min(H * W, 300); return h - nt * ((w + U * q * B) * Math.sinh(P) + H * B * Math.cosh(P)) / H } } const et = { calculatedDuration: V && b || null, next: H => { const W = Y(H); if (V) g.done = H >= b; else { let nt = H === 0 ? w : 0; U < 1 && (nt = H === 0 ? Xe(w) : Ny(Y, H, W)); const P = Math.abs(nt) <= o, yt = Math.abs(h - W) <= c; g.done = P && yt } return g.value = g.done ? h : W, g }, toString: () => { const H = Math.min(Ec(et), Ps), W = zy(nt => et.next(H * nt).value, H, 30); return H + "ms " + W }, toTransition: () => { } }; return et } Fs.applyToOptions = i => { const l = I1(i, 100, Fs); return i.ease = l.ease, i.duration = Xe(l.duration), i.type = "keyframes", i }; function Zr({ keyframes: i, velocity: l = 0, power: u = .8, timeConstant: o = 325, bounceDamping: c = 10, bounceStiffness: d = 500, modifyTarget: h, min: g, max: y, restDelta: m = .5, restSpeed: v }) { const b = i[0], x = { done: !1, value: b }, V = P => g !== void 0 && P < g || y !== void 0 && P > y, w = P => g === void 0 ? y : y === void 0 || Math.abs(g - P) < Math.abs(y - P) ? g : y; let U = u * l; const B = b + U, q = h === void 0 ? B : h(B); q !== B && (U = q - b); const Z = P => -U * Math.exp(-P / o), Y = P => q + Z(P), et = P => { const yt = Z(P), Ct = Y(P); x.done = Math.abs(yt) <= m, x.value = x.done ? q : Ct }; let H, W; const nt = P => { V(x.value) && (H = P, W = Fs({ keyframes: [x.value, w(x.value)], velocity: Ny(Y, P, x.value), damping: c, stiffness: d, restDelta: m, restSpeed: v })) }; return nt(0), { calculatedDuration: null, next: P => { let yt = !1; return !W && H === void 0 && (yt = !0, et(P), nt(P)), H !== void 0 && P >= H ? W.next(P - H) : (!yt && et(P), x) } } } function uS(i, l, u) { const o = [], c = u || fn.mix || Vy, d = i.length - 1; for (let h = 0; h < d; h++) { let g = c(i[h], i[h + 1]); if (l) { const y = Array.isArray(l) ? l[h] || ze : l; g = bl(y, g) } o.push(g) } return o } function oS(i, l, { clamp: u = !0, ease: o, mixer: c } = {}) { const d = i.length; if (mc(d === l.length), d === 1) return () => l[0]; if (d === 2 && l[0] === l[1]) return () => l[1]; const h = i[0] === i[1]; i[0] > i[d - 1] && (i = [...i].reverse(), l = [...l].reverse()); const g = uS(l, o, c), y = g.length, m = v => { if (h && v < i[0]) return l[0]; let b = 0; if (y > 1) for (; b < i.length - 2 && !(v < i[b + 1]); b++); const x = ml(i[b], i[b + 1], v); return g[b](x) }; return u ? v => m(cn(i[0], i[d - 1], v)) : m } function rS(i, l) { const u = i[i.length - 1]; for (let o = 1; o <= l; o++) { const c = ml(0, l, o); i.push(Ot(u, 1, c)) } } function cS(i) { const l = [0]; return rS(l, i.length - 1), l } function fS(i, l) { return i.map(u => u * l) } function hS(i, l) { return i.map(() => l || by).splice(0, i.length - 1) } function cl({ duration: i = 300, keyframes: l, times: u, ease: o = "easeInOut" }) { const c = x1(o) ? o.map(Qm) : Qm(o), d = { done: !1, value: l[0] }, h = fS(u && u.length === l.length ? u : cS(l), i), g = oS(h, l, { ease: Array.isArray(c) ? c : hS(l, c) }); return { calculatedDuration: i, next: y => (d.value = g(y), d.done = y >= i, d) } } const dS = i => i !== null; function Mc(i, { repeat: l, repeatType: u = "loop" }, o, c = 1) { const d = i.filter(dS), g = c < 0 || l && u !== "loop" && l % 2 === 1 ? 0 : d.length - 1; return !g || o === void 0 ? d[g] : o } const mS = { decay: Zr, inertia: Zr, tween: cl, keyframes: cl, spring: Fs }; function Uy(i) { typeof i.type == "string" && (i.type = mS[i.type]) } class Dc { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(l => { this.resolve = l }) } notifyFinished() { this.resolve() } then(l, u) { return this.finished.then(l, u) } } const pS = i => i / 100; class Rc extends Dc { constructor(l) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { const { motionValue: u } = this.options; u && u.updatedAt !== re.now() && this.tick(re.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.()) }, this.options = l, this.initAnimation(), this.play(), l.autoplay === !1 && this.pause() } initAnimation() { const { options: l } = this; Uy(l); const { type: u = cl, repeat: o = 0, repeatDelay: c = 0, repeatType: d, velocity: h = 0 } = l; let { keyframes: g } = l; const y = u || cl; y !== cl && typeof g[0] != "number" && (this.mixKeyframes = bl(pS, Vy(g[0], g[1])), g = [0, 100]); const m = y({ ...l, keyframes: g }); d === "mirror" && (this.mirroredGenerator = y({ ...l, keyframes: [...g].reverse(), velocity: -h })), m.calculatedDuration === null && (m.calculatedDuration = Ec(m)); const { calculatedDuration: v } = m; this.calculatedDuration = v, this.resolvedDuration = v + c, this.totalDuration = this.resolvedDuration * (o + 1) - c, this.generator = m } updateTime(l) { const u = Math.round(l - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = u } tick(l, u = !1) { const { generator: o, totalDuration: c, mixKeyframes: d, mirroredGenerator: h, resolvedDuration: g, calculatedDuration: y } = this; if (this.startTime === null) return o.next(0); const { delay: m = 0, keyframes: v, repeat: b, repeatType: x, repeatDelay: V, type: w, onUpdate: U, finalKeyframe: B } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, l) : this.speed < 0 && (this.startTime = Math.min(l - c / this.speed, this.startTime)), u ? this.currentTime = l : this.updateTime(l); const q = this.currentTime - m * (this.playbackSpeed >= 0 ? 1 : -1), Z = this.playbackSpeed >= 0 ? q < 0 : q > c; this.currentTime = Math.max(q, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c); let Y = this.currentTime, et = o; if (b) { const P = Math.min(this.currentTime, c) / g; let yt = Math.floor(P), Ct = P % 1; !Ct && P >= 1 && (Ct = 1), Ct === 1 && yt--, yt = Math.min(yt, b + 1), !!(yt % 2) && (x === "reverse" ? (Ct = 1 - Ct, V && (Ct -= V / g)) : x === "mirror" && (et = h)), Y = cn(0, 1, Ct) * g } const H = Z ? { done: !1, value: v[0] } : et.next(Y); d && (H.value = d(H.value)); let { done: W } = H; !Z && y !== null && (W = this.playbackSpeed >= 0 ? this.currentTime >= c : this.currentTime <= 0); const nt = this.holdTime === null && (this.state === "finished" || this.state === "running" && W); return nt && w !== Zr && (H.value = Mc(v, this.options, B, this.speed)), U && U(H.value), nt && this.finish(), H } then(l, u) { return this.finished.then(l, u) } get duration() { return Ze(this.calculatedDuration) } get time() { return Ze(this.currentTime) } set time(l) { l = Xe(l), this.currentTime = l, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = l : this.driver && (this.startTime = this.driver.now() - l / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(l) { this.updateTime(re.now()); const u = this.playbackSpeed !== l; this.playbackSpeed = l, u && (this.time = Ze(this.currentTime)) } play() { if (this.isStopped) return; const { driver: l = $1, startTime: u } = this.options; this.driver || (this.driver = l(c => this.tick(c))), this.options.onPlay?.(); const o = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = o) : this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime || (this.startTime = u ?? o), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(re.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(l) { return this.startTime = 0, this.tick(l, !0) } attachTimeline(l) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), l.observe(this) } } function yS(i) { for (let l = 1; l < i.length; l++)i[l] ?? (i[l] = i[l - 1]) } const oa = i => i * 180 / Math.PI, Kr = i => { const l = oa(Math.atan2(i[1], i[0])); return Qr(l) }, gS = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: i => (Math.abs(i[0]) + Math.abs(i[3])) / 2, rotate: Kr, rotateZ: Kr, skewX: i => oa(Math.atan(i[1])), skewY: i => oa(Math.atan(i[2])), skew: i => (Math.abs(i[1]) + Math.abs(i[2])) / 2 }, Qr = i => (i = i % 360, i < 0 && (i += 360), i), $m = Kr, Im = i => Math.sqrt(i[0] * i[0] + i[1] * i[1]), tp = i => Math.sqrt(i[4] * i[4] + i[5] * i[5]), vS = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: Im, scaleY: tp, scale: i => (Im(i) + tp(i)) / 2, rotateX: i => Qr(oa(Math.atan2(i[6], i[5]))), rotateY: i => Qr(oa(Math.atan2(-i[2], i[0]))), rotateZ: $m, rotate: $m, skewX: i => oa(Math.atan(i[4])), skewY: i => oa(Math.atan(i[1])), skew: i => (Math.abs(i[1]) + Math.abs(i[4])) / 2 }; function Jr(i) { return i.includes("scale") ? 1 : 0 } function kr(i, l) { if (!i || i === "none") return Jr(l); const u = i.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let o, c; if (u) o = vS, c = u; else { const g = i.match(/^matrix\(([-\d.e\s,]+)\)$/u); o = gS, c = g } if (!c) return Jr(l); const d = o[l], h = c[1].split(",").map(bS); return typeof d == "function" ? d(h) : h[d] } const SS = (i, l) => { const { transform: u = "none" } = getComputedStyle(i); return kr(u, l) }; function bS(i) { return parseFloat(i.trim()) } const si = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], ui = new Set(si), ep = i => i === li || i === it, TS = new Set(["x", "y", "z"]), AS = si.filter(i => !TS.has(i)); function xS(i) { const l = []; return AS.forEach(u => { const o = i.getValue(u); o !== void 0 && (l.push([u, o.get()]), o.set(u.startsWith("scale") ? 1 : 0)) }), l } const ra = { width: ({ x: i }, { paddingLeft: l = "0", paddingRight: u = "0" }) => i.max - i.min - parseFloat(l) - parseFloat(u), height: ({ y: i }, { paddingTop: l = "0", paddingBottom: u = "0" }) => i.max - i.min - parseFloat(l) - parseFloat(u), top: (i, { top: l }) => parseFloat(l), left: (i, { left: l }) => parseFloat(l), bottom: ({ y: i }, { top: l }) => parseFloat(l) + (i.max - i.min), right: ({ x: i }, { left: l }) => parseFloat(l) + (i.max - i.min), x: (i, { transform: l }) => kr(l, "x"), y: (i, { transform: l }) => kr(l, "y") }; ra.translateX = ra.x; ra.translateY = ra.y; const ca = new Set; let Pr = !1, Fr = !1, Wr = !1; function _y() { if (Fr) { const i = Array.from(ca).filter(o => o.needsMeasurement), l = new Set(i.map(o => o.element)), u = new Map; l.forEach(o => { const c = xS(o); c.length && (u.set(o, c), o.render()) }), i.forEach(o => o.measureInitialState()), l.forEach(o => { o.render(); const c = u.get(o); c && c.forEach(([d, h]) => { o.getValue(d)?.set(h) }) }), i.forEach(o => o.measureEndState()), i.forEach(o => { o.suspendedScrollY !== void 0 && window.scrollTo(0, o.suspendedScrollY) }) } Fr = !1, Pr = !1, ca.forEach(i => i.complete(Wr)), ca.clear() } function By() { ca.forEach(i => { i.readKeyframes(), i.needsMeasurement && (Fr = !0) }) } function ES() { Wr = !0, By(), _y(), Wr = !1 } class Oc { constructor(l, u, o, c, d, h = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...l], this.onComplete = u, this.name = o, this.motionValue = c, this.element = d, this.isAsync = h } scheduleResolve() { this.state = "scheduled", this.isAsync ? (ca.add(this), Pr || (Pr = !0, Dt.read(By), Dt.resolveKeyframes(_y))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: l, name: u, element: o, motionValue: c } = this; if (l[0] === null) { const d = c?.get(), h = l[l.length - 1]; if (d !== void 0) l[0] = d; else if (o && u) { const g = o.readValue(u, h); g != null && (l[0] = g) } l[0] === void 0 && (l[0] = h), c && d === void 0 && c.set(l[0]) } yS(l) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(l = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, l), ca.delete(this) } cancel() { this.state === "scheduled" && (ca.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const MS = i => i.startsWith("--"); function DS(i, l, u) { MS(l) ? i.style.setProperty(l, u) : i.style[l] = u } const RS = pc(() => window.ScrollTimeline !== void 0), OS = {}; function CS(i, l) { const u = pc(i); return () => OS[l] ?? u() } const jy = CS(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), ol = ([i, l, u, o]) => `cubic-bezier(${i}, ${l}, ${u}, ${o})`, np = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ol([0, .65, .55, 1]), circOut: ol([.55, 0, 1, .45]), backIn: ol([.31, .01, .66, -.59]), backOut: ol([.33, 1.53, .69, .99]) }; function wy(i, l) { if (i) return typeof i == "function" ? jy() ? zy(i, l) : "ease-out" : Ty(i) ? ol(i) : Array.isArray(i) ? i.map(u => wy(u, l) || np.easeOut) : np[i] } function VS(i, l, u, { delay: o = 0, duration: c = 300, repeat: d = 0, repeatType: h = "loop", ease: g = "easeOut", times: y } = {}, m = void 0) { const v = { [l]: u }; y && (v.offset = y); const b = wy(g, c); Array.isArray(b) && (v.easing = b); const x = { delay: o, duration: c, easing: Array.isArray(b) ? "linear" : b, fill: "both", iterations: d + 1, direction: h === "reverse" ? "alternate" : "normal" }; return m && (x.pseudoElement = m), i.animate(v, x) } function Ly(i) { return typeof i == "function" && "applyToOptions" in i } function zS({ type: i, ...l }) { return Ly(i) && jy() ? i.applyToOptions(l) : (l.duration ?? (l.duration = 300), l.ease ?? (l.ease = "easeOut"), l) } class NS extends Dc { constructor(l) { if (super(), this.finishedTime = null, this.isStopped = !1, !l) return; const { element: u, name: o, keyframes: c, pseudoElement: d, allowFlatten: h = !1, finalKeyframe: g, onComplete: y } = l; this.isPseudoElement = !!d, this.allowFlatten = h, this.options = l, mc(typeof l.type != "string"); const m = zS(l); this.animation = VS(u, o, c, m, d), m.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !d) { const v = Mc(c, this.options, g, this.speed); this.updateMotionValue ? this.updateMotionValue(v) : DS(u, o, v), this.animation.cancel() } y?.(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: l } = this; l === "idle" || l === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { this.isPseudoElement || this.animation.commitStyles?.() } get duration() { const l = this.animation.effect?.getComputedTiming?.().duration || 0; return Ze(Number(l)) } get time() { return Ze(Number(this.animation.currentTime) || 0) } set time(l) { this.finishedTime = null, this.animation.currentTime = Xe(l) } get speed() { return this.animation.playbackRate } set speed(l) { l < 0 && (this.finishedTime = null), this.animation.playbackRate = l } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(l) { this.animation.startTime = l } attachTimeline({ timeline: l, observe: u }) { return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, l && RS() ? (this.animation.timeline = l, ze) : u(this) } } const Hy = { anticipate: gy, backInOut: yy, circInOut: Sy }; function US(i) { return i in Hy } function _S(i) { typeof i.ease == "string" && US(i.ease) && (i.ease = Hy[i.ease]) } const ap = 10; class BS extends NS { constructor(l) { _S(l), Uy(l), super(l), l.startTime && (this.startTime = l.startTime), this.options = l } updateMotionValue(l) { const { motionValue: u, onUpdate: o, onComplete: c, element: d, ...h } = this.options; if (!u) return; if (l !== void 0) { u.set(l); return } const g = new Rc({ ...h, autoplay: !1 }), y = Xe(this.finishedTime ?? this.time); u.setWithVelocity(g.sample(y - ap).value, g.sample(y).value, ap), g.stop() } } const ip = (i, l) => l === "zIndex" ? !1 : !!(typeof i == "number" || Array.isArray(i) || typeof i == "string" && (Hn.test(i) || i === "0") && !i.startsWith("url(")); function jS(i) { const l = i[0]; if (i.length === 1) return !0; for (let u = 0; u < i.length; u++)if (i[u] !== l) return !0 } function wS(i, l, u, o) { const c = i[0]; if (c === null) return !1; if (l === "display" || l === "visibility") return !0; const d = i[i.length - 1], h = ip(c, l), g = ip(d, l); return !h || !g ? !1 : jS(i) || (u === "spring" || Ly(u)) && o } function $r(i) { i.duration = 0, i.type } const LS = new Set(["opacity", "clipPath", "filter", "transform"]), HS = pc(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function qS(i) { const { motionValue: l, name: u, repeatDelay: o, repeatType: c, damping: d, type: h } = i; if (!(l?.owner?.current instanceof HTMLElement)) return !1; const { onUpdate: y, transformTemplate: m } = l.owner.getProps(); return HS() && u && LS.has(u) && (u !== "transform" || !m) && !y && !o && c !== "mirror" && d !== 0 && h !== "inertia" } const YS = 40; class GS extends Dc { constructor({ autoplay: l = !0, delay: u = 0, type: o = "keyframes", repeat: c = 0, repeatDelay: d = 0, repeatType: h = "loop", keyframes: g, name: y, motionValue: m, element: v, ...b }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = re.now(); const x = { autoplay: l, delay: u, type: o, repeat: c, repeatDelay: d, repeatType: h, name: y, motionValue: m, element: v, ...b }, V = v?.KeyframeResolver || Oc; this.keyframeResolver = new V(g, (w, U, B) => this.onKeyframesResolved(w, U, x, !B), y, m, v), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(l, u, o, c) { this.keyframeResolver = void 0; const { name: d, type: h, velocity: g, delay: y, isHandoff: m, onUpdate: v } = o; this.resolvedAt = re.now(), wS(l, d, h, g) || ((fn.instantAnimations || !y) && v?.(Mc(l, o, u)), l[0] = l[l.length - 1], $r(o), o.repeat = 0); const x = { startTime: c ? this.resolvedAt ? this.resolvedAt - this.createdAt > YS ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: u, ...o, keyframes: l }, V = !m && qS(x) ? new BS({ ...x, element: x.motionValue.owner.current }) : new Rc(x); V.finished.then(() => this.notifyFinished()).catch(ze), this.pendingTimeline && (this.stopTimeline = V.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = V } get finished() { return this._animation ? this.animation.finished : this._finished } then(l, u) { return this.finished.finally(l).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), ES()), this._animation } get duration() { return this.animation.duration } get time() { return this.animation.time } set time(l) { this.animation.time = l } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(l) { this.animation.speed = l } get startTime() { return this.animation.startTime } attachTimeline(l) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(l) : this.pendingTimeline = l, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } const XS = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function ZS(i) { const l = XS.exec(i); if (!l) return [,]; const [, u, o, c] = l; return [`--${u ?? o}`, c] } function qy(i, l, u = 1) { const [o, c] = ZS(i); if (!o) return; const d = window.getComputedStyle(l).getPropertyValue(o); if (d) { const h = d.trim(); return oy(h) ? parseFloat(h) : h } return bc(c) ? qy(c, l, u + 1) : c } function Cc(i, l) { return i?.[l] ?? i?.default ?? i } const Yy = new Set(["width", "height", "top", "left", "right", "bottom", ...si]), KS = { test: i => i === "auto", parse: i => i }, Gy = i => l => l.test(i), Xy = [li, it, Ke, wn, j1, B1, KS], lp = i => Xy.find(Gy(i)); function QS(i) { return typeof i == "number" ? i === 0 : i !== null ? i === "none" || i === "0" || cy(i) : !0 } const JS = new Set(["brightness", "contrast", "saturate", "opacity"]); function kS(i) { const [l, u] = i.slice(0, -1).split("("); if (l === "drop-shadow") return i; const [o] = u.match(Tc) || []; if (!o) return i; const c = u.replace(o, ""); let d = JS.has(l) ? 1 : 0; return o !== u && (d *= 100), l + "(" + d + c + ")" } const PS = /\b([a-z-]*)\(.*?\)/gu, Ir = { ...Hn, getAnimatableNone: i => { const l = i.match(PS); return l ? l.map(kS).join(" ") : i } }, sp = { ...li, transform: Math.round }, FS = { rotate: wn, rotateX: wn, rotateY: wn, rotateZ: wn, scale: qs, scaleX: qs, scaleY: qs, scaleZ: qs, skew: wn, skewX: wn, skewY: wn, distance: it, translateX: it, translateY: it, translateZ: it, x: it, y: it, z: it, perspective: it, transformPerspective: it, opacity: pl, originX: Jm, originY: Jm, originZ: it }, Vc = { borderWidth: it, borderTopWidth: it, borderRightWidth: it, borderBottomWidth: it, borderLeftWidth: it, borderRadius: it, radius: it, borderTopLeftRadius: it, borderTopRightRadius: it, borderBottomRightRadius: it, borderBottomLeftRadius: it, width: it, maxWidth: it, height: it, maxHeight: it, top: it, right: it, bottom: it, left: it, padding: it, paddingTop: it, paddingRight: it, paddingBottom: it, paddingLeft: it, margin: it, marginTop: it, marginRight: it, marginBottom: it, marginLeft: it, backgroundPositionX: it, backgroundPositionY: it, ...FS, zIndex: sp, fillOpacity: pl, strokeOpacity: pl, numOctaves: sp }, WS = { ...Vc, color: Lt, backgroundColor: Lt, outlineColor: Lt, fill: Lt, stroke: Lt, borderColor: Lt, borderTopColor: Lt, borderRightColor: Lt, borderBottomColor: Lt, borderLeftColor: Lt, filter: Ir, WebkitFilter: Ir }, Zy = i => WS[i]; function Ky(i, l) { let u = Zy(i); return u !== Ir && (u = Hn), u.getAnimatableNone ? u.getAnimatableNone(l) : void 0 } const $S = new Set(["auto", "none", "0"]); function IS(i, l, u) { let o = 0, c; for (; o < i.length && !c;) { const d = i[o]; typeof d == "string" && !$S.has(d) && yl(d).values.length && (c = i[o]), o++ } if (c && u) for (const d of l) i[d] = Ky(u, c) } class tb extends Oc { constructor(l, u, o, c, d) { super(l, u, o, c, d, !0) } readKeyframes() { const { unresolvedKeyframes: l, element: u, name: o } = this; if (!u || !u.current) return; super.readKeyframes(); for (let y = 0; y < l.length; y++) { let m = l[y]; if (typeof m == "string" && (m = m.trim(), bc(m))) { const v = qy(m, u.current); v !== void 0 && (l[y] = v), y === l.length - 1 && (this.finalKeyframe = m) } } if (this.resolveNoneKeyframes(), !Yy.has(o) || l.length !== 2) return; const [c, d] = l, h = lp(c), g = lp(d); if (h !== g) if (ep(h) && ep(g)) for (let y = 0; y < l.length; y++) { const m = l[y]; typeof m == "string" && (l[y] = parseFloat(m)) } else ra[o] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: l, name: u } = this, o = []; for (let c = 0; c < l.length; c++)(l[c] === null || QS(l[c])) && o.push(c); o.length && IS(l, o, u) } measureInitialState() { const { element: l, unresolvedKeyframes: u, name: o } = this; if (!l || !l.current) return; o === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ra[o](l.measureViewportBox(), window.getComputedStyle(l.current)), u[0] = this.measuredOrigin; const c = u[u.length - 1]; c !== void 0 && l.getValue(o, c).jump(c, !1) } measureEndState() { const { element: l, name: u, unresolvedKeyframes: o } = this; if (!l || !l.current) return; const c = l.getValue(u); c && c.jump(this.measuredOrigin, !1); const d = o.length - 1, h = o[d]; o[d] = ra[u](l.measureViewportBox(), window.getComputedStyle(l.current)), h !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = h), this.removedTransforms?.length && this.removedTransforms.forEach(([g, y]) => { l.getValue(g).set(y) }), this.resolveNoneKeyframes() } } function eb(i, l, u) { if (i instanceof EventTarget) return [i]; if (typeof i == "string") { let o = document; const c = u?.[i] ?? o.querySelectorAll(i); return c ? Array.from(c) : [] } return Array.from(i) } const Qy = (i, l) => l && typeof i == "number" ? l.transform(i) : i; function Jy(i) { return ry(i) && "offsetHeight" in i } const up = 30, nb = i => !isNaN(parseFloat(i)); class ab { constructor(l, u = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = o => { const c = re.now(); if (this.updatedAt !== c && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(o), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (const d of this.dependents) d.dirty() }, this.hasAnimated = !1, this.setCurrent(l), this.owner = u.owner } setCurrent(l) { this.current = l, this.updatedAt = re.now(), this.canTrackVelocity === null && l !== void 0 && (this.canTrackVelocity = nb(this.current)) } setPrevFrameValue(l = this.current) { this.prevFrameValue = l, this.prevUpdatedAt = this.updatedAt } onChange(l) { return this.on("change", l) } on(l, u) { this.events[l] || (this.events[l] = new yc); const o = this.events[l].add(u); return l === "change" ? () => { o(), Dt.read(() => { this.events.change.getSize() || this.stop() }) } : o } clearListeners() { for (const l in this.events) this.events[l].clear() } attach(l, u) { this.passiveEffect = l, this.stopPassiveEffect = u } set(l) { this.passiveEffect ? this.passiveEffect(l, this.updateAndNotify) : this.updateAndNotify(l) } setWithVelocity(l, u, o) { this.set(u), this.prev = void 0, this.prevFrameValue = l, this.prevUpdatedAt = this.updatedAt - o } jump(l, u = !0) { this.updateAndNotify(l), this.prev = l, this.prevUpdatedAt = this.prevFrameValue = void 0, u && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(l) { this.dependents || (this.dependents = new Set), this.dependents.add(l) } removeDependent(l) { this.dependents && this.dependents.delete(l) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const l = re.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || l - this.updatedAt > up) return 0; const u = Math.min(this.updatedAt - this.prevUpdatedAt, up); return fy(parseFloat(this.current) - parseFloat(this.prevFrameValue), u) } start(l) { return this.stop(), new Promise(u => { this.hasAnimated = !0, this.animation = l(u), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function ai(i, l) { return new ab(i, l) } const { schedule: zc } = Ay(queueMicrotask, !1), Be = { x: !1, y: !1 }; function ky() { return Be.x || Be.y } function ib(i) { return i === "x" || i === "y" ? Be[i] ? null : (Be[i] = !0, () => { Be[i] = !1 }) : Be.x || Be.y ? null : (Be.x = Be.y = !0, () => { Be.x = Be.y = !1 }) } function Py(i, l) { const u = eb(i), o = new AbortController, c = { passive: !0, ...l, signal: o.signal }; return [u, c, () => o.abort()] } function op(i) { return !(i.pointerType === "touch" || ky()) } function lb(i, l, u = {}) { const [o, c, d] = Py(i, u), h = g => { if (!op(g)) return; const { target: y } = g, m = l(y, g); if (typeof m != "function" || !y) return; const v = b => { op(b) && (m(b), y.removeEventListener("pointerleave", v)) }; y.addEventListener("pointerleave", v, c) }; return o.forEach(g => { g.addEventListener("pointerenter", h, c) }), d } const Fy = (i, l) => l ? i === l ? !0 : Fy(i, l.parentElement) : !1, Nc = i => i.pointerType === "mouse" ? typeof i.button != "number" || i.button <= 0 : i.isPrimary !== !1, sb = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function ub(i) { return sb.has(i.tagName) || i.tabIndex !== -1 } const Zs = new WeakSet; function rp(i) { return l => { l.key === "Enter" && i(l) } } function zr(i, l) { i.dispatchEvent(new PointerEvent("pointer" + l, { isPrimary: !0, bubbles: !0 })) } const ob = (i, l) => { const u = i.currentTarget; if (!u) return; const o = rp(() => { if (Zs.has(u)) return; zr(u, "down"); const c = rp(() => { zr(u, "up") }), d = () => zr(u, "cancel"); u.addEventListener("keyup", c, l), u.addEventListener("blur", d, l) }); u.addEventListener("keydown", o, l), u.addEventListener("blur", () => u.removeEventListener("keydown", o), l) }; function cp(i) { return Nc(i) && !ky() } function rb(i, l, u = {}) { const [o, c, d] = Py(i, u), h = g => { const y = g.currentTarget; if (!cp(g)) return; Zs.add(y); const m = l(y, g), v = (V, w) => { window.removeEventListener("pointerup", b), window.removeEventListener("pointercancel", x), Zs.has(y) && Zs.delete(y), cp(V) && typeof m == "function" && m(V, { success: w }) }, b = V => { v(V, y === window || y === document || u.useGlobalTarget || Fy(y, V.target)) }, x = V => { v(V, !1) }; window.addEventListener("pointerup", b, c), window.addEventListener("pointercancel", x, c) }; return o.forEach(g => { (u.useGlobalTarget ? window : g).addEventListener("pointerdown", h, c), Jy(g) && (g.addEventListener("focus", m => ob(m, c)), !ub(g) && !g.hasAttribute("tabindex") && (g.tabIndex = 0)) }), d } function Wy(i) { return ry(i) && "ownerSVGElement" in i } function cb(i) { return Wy(i) && i.tagName === "svg" } const ee = i => !!(i && i.getVelocity), fb = [...Xy, Lt, Hn], hb = i => fb.find(Gy(i)), Uc = X.createContext({ transformPagePoint: i => i, isStatic: !1, reducedMotion: "never" }); function fp(i, l) { if (typeof i == "function") return i(l); i != null && (i.current = l) } function db(...i) { return l => { let u = !1; const o = i.map(c => { const d = fp(c, l); return !u && typeof d == "function" && (u = !0), d }); if (u) return () => { for (let c = 0; c < o.length; c++) { const d = o[c]; typeof d == "function" ? d() : fp(i[c], null) } } } } function mb(...i) { return X.useCallback(db(...i), i) } class pb extends X.Component { getSnapshotBeforeUpdate(l) { const u = this.props.childRef.current; if (u && l.isPresent && !this.props.isPresent) { const o = u.offsetParent, c = Jy(o) && o.offsetWidth || 0, d = this.props.sizeRef.current; d.height = u.offsetHeight || 0, d.width = u.offsetWidth || 0, d.top = u.offsetTop, d.left = u.offsetLeft, d.right = c - d.width - d.left } return null } componentDidUpdate() { } render() { return this.props.children } } function yb({ children: i, isPresent: l, anchorX: u, root: o }) {
  const c = X.useId(), d = X.useRef(null), h = X.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: g } = X.useContext(Uc), y = mb(d, i?.ref); return X.useInsertionEffect(() => {
    const { width: m, height: v, top: b, left: x, right: V } = h.current; if (l || !d.current || !m || !v) return; const w = u === "left" ? `left: ${x}` : `right: ${V}`; d.current.dataset.motionPopId = c; const U = document.createElement("style"); g && (U.nonce = g); const B = o ?? document.head; return B.appendChild(U), U.sheet && U.sheet.insertRule(`
          [data-motion-pop-id="${c}"] {
            position: absolute !important;
            width: ${m}px !important;
            height: ${v}px !important;
            ${w}px !important;
            top: ${b}px !important;
          }
        `), () => { B.contains(U) && B.removeChild(U) }
  }, [l]), k.jsx(pb, { isPresent: l, childRef: d, sizeRef: h, children: X.cloneElement(i, { ref: y }) })
} const gb = ({ children: i, initial: l, isPresent: u, onExitComplete: o, custom: c, presenceAffectsLayout: d, mode: h, anchorX: g, root: y }) => { const m = cc(vb), v = X.useId(); let b = !0, x = X.useMemo(() => (b = !1, { id: v, initial: l, isPresent: u, custom: c, onExitComplete: V => { m.set(V, !0); for (const w of m.values()) if (!w) return; o && o() }, register: V => (m.set(V, !1), () => m.delete(V)) }), [u, m, o]); return d && b && (x = { ...x }), X.useMemo(() => { m.forEach((V, w) => m.set(w, !1)) }, [u]), X.useEffect(() => { !u && !m.size && o && o() }, [u]), h === "popLayout" && (i = k.jsx(yb, { isPresent: u, anchorX: g, root: y, children: i })), k.jsx(Is.Provider, { value: x, children: i }) }; function vb() { return new Map } function $y(i = !0) { const l = X.useContext(Is); if (l === null) return [!0, null]; const { isPresent: u, onExitComplete: o, register: c } = l, d = X.useId(); X.useEffect(() => { if (i) return c(d) }, [i]); const h = X.useCallback(() => i && o && o(d), [d, o, i]); return !u && o ? [!1, h] : [!0] } const Ys = i => i.key || ""; function hp(i) { const l = []; return X.Children.forEach(i, u => { X.isValidElement(u) && l.push(u) }), l } const dp = ({ children: i, custom: l, initial: u = !0, onExitComplete: o, presenceAffectsLayout: c = !0, mode: d = "sync", propagate: h = !1, anchorX: g = "left", root: y }) => { const [m, v] = $y(h), b = X.useMemo(() => hp(i), [i]), x = h && !m ? [] : b.map(Ys), V = X.useRef(!0), w = X.useRef(b), U = cc(() => new Map), [B, q] = X.useState(b), [Z, Y] = X.useState(b); uy(() => { V.current = !1, w.current = b; for (let W = 0; W < Z.length; W++) { const nt = Ys(Z[W]); x.includes(nt) ? U.delete(nt) : U.get(nt) !== !0 && U.set(nt, !1) } }, [Z, x.length, x.join("-")]); const et = []; if (b !== B) { let W = [...b]; for (let nt = 0; nt < Z.length; nt++) { const P = Z[nt], yt = Ys(P); x.includes(yt) || (W.splice(nt, 0, P), et.push(P)) } return d === "wait" && et.length && (W = et), Y(hp(W)), q(b), null } const { forceRender: H } = X.useContext(rc); return k.jsx(k.Fragment, { children: Z.map(W => { const nt = Ys(W), P = h && !m ? !1 : b === Z || x.includes(nt), yt = () => { if (U.has(nt)) U.set(nt, !0); else return; let Ct = !0; U.forEach(Xt => { Xt || (Ct = !1) }), Ct && (H?.(), Y(w.current), h && v?.(), o && o()) }; return k.jsx(gb, { isPresent: P, initial: !V.current || u ? void 0 : !1, custom: l, presenceAffectsLayout: c, mode: d, root: y, onExitComplete: P ? void 0 : yt, anchorX: g, children: W }, nt) }) }) }, Iy = X.createContext({ strict: !1 }), mp = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ii = {}; for (const i in mp) ii[i] = { isEnabled: l => mp[i].some(u => !!l[u]) }; function Sb(i) { for (const l in i) ii[l] = { ...ii[l], ...i[l] } } const bb = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Ws(i) { return i.startsWith("while") || i.startsWith("drag") && i !== "draggable" || i.startsWith("layout") || i.startsWith("onTap") || i.startsWith("onPan") || i.startsWith("onLayout") || bb.has(i) } let tg = i => !Ws(i); function Tb(i) { typeof i == "function" && (tg = l => l.startsWith("on") ? !Ws(l) : i(l)) } try { Tb(require("@emotion/is-prop-valid").default) } catch { } function Ab(i, l, u) { const o = {}; for (const c in i) c === "values" && typeof i.values == "object" || (tg(c) || u === !0 && Ws(c) || !l && !Ws(c) || i.draggable && c.startsWith("onDrag")) && (o[c] = i[c]); return o } const tu = X.createContext({}); function eu(i) { return i !== null && typeof i == "object" && typeof i.start == "function" } function gl(i) { return typeof i == "string" || Array.isArray(i) } const _c = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Bc = ["initial", ..._c]; function nu(i) { return eu(i.animate) || Bc.some(l => gl(i[l])) } function eg(i) { return !!(nu(i) || i.variants) } function xb(i, l) { if (nu(i)) { const { initial: u, animate: o } = i; return { initial: u === !1 || gl(u) ? u : void 0, animate: gl(o) ? o : void 0 } } return i.inherit !== !1 ? l : {} } function Eb(i) { const { initial: l, animate: u } = xb(i, X.useContext(tu)); return X.useMemo(() => ({ initial: l, animate: u }), [pp(l), pp(u)]) } function pp(i) { return Array.isArray(i) ? i.join(" ") : i } const vl = {}; function Mb(i) { for (const l in i) vl[l] = i[l], Sc(l) && (vl[l].isCSSVariable = !0) } function ng(i, { layout: l, layoutId: u }) { return ui.has(i) || i.startsWith("origin") || (l || u !== void 0) && (!!vl[i] || i === "opacity") } const Db = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, Rb = si.length; function Ob(i, l, u) { let o = "", c = !0; for (let d = 0; d < Rb; d++) { const h = si[d], g = i[h]; if (g === void 0) continue; let y = !0; if (typeof g == "number" ? y = g === (h.startsWith("scale") ? 1 : 0) : y = parseFloat(g) === 0, !y || u) { const m = Qy(g, Vc[h]); if (!y) { c = !1; const v = Db[h] || h; o += `${v}(${m}) ` } u && (l[h] = m) } } return o = o.trim(), u ? o = u(l, c ? "" : o) : c && (o = "none"), o } function jc(i, l, u) { const { style: o, vars: c, transformOrigin: d } = i; let h = !1, g = !1; for (const y in l) { const m = l[y]; if (ui.has(y)) { h = !0; continue } else if (Sc(y)) { c[y] = m; continue } else { const v = Qy(m, Vc[y]); y.startsWith("origin") ? (g = !0, d[y] = v) : o[y] = v } } if (l.transform || (h || u ? o.transform = Ob(l, i.transform, u) : o.transform && (o.transform = "none")), g) { const { originX: y = "50%", originY: m = "50%", originZ: v = 0 } = d; o.transformOrigin = `${y} ${m} ${v}` } } const wc = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function ag(i, l, u) { for (const o in l) !ee(l[o]) && !ng(o, u) && (i[o] = l[o]) } function Cb({ transformTemplate: i }, l) { return X.useMemo(() => { const u = wc(); return jc(u, l, i), Object.assign({}, u.vars, u.style) }, [l]) } function Vb(i, l) { const u = i.style || {}, o = {}; return ag(o, u, i), Object.assign(o, Cb(i, l)), o } function zb(i, l) { const u = {}, o = Vb(i, l); return i.drag && i.dragListener !== !1 && (u.draggable = !1, o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = "none", o.touchAction = i.drag === !0 ? "none" : `pan-${i.drag === "x" ? "y" : "x"}`), i.tabIndex === void 0 && (i.onTap || i.onTapStart || i.whileTap) && (u.tabIndex = 0), u.style = o, u } const Nb = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, Ub = { offset: "strokeDashoffset", array: "strokeDasharray" }; function _b(i, l, u = 1, o = 0, c = !0) { i.pathLength = 1; const d = c ? Nb : Ub; i[d.offset] = it.transform(-o); const h = it.transform(l), g = it.transform(u); i[d.array] = `${h} ${g}` } function ig(i, { attrX: l, attrY: u, attrScale: o, pathLength: c, pathSpacing: d = 1, pathOffset: h = 0, ...g }, y, m, v) { if (jc(i, g, m), y) { i.style.viewBox && (i.attrs.viewBox = i.style.viewBox); return } i.attrs = i.style, i.style = {}; const { attrs: b, style: x } = i; b.transform && (x.transform = b.transform, delete b.transform), (x.transform || b.transformOrigin) && (x.transformOrigin = b.transformOrigin ?? "50% 50%", delete b.transformOrigin), x.transform && (x.transformBox = v?.transformBox ?? "fill-box", delete b.transformBox), l !== void 0 && (b.x = l), u !== void 0 && (b.y = u), o !== void 0 && (b.scale = o), c !== void 0 && _b(b, c, d, h, !1) } const lg = () => ({ ...wc(), attrs: {} }), sg = i => typeof i == "string" && i.toLowerCase() === "svg"; function Bb(i, l, u, o) { const c = X.useMemo(() => { const d = lg(); return ig(d, l, sg(o), i.transformTemplate, i.style), { ...d.attrs, style: { ...d.style } } }, [l]); if (i.style) { const d = {}; ag(d, i.style, i), c.style = { ...d, ...c.style } } return c } const jb = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Lc(i) { return typeof i != "string" || i.includes("-") ? !1 : !!(jb.indexOf(i) > -1 || /[A-Z]/u.test(i)) } function wb(i, l, u, { latestValues: o }, c, d = !1) { const g = (Lc(i) ? Bb : zb)(l, o, c, i), y = Ab(l, typeof i == "string", d), m = i !== X.Fragment ? { ...y, ...g, ref: u } : {}, { children: v } = l, b = X.useMemo(() => ee(v) ? v.get() : v, [v]); return X.createElement(i, { ...m, children: b }) } function yp(i) { const l = [{}, {}]; return i?.values.forEach((u, o) => { l[0][o] = u.get(), l[1][o] = u.getVelocity() }), l } function Hc(i, l, u, o) { if (typeof l == "function") { const [c, d] = yp(o); l = l(u !== void 0 ? u : i.custom, c, d) } if (typeof l == "string" && (l = i.variants && i.variants[l]), typeof l == "function") { const [c, d] = yp(o); l = l(u !== void 0 ? u : i.custom, c, d) } return l } function Ks(i) { return ee(i) ? i.get() : i } function Lb({ scrapeMotionValuesFromProps: i, createRenderState: l }, u, o, c) { return { latestValues: Hb(u, o, c, i), renderState: l() } } function Hb(i, l, u, o) { const c = {}, d = o(i, {}); for (const x in d) c[x] = Ks(d[x]); let { initial: h, animate: g } = i; const y = nu(i), m = eg(i); l && m && !y && i.inherit !== !1 && (h === void 0 && (h = l.initial), g === void 0 && (g = l.animate)); let v = u ? u.initial === !1 : !1; v = v || h === !1; const b = v ? g : h; if (b && typeof b != "boolean" && !eu(b)) { const x = Array.isArray(b) ? b : [b]; for (let V = 0; V < x.length; V++) { const w = Hc(i, x[V]); if (w) { const { transitionEnd: U, transition: B, ...q } = w; for (const Z in q) { let Y = q[Z]; if (Array.isArray(Y)) { const et = v ? Y.length - 1 : 0; Y = Y[et] } Y !== null && (c[Z] = Y) } for (const Z in U) c[Z] = U[Z] } } } return c } const ug = i => (l, u) => { const o = X.useContext(tu), c = X.useContext(Is), d = () => Lb(i, l, o, c); return u ? d() : cc(d) }; function qc(i, l, u) { const { style: o } = i, c = {}; for (const d in o) (ee(o[d]) || l.style && ee(l.style[d]) || ng(d, i) || u?.getValue(d)?.liveStyle !== void 0) && (c[d] = o[d]); return c } const qb = ug({ scrapeMotionValuesFromProps: qc, createRenderState: wc }); function og(i, l, u) { const o = qc(i, l, u); for (const c in i) if (ee(i[c]) || ee(l[c])) { const d = si.indexOf(c) !== -1 ? "attr" + c.charAt(0).toUpperCase() + c.substring(1) : c; o[d] = i[c] } return o } const Yb = ug({ scrapeMotionValuesFromProps: og, createRenderState: lg }), Gb = Symbol.for("motionComponentSymbol"); function $a(i) { return i && typeof i == "object" && Object.prototype.hasOwnProperty.call(i, "current") } function Xb(i, l, u) { return X.useCallback(o => { o && i.onMount && i.onMount(o), l && (o ? l.mount(o) : l.unmount()), u && (typeof u == "function" ? u(o) : $a(u) && (u.current = o)) }, [l]) } const Yc = i => i.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Zb = "framerAppearId", rg = "data-" + Yc(Zb), cg = X.createContext({}); function Kb(i, l, u, o, c) { const { visualElement: d } = X.useContext(tu), h = X.useContext(Iy), g = X.useContext(Is), y = X.useContext(Uc).reducedMotion, m = X.useRef(null); o = o || h.renderer, !m.current && o && (m.current = o(i, { visualState: l, parent: d, props: u, presenceContext: g, blockInitialAnimation: g ? g.initial === !1 : !1, reducedMotionConfig: y })); const v = m.current, b = X.useContext(cg); v && !v.projection && c && (v.type === "html" || v.type === "svg") && Qb(m.current, u, c, b); const x = X.useRef(!1); X.useInsertionEffect(() => { v && x.current && v.update(u, g) }); const V = u[rg], w = X.useRef(!!V && !window.MotionHandoffIsComplete?.(V) && window.MotionHasOptimisedAnimation?.(V)); return uy(() => { v && (x.current = !0, window.MotionIsMounted = !0, v.updateFeatures(), v.scheduleRenderMicrotask(), w.current && v.animationState && v.animationState.animateChanges()) }), X.useEffect(() => { v && (!w.current && v.animationState && v.animationState.animateChanges(), w.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(V) }), w.current = !1), v.enteringChildren = void 0) }), v } function Qb(i, l, u, o) { const { layoutId: c, layout: d, drag: h, dragConstraints: g, layoutScroll: y, layoutRoot: m, layoutCrossfade: v } = l; i.projection = new u(i.latestValues, l["data-framer-portal-id"] ? void 0 : fg(i.parent)), i.projection.setOptions({ layoutId: c, layout: d, alwaysMeasureLayout: !!h || g && $a(g), visualElement: i, animationType: typeof d == "string" ? d : "both", initialPromotionConfig: o, crossfade: v, layoutScroll: y, layoutRoot: m }) } function fg(i) { if (i) return i.options.allowProjection !== !1 ? i.projection : fg(i.parent) } function Nr(i, { forwardMotionProps: l = !1 } = {}, u, o) { u && Sb(u); const c = Lc(i) ? Yb : qb; function d(g, y) { let m; const v = { ...X.useContext(Uc), ...g, layoutId: Jb(g) }, { isStatic: b } = v, x = Eb(g), V = c(g, b); if (!b && fc) { kb(); const w = Pb(v); m = w.MeasureLayout, x.visualElement = Kb(i, V, v, o, w.ProjectionNode) } return k.jsxs(tu.Provider, { value: x, children: [m && x.visualElement ? k.jsx(m, { visualElement: x.visualElement, ...v }) : null, wb(i, g, Xb(V, x.visualElement, y), V, b, l)] }) } d.displayName = `motion.${typeof i == "string" ? i : `create(${i.displayName ?? i.name ?? ""})`}`; const h = X.forwardRef(d); return h[Gb] = i, h } function Jb({ layoutId: i }) { const l = X.useContext(rc).id; return l && i !== void 0 ? l + "-" + i : i } function kb(i, l) { X.useContext(Iy).strict } function Pb(i) { const { drag: l, layout: u } = ii; if (!l && !u) return {}; const o = { ...l, ...u }; return { MeasureLayout: l?.isEnabled(i) || u?.isEnabled(i) ? o.MeasureLayout : void 0, ProjectionNode: o.ProjectionNode } } function Fb(i, l) { if (typeof Proxy > "u") return Nr; const u = new Map, o = (d, h) => Nr(d, h, i, l), c = (d, h) => o(d, h); return new Proxy(c, { get: (d, h) => h === "create" ? o : (u.has(h) || u.set(h, Nr(h, void 0, i, l)), u.get(h)) }) } function hg({ top: i, left: l, right: u, bottom: o }) { return { x: { min: l, max: u }, y: { min: i, max: o } } } function Wb({ x: i, y: l }) { return { top: l.min, right: i.max, bottom: l.max, left: i.min } } function $b(i, l) { if (!l) return i; const u = l({ x: i.left, y: i.top }), o = l({ x: i.right, y: i.bottom }); return { top: u.y, left: u.x, bottom: o.y, right: o.x } } function Ur(i) { return i === void 0 || i === 1 } function tc({ scale: i, scaleX: l, scaleY: u }) { return !Ur(i) || !Ur(l) || !Ur(u) } function sa(i) { return tc(i) || dg(i) || i.z || i.rotate || i.rotateX || i.rotateY || i.skewX || i.skewY } function dg(i) { return gp(i.x) || gp(i.y) } function gp(i) { return i && i !== "0%" } function $s(i, l, u) { const o = i - u, c = l * o; return u + c } function vp(i, l, u, o, c) { return c !== void 0 && (i = $s(i, c, o)), $s(i, u, o) + l } function ec(i, l = 0, u = 1, o, c) { i.min = vp(i.min, l, u, o, c), i.max = vp(i.max, l, u, o, c) } function mg(i, { x: l, y: u }) { ec(i.x, l.translate, l.scale, l.originPoint), ec(i.y, u.translate, u.scale, u.originPoint) } const Sp = .999999999999, bp = 1.0000000000001; function Ib(i, l, u, o = !1) { const c = u.length; if (!c) return; l.x = l.y = 1; let d, h; for (let g = 0; g < c; g++) { d = u[g], h = d.projectionDelta; const { visualElement: y } = d.options; y && y.props.style && y.props.style.display === "contents" || (o && d.options.layoutScroll && d.scroll && d !== d.root && ti(i, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }), h && (l.x *= h.x.scale, l.y *= h.y.scale, mg(i, h)), o && sa(d.latestValues) && ti(i, d.latestValues)) } l.x < bp && l.x > Sp && (l.x = 1), l.y < bp && l.y > Sp && (l.y = 1) } function Ia(i, l) { i.min = i.min + l, i.max = i.max + l } function Tp(i, l, u, o, c = .5) { const d = Ot(i.min, i.max, c); ec(i, l, u, d, o) } function ti(i, l) { Tp(i.x, l.x, l.scaleX, l.scale, l.originX), Tp(i.y, l.y, l.scaleY, l.scale, l.originY) } function pg(i, l) { return hg($b(i.getBoundingClientRect(), l)) } function tT(i, l, u) { const o = pg(i, u), { scroll: c } = l; return c && (Ia(o.x, c.offset.x), Ia(o.y, c.offset.y)), o } const Ap = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), ei = () => ({ x: Ap(), y: Ap() }), xp = () => ({ min: 0, max: 0 }), Bt = () => ({ x: xp(), y: xp() }), nc = { current: null }, yg = { current: !1 }; function eT() { if (yg.current = !0, !!fc) if (window.matchMedia) { const i = window.matchMedia("(prefers-reduced-motion)"), l = () => nc.current = i.matches; i.addEventListener("change", l), l() } else nc.current = !1 } const nT = new WeakMap; function aT(i, l, u) { for (const o in l) { const c = l[o], d = u[o]; if (ee(c)) i.addValue(o, c); else if (ee(d)) i.addValue(o, ai(c, { owner: i })); else if (d !== c) if (i.hasValue(o)) { const h = i.getValue(o); h.liveStyle === !0 ? h.jump(c) : h.hasAnimated || h.set(c) } else { const h = i.getStaticValue(o); i.addValue(o, ai(h !== void 0 ? h : c, { owner: i })) } } for (const o in u) l[o] === void 0 && i.removeValue(o); return l } const Ep = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class iT { scrapeMotionValuesFromProps(l, u, o) { return {} } constructor({ parent: l, props: u, presenceContext: o, reducedMotionConfig: c, blockInitialAnimation: d, visualState: h }, g = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Oc, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const x = re.now(); this.renderScheduledAt < x && (this.renderScheduledAt = x, Dt.render(this.render, !1, !0)) }; const { latestValues: y, renderState: m } = h; this.latestValues = y, this.baseTarget = { ...y }, this.initialValues = u.initial ? { ...y } : {}, this.renderState = m, this.parent = l, this.props = u, this.presenceContext = o, this.depth = l ? l.depth + 1 : 0, this.reducedMotionConfig = c, this.options = g, this.blockInitialAnimation = !!d, this.isControllingVariants = nu(u), this.isVariantNode = eg(u), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(l && l.current); const { willChange: v, ...b } = this.scrapeMotionValuesFromProps(u, {}, this); for (const x in b) { const V = b[x]; y[x] !== void 0 && ee(V) && V.set(y[x]) } } mount(l) { this.current = l, nT.set(l, this), this.projection && !this.projection.instance && this.projection.mount(l), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((u, o) => this.bindToMotionValue(o, u)), yg.current || eT(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : nc.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), Ln(this.notifyUpdate), Ln(this.render), this.valueSubscriptions.forEach(l => l()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this); for (const l in this.events) this.events[l].clear(); for (const l in this.features) { const u = this.features[l]; u && (u.unmount(), u.isMounted = !1) } this.current = null } addChild(l) { this.children.add(l), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(l) } removeChild(l) { this.children.delete(l), this.enteringChildren && this.enteringChildren.delete(l) } bindToMotionValue(l, u) { this.valueSubscriptions.has(l) && this.valueSubscriptions.get(l)(); const o = ui.has(l); o && this.onBindTransform && this.onBindTransform(); const c = u.on("change", h => { this.latestValues[l] = h, this.props.onUpdate && Dt.preRender(this.notifyUpdate), o && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let d; window.MotionCheckAppearSync && (d = window.MotionCheckAppearSync(this, l, u)), this.valueSubscriptions.set(l, () => { c(), d && d(), u.owner && u.stop() }) } sortNodePosition(l) { return !this.current || !this.sortInstanceNodePosition || this.type !== l.type ? 0 : this.sortInstanceNodePosition(this.current, l.current) } updateFeatures() { let l = "animation"; for (l in ii) { const u = ii[l]; if (!u) continue; const { isEnabled: o, Feature: c } = u; if (!this.features[l] && c && o(this.props) && (this.features[l] = new c(this)), this.features[l]) { const d = this.features[l]; d.isMounted ? d.update() : (d.mount(), d.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Bt() } getStaticValue(l) { return this.latestValues[l] } setStaticValue(l, u) { this.latestValues[l] = u } update(l, u) { (l.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = l, this.prevPresenceContext = this.presenceContext, this.presenceContext = u; for (let o = 0; o < Ep.length; o++) { const c = Ep[o]; this.propEventSubscriptions[c] && (this.propEventSubscriptions[c](), delete this.propEventSubscriptions[c]); const d = "on" + c, h = l[d]; h && (this.propEventSubscriptions[c] = this.on(c, h)) } this.prevMotionValues = aT(this, this.scrapeMotionValuesFromProps(l, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(l) { return this.props.variants ? this.props.variants[l] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(l) { const u = this.getClosestVariantNode(); if (u) return u.variantChildren && u.variantChildren.add(l), () => u.variantChildren.delete(l) } addValue(l, u) { const o = this.values.get(l); u !== o && (o && this.removeValue(l), this.bindToMotionValue(l, u), this.values.set(l, u), this.latestValues[l] = u.get()) } removeValue(l) { this.values.delete(l); const u = this.valueSubscriptions.get(l); u && (u(), this.valueSubscriptions.delete(l)), delete this.latestValues[l], this.removeValueFromRenderState(l, this.renderState) } hasValue(l) { return this.values.has(l) } getValue(l, u) { if (this.props.values && this.props.values[l]) return this.props.values[l]; let o = this.values.get(l); return o === void 0 && u !== void 0 && (o = ai(u === null ? void 0 : u, { owner: this }), this.addValue(l, o)), o } readValue(l, u) { let o = this.latestValues[l] !== void 0 || !this.current ? this.latestValues[l] : this.getBaseTargetFromProps(this.props, l) ?? this.readValueFromInstance(this.current, l, this.options); return o != null && (typeof o == "string" && (oy(o) || cy(o)) ? o = parseFloat(o) : !hb(o) && Hn.test(u) && (o = Ky(l, u)), this.setBaseTarget(l, ee(o) ? o.get() : o)), ee(o) ? o.get() : o } setBaseTarget(l, u) { this.baseTarget[l] = u } getBaseTarget(l) { const { initial: u } = this.props; let o; if (typeof u == "string" || typeof u == "object") { const d = Hc(this.props, u, this.presenceContext?.custom); d && (o = d[l]) } if (u && o !== void 0) return o; const c = this.getBaseTargetFromProps(this.props, l); return c !== void 0 && !ee(c) ? c : this.initialValues[l] !== void 0 && o === void 0 ? void 0 : this.baseTarget[l] } on(l, u) { return this.events[l] || (this.events[l] = new yc), this.events[l].add(u) } notify(l, ...u) { this.events[l] && this.events[l].notify(...u) } scheduleRenderMicrotask() { zc.render(this.render) } } class gg extends iT { constructor() { super(...arguments), this.KeyframeResolver = tb } sortInstanceNodePosition(l, u) { return l.compareDocumentPosition(u) & 2 ? 1 : -1 } getBaseTargetFromProps(l, u) { return l.style ? l.style[u] : void 0 } removeValueFromRenderState(l, { vars: u, style: o }) { delete u[l], delete o[l] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: l } = this.props; ee(l) && (this.childSubscription = l.on("change", u => { this.current && (this.current.textContent = `${u}`) })) } } function vg(i, { style: l, vars: u }, o, c) { const d = i.style; let h; for (h in l) d[h] = l[h]; c?.applyProjectionStyles(d, o); for (h in u) d.setProperty(h, u[h]) } function lT(i) { return window.getComputedStyle(i) } class sT extends gg { constructor() { super(...arguments), this.type = "html", this.renderInstance = vg } readValueFromInstance(l, u) { if (ui.has(u)) return this.projection?.isProjecting ? Jr(u) : SS(l, u); { const o = lT(l), c = (Sc(u) ? o.getPropertyValue(u) : o[u]) || 0; return typeof c == "string" ? c.trim() : c } } measureInstanceViewportBox(l, { transformPagePoint: u }) { return pg(l, u) } build(l, u, o) { jc(l, u, o.transformTemplate) } scrapeMotionValuesFromProps(l, u, o) { return qc(l, u, o) } } const Sg = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function uT(i, l, u, o) { vg(i, l, void 0, o); for (const c in l.attrs) i.setAttribute(Sg.has(c) ? c : Yc(c), l.attrs[c]) } class oT extends gg { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Bt } getBaseTargetFromProps(l, u) { return l[u] } readValueFromInstance(l, u) { if (ui.has(u)) { const o = Zy(u); return o && o.default || 0 } return u = Sg.has(u) ? u : Yc(u), l.getAttribute(u) } scrapeMotionValuesFromProps(l, u, o) { return og(l, u, o) } build(l, u, o) { ig(l, u, this.isSVGTag, o.transformTemplate, o.style) } renderInstance(l, u, o, c) { uT(l, u, o, c) } mount(l) { this.isSVGTag = sg(l.tagName), super.mount(l) } } const rT = (i, l) => Lc(i) ? new oT(l) : new sT(l, { allowProjection: i !== X.Fragment }); function ni(i, l, u) { const o = i.getProps(); return Hc(o, l, u !== void 0 ? u : o.custom, i) } const ac = i => Array.isArray(i); function cT(i, l, u) { i.hasValue(l) ? i.getValue(l).set(u) : i.addValue(l, ai(u)) } function fT(i) { return ac(i) ? i[i.length - 1] || 0 : i } function hT(i, l) { const u = ni(i, l); let { transitionEnd: o = {}, transition: c = {}, ...d } = u || {}; d = { ...d, ...o }; for (const h in d) { const g = fT(d[h]); cT(i, h, g) } } function dT(i) { return !!(ee(i) && i.add) } function ic(i, l) { const u = i.getValue("willChange"); if (dT(u)) return u.add(l); if (!u && fn.WillChange) { const o = new fn.WillChange("auto"); i.addValue("willChange", o), o.add(l) } } function bg(i) { return i.props[rg] } const mT = i => i !== null; function pT(i, { repeat: l, repeatType: u = "loop" }, o) { const c = i.filter(mT), d = l && u !== "loop" && l % 2 === 1 ? 0 : c.length - 1; return c[d] } const yT = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, gT = i => ({ type: "spring", stiffness: 550, damping: i === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), vT = { type: "keyframes", duration: .8 }, ST = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, bT = (i, { keyframes: l }) => l.length > 2 ? vT : ui.has(i) ? i.startsWith("scale") ? gT(l[1]) : yT : ST; function TT({ when: i, delay: l, delayChildren: u, staggerChildren: o, staggerDirection: c, repeat: d, repeatType: h, repeatDelay: g, from: y, elapsed: m, ...v }) { return !!Object.keys(v).length } const Gc = (i, l, u, o = {}, c, d) => h => { const g = Cc(o, i) || {}, y = g.delay || o.delay || 0; let { elapsed: m = 0 } = o; m = m - Xe(y); const v = { keyframes: Array.isArray(u) ? u : [null, u], ease: "easeOut", velocity: l.getVelocity(), ...g, delay: -m, onUpdate: x => { l.set(x), g.onUpdate && g.onUpdate(x) }, onComplete: () => { h(), g.onComplete && g.onComplete() }, name: i, motionValue: l, element: d ? void 0 : c }; TT(g) || Object.assign(v, bT(i, v)), v.duration && (v.duration = Xe(v.duration)), v.repeatDelay && (v.repeatDelay = Xe(v.repeatDelay)), v.from !== void 0 && (v.keyframes[0] = v.from); let b = !1; if ((v.type === !1 || v.duration === 0 && !v.repeatDelay) && ($r(v), v.delay === 0 && (b = !0)), (fn.instantAnimations || fn.skipAnimations) && (b = !0, $r(v), v.delay = 0), v.allowFlatten = !g.type && !g.ease, b && !d && l.get() !== void 0) { const x = pT(v.keyframes, g); if (x !== void 0) { Dt.update(() => { v.onUpdate(x), v.onComplete() }); return } } return g.isSync ? new Rc(v) : new GS(v) }; function AT({ protectedKeys: i, needsAnimating: l }, u) { const o = i.hasOwnProperty(u) && l[u] !== !0; return l[u] = !1, o } function Tg(i, l, { delay: u = 0, transitionOverride: o, type: c } = {}) { let { transition: d = i.getDefaultTransition(), transitionEnd: h, ...g } = l; o && (d = o); const y = [], m = c && i.animationState && i.animationState.getState()[c]; for (const v in g) { const b = i.getValue(v, i.latestValues[v] ?? null), x = g[v]; if (x === void 0 || m && AT(m, v)) continue; const V = { delay: u, ...Cc(d || {}, v) }, w = b.get(); if (w !== void 0 && !b.isAnimating && !Array.isArray(x) && x === w && !V.velocity) continue; let U = !1; if (window.MotionHandoffAnimation) { const q = bg(i); if (q) { const Z = window.MotionHandoffAnimation(q, v, Dt); Z !== null && (V.startTime = Z, U = !0) } } ic(i, v), b.start(Gc(v, b, x, i.shouldReduceMotion && Yy.has(v) ? { type: !1 } : V, i, U)); const B = b.animation; B && y.push(B) } return h && Promise.all(y).then(() => { Dt.update(() => { h && hT(i, h) }) }), y } function Ag(i, l, u, o = 0, c = 1) { const d = Array.from(i).sort((m, v) => m.sortNodePosition(v)).indexOf(l), h = i.size, g = (h - 1) * o; return typeof u == "function" ? u(d, h) : c === 1 ? d * o : g - d * o } function lc(i, l, u = {}) { const o = ni(i, l, u.type === "exit" ? i.presenceContext?.custom : void 0); let { transition: c = i.getDefaultTransition() || {} } = o || {}; u.transitionOverride && (c = u.transitionOverride); const d = o ? () => Promise.all(Tg(i, o, u)) : () => Promise.resolve(), h = i.variantChildren && i.variantChildren.size ? (y = 0) => { const { delayChildren: m = 0, staggerChildren: v, staggerDirection: b } = c; return xT(i, l, y, m, v, b, u) } : () => Promise.resolve(), { when: g } = c; if (g) { const [y, m] = g === "beforeChildren" ? [d, h] : [h, d]; return y().then(() => m()) } else return Promise.all([d(), h(u.delay)]) } function xT(i, l, u = 0, o = 0, c = 0, d = 1, h) { const g = []; for (const y of i.variantChildren) y.notify("AnimationStart", l), g.push(lc(y, l, { ...h, delay: u + (typeof o == "function" ? 0 : o) + Ag(i.variantChildren, y, o, c, d) }).then(() => y.notify("AnimationComplete", l))); return Promise.all(g) } function ET(i, l, u = {}) { i.notify("AnimationStart", l); let o; if (Array.isArray(l)) { const c = l.map(d => lc(i, d, u)); o = Promise.all(c) } else if (typeof l == "string") o = lc(i, l, u); else { const c = typeof l == "function" ? ni(i, l, u.custom) : l; o = Promise.all(Tg(i, c, u)) } return o.then(() => { i.notify("AnimationComplete", l) }) } function xg(i, l) { if (!Array.isArray(l)) return !1; const u = l.length; if (u !== i.length) return !1; for (let o = 0; o < u; o++)if (l[o] !== i[o]) return !1; return !0 } const MT = Bc.length; function Eg(i) { if (!i) return; if (!i.isControllingVariants) { const u = i.parent ? Eg(i.parent) || {} : {}; return i.props.initial !== void 0 && (u.initial = i.props.initial), u } const l = {}; for (let u = 0; u < MT; u++) { const o = Bc[u], c = i.props[o]; (gl(c) || c === !1) && (l[o] = c) } return l } const DT = [..._c].reverse(), RT = _c.length; function OT(i) { return l => Promise.all(l.map(({ animation: u, options: o }) => ET(i, u, o))) } function CT(i) { let l = OT(i), u = Mp(), o = !0; const c = y => (m, v) => { const b = ni(i, v, y === "exit" ? i.presenceContext?.custom : void 0); if (b) { const { transition: x, transitionEnd: V, ...w } = b; m = { ...m, ...w, ...V } } return m }; function d(y) { l = y(i) } function h(y) { const { props: m } = i, v = Eg(i.parent) || {}, b = [], x = new Set; let V = {}, w = 1 / 0; for (let B = 0; B < RT; B++) { const q = DT[B], Z = u[q], Y = m[q] !== void 0 ? m[q] : v[q], et = gl(Y), H = q === y ? Z.isActive : null; H === !1 && (w = B); let W = Y === v[q] && Y !== m[q] && et; if (W && o && i.manuallyAnimateOnMount && (W = !1), Z.protectedKeys = { ...V }, !Z.isActive && H === null || !Y && !Z.prevProp || eu(Y) || typeof Y == "boolean") continue; const nt = VT(Z.prevProp, Y); let P = nt || q === y && Z.isActive && !W && et || B > w && et, yt = !1; const Ct = Array.isArray(Y) ? Y : [Y]; let Xt = Ct.reduce(c(q), {}); H === !1 && (Xt = {}); const { prevResolvedValues: Ht = {} } = Z, Qe = { ...Ht, ...Xt }, je = L => { P = !0, x.has(L) && (yt = !0, x.delete(L)), Z.needsAnimating[L] = !0; const J = i.getValue(L); J && (J.liveStyle = !1) }; for (const L in Qe) { const J = Xt[L], ft = Ht[L]; if (V.hasOwnProperty(L)) continue; let T = !1; ac(J) && ac(ft) ? T = !xg(J, ft) : T = J !== ft, T ? J != null ? je(L) : x.add(L) : J !== void 0 && x.has(L) ? je(L) : Z.protectedKeys[L] = !0 } Z.prevProp = Y, Z.prevResolvedValues = Xt, Z.isActive && (V = { ...V, ...Xt }), o && i.blockInitialAnimation && (P = !1); const qt = W && nt; P && (!qt || yt) && b.push(...Ct.map(L => { const J = { type: q }; if (typeof L == "string" && o && !qt && i.manuallyAnimateOnMount && i.parent) { const { parent: ft } = i, T = ni(ft, L); if (ft.enteringChildren && T) { const { delayChildren: j } = T.transition || {}; J.delay = Ag(ft.enteringChildren, i, j) } } return { animation: L, options: J } })) } if (x.size) { const B = {}; if (typeof m.initial != "boolean") { const q = ni(i, Array.isArray(m.initial) ? m.initial[0] : m.initial); q && q.transition && (B.transition = q.transition) } x.forEach(q => { const Z = i.getBaseTarget(q), Y = i.getValue(q); Y && (Y.liveStyle = !0), B[q] = Z ?? null }), b.push({ animation: B }) } let U = !!b.length; return o && (m.initial === !1 || m.initial === m.animate) && !i.manuallyAnimateOnMount && (U = !1), o = !1, U ? l(b) : Promise.resolve() } function g(y, m) { if (u[y].isActive === m) return Promise.resolve(); i.variantChildren?.forEach(b => b.animationState?.setActive(y, m)), u[y].isActive = m; const v = h(y); for (const b in u) u[b].protectedKeys = {}; return v } return { animateChanges: h, setActive: g, setAnimateFunction: d, getState: () => u, reset: () => { u = Mp(), o = !0 } } } function VT(i, l) { return typeof l == "string" ? l !== i : Array.isArray(l) ? !xg(l, i) : !1 } function la(i = !1) { return { isActive: i, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Mp() { return { animate: la(!0), whileInView: la(), whileHover: la(), whileTap: la(), whileDrag: la(), whileFocus: la(), exit: la() } } class qn { constructor(l) { this.isMounted = !1, this.node = l } update() { } } class zT extends qn { constructor(l) { super(l), l.animationState || (l.animationState = CT(l)) } updateAnimationControlsSubscription() { const { animate: l } = this.node.getProps(); eu(l) && (this.unmountControls = l.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: l } = this.node.getProps(), { animate: u } = this.node.prevProps || {}; l !== u && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } let NT = 0; class UT extends qn { constructor() { super(...arguments), this.id = NT++ } update() { if (!this.node.presenceContext) return; const { isPresent: l, onExitComplete: u } = this.node.presenceContext, { isPresent: o } = this.node.prevPresenceContext || {}; if (!this.node.animationState || l === o) return; const c = this.node.animationState.setActive("exit", !l); u && !l && c.then(() => { u(this.id) }) } mount() { const { register: l, onExitComplete: u } = this.node.presenceContext || {}; u && u(this.id), l && (this.unmount = l(this.id)) } unmount() { } } const _T = { animation: { Feature: zT }, exit: { Feature: UT } }; function Sl(i, l, u, o = { passive: !0 }) { return i.addEventListener(l, u, o), () => i.removeEventListener(l, u) } function xl(i) { return { point: { x: i.pageX, y: i.pageY } } } const BT = i => l => Nc(l) && i(l, xl(l)); function fl(i, l, u, o) { return Sl(i, l, BT(u), o) } const Mg = 1e-4, jT = 1 - Mg, wT = 1 + Mg, Dg = .01, LT = 0 - Dg, HT = 0 + Dg; function ae(i) { return i.max - i.min } function qT(i, l, u) { return Math.abs(i - l) <= u } function Dp(i, l, u, o = .5) { i.origin = o, i.originPoint = Ot(l.min, l.max, i.origin), i.scale = ae(u) / ae(l), i.translate = Ot(u.min, u.max, i.origin) - i.originPoint, (i.scale >= jT && i.scale <= wT || isNaN(i.scale)) && (i.scale = 1), (i.translate >= LT && i.translate <= HT || isNaN(i.translate)) && (i.translate = 0) } function hl(i, l, u, o) { Dp(i.x, l.x, u.x, o ? o.originX : void 0), Dp(i.y, l.y, u.y, o ? o.originY : void 0) } function Rp(i, l, u) { i.min = u.min + l.min, i.max = i.min + ae(l) } function YT(i, l, u) { Rp(i.x, l.x, u.x), Rp(i.y, l.y, u.y) } function Op(i, l, u) { i.min = l.min - u.min, i.max = i.min + ae(l) } function dl(i, l, u) { Op(i.x, l.x, u.x), Op(i.y, l.y, u.y) } function Ve(i) { return [i("x"), i("y")] } const Rg = ({ current: i }) => i ? i.ownerDocument.defaultView : null, Cp = (i, l) => Math.abs(i - l); function GT(i, l) { const u = Cp(i.x, l.x), o = Cp(i.y, l.y); return Math.sqrt(u ** 2 + o ** 2) } class Og { constructor(l, u, { transformPagePoint: o, contextWindow: c = window, dragSnapToOrigin: d = !1, distanceThreshold: h = 3 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const x = Br(this.lastMoveEventInfo, this.history), V = this.startEvent !== null, w = GT(x.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!V && !w) return; const { point: U } = x, { timestamp: B } = Wt; this.history.push({ ...U, timestamp: B }); const { onStart: q, onMove: Z } = this.handlers; V || (q && q(this.lastMoveEvent, x), this.startEvent = this.lastMoveEvent), Z && Z(this.lastMoveEvent, x) }, this.handlePointerMove = (x, V) => { this.lastMoveEvent = x, this.lastMoveEventInfo = _r(V, this.transformPagePoint), Dt.update(this.updatePoint, !0) }, this.handlePointerUp = (x, V) => { this.end(); const { onEnd: w, onSessionEnd: U, resumeAnimation: B } = this.handlers; if (this.dragSnapToOrigin && B && B(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const q = Br(x.type === "pointercancel" ? this.lastMoveEventInfo : _r(V, this.transformPagePoint), this.history); this.startEvent && w && w(x, q), U && U(x, q) }, !Nc(l)) return; this.dragSnapToOrigin = d, this.handlers = u, this.transformPagePoint = o, this.distanceThreshold = h, this.contextWindow = c || window; const g = xl(l), y = _r(g, this.transformPagePoint), { point: m } = y, { timestamp: v } = Wt; this.history = [{ ...m, timestamp: v }]; const { onSessionStart: b } = u; b && b(l, Br(y, this.history)), this.removeListeners = bl(fl(this.contextWindow, "pointermove", this.handlePointerMove), fl(this.contextWindow, "pointerup", this.handlePointerUp), fl(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(l) { this.handlers = l } end() { this.removeListeners && this.removeListeners(), Ln(this.updatePoint) } } function _r(i, l) { return l ? { point: l(i.point) } : i } function Vp(i, l) { return { x: i.x - l.x, y: i.y - l.y } } function Br({ point: i }, l) { return { point: i, delta: Vp(i, Cg(l)), offset: Vp(i, XT(l)), velocity: ZT(l, .1) } } function XT(i) { return i[0] } function Cg(i) { return i[i.length - 1] } function ZT(i, l) { if (i.length < 2) return { x: 0, y: 0 }; let u = i.length - 1, o = null; const c = Cg(i); for (; u >= 0 && (o = i[u], !(c.timestamp - o.timestamp > Xe(l)));)u--; if (!o) return { x: 0, y: 0 }; const d = Ze(c.timestamp - o.timestamp); if (d === 0) return { x: 0, y: 0 }; const h = { x: (c.x - o.x) / d, y: (c.y - o.y) / d }; return h.x === 1 / 0 && (h.x = 0), h.y === 1 / 0 && (h.y = 0), h } function KT(i, { min: l, max: u }, o) { return l !== void 0 && i < l ? i = o ? Ot(l, i, o.min) : Math.max(i, l) : u !== void 0 && i > u && (i = o ? Ot(u, i, o.max) : Math.min(i, u)), i } function zp(i, l, u) { return { min: l !== void 0 ? i.min + l : void 0, max: u !== void 0 ? i.max + u - (i.max - i.min) : void 0 } } function QT(i, { top: l, left: u, bottom: o, right: c }) { return { x: zp(i.x, u, c), y: zp(i.y, l, o) } } function Np(i, l) { let u = l.min - i.min, o = l.max - i.max; return l.max - l.min < i.max - i.min && ([u, o] = [o, u]), { min: u, max: o } } function JT(i, l) { return { x: Np(i.x, l.x), y: Np(i.y, l.y) } } function kT(i, l) { let u = .5; const o = ae(i), c = ae(l); return c > o ? u = ml(l.min, l.max - o, i.min) : o > c && (u = ml(i.min, i.max - c, l.min)), cn(0, 1, u) } function PT(i, l) { const u = {}; return l.min !== void 0 && (u.min = l.min - i.min), l.max !== void 0 && (u.max = l.max - i.min), u } const sc = .35; function FT(i = sc) { return i === !1 ? i = 0 : i === !0 && (i = sc), { x: Up(i, "left", "right"), y: Up(i, "top", "bottom") } } function Up(i, l, u) { return { min: _p(i, l), max: _p(i, u) } } function _p(i, l) { return typeof i == "number" ? i : i[l] || 0 } const WT = new WeakMap; class $T { constructor(l) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Bt(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = l } start(l, { snapToCursor: u = !1, distanceThreshold: o } = {}) { const { presenceContext: c } = this.visualElement; if (c && c.isPresent === !1) return; const d = b => { const { dragSnapToOrigin: x } = this.getProps(); x ? this.pauseAnimation() : this.stopAnimation(), u && this.snapToCursor(xl(b).point) }, h = (b, x) => { const { drag: V, dragPropagation: w, onDragStart: U } = this.getProps(); if (V && !w && (this.openDragLock && this.openDragLock(), this.openDragLock = ib(V), !this.openDragLock)) return; this.latestPointerEvent = b, this.latestPanInfo = x, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Ve(q => { let Z = this.getAxisMotionValue(q).get() || 0; if (Ke.test(Z)) { const { projection: Y } = this.visualElement; if (Y && Y.layout) { const et = Y.layout.layoutBox[q]; et && (Z = ae(et) * (parseFloat(Z) / 100)) } } this.originPoint[q] = Z }), U && Dt.postRender(() => U(b, x)), ic(this.visualElement, "transform"); const { animationState: B } = this.visualElement; B && B.setActive("whileDrag", !0) }, g = (b, x) => { this.latestPointerEvent = b, this.latestPanInfo = x; const { dragPropagation: V, dragDirectionLock: w, onDirectionLock: U, onDrag: B } = this.getProps(); if (!V && !this.openDragLock) return; const { offset: q } = x; if (w && this.currentDirection === null) { this.currentDirection = IT(q), this.currentDirection !== null && U && U(this.currentDirection); return } this.updateAxis("x", x.point, q), this.updateAxis("y", x.point, q), this.visualElement.render(), B && B(b, x) }, y = (b, x) => { this.latestPointerEvent = b, this.latestPanInfo = x, this.stop(b, x), this.latestPointerEvent = null, this.latestPanInfo = null }, m = () => Ve(b => this.getAnimationState(b) === "paused" && this.getAxisMotionValue(b).animation?.play()), { dragSnapToOrigin: v } = this.getProps(); this.panSession = new Og(l, { onSessionStart: d, onStart: h, onMove: g, onSessionEnd: y, resumeAnimation: m }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: v, distanceThreshold: o, contextWindow: Rg(this.visualElement) }) } stop(l, u) { const o = l || this.latestPointerEvent, c = u || this.latestPanInfo, d = this.isDragging; if (this.cancel(), !d || !c || !o) return; const { velocity: h } = c; this.startAnimation(h); const { onDragEnd: g } = this.getProps(); g && Dt.postRender(() => g(o, c)) } cancel() { this.isDragging = !1; const { projection: l, animationState: u } = this.visualElement; l && (l.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: o } = this.getProps(); !o && this.openDragLock && (this.openDragLock(), this.openDragLock = null), u && u.setActive("whileDrag", !1) } updateAxis(l, u, o) { const { drag: c } = this.getProps(); if (!o || !Gs(l, c, this.currentDirection)) return; const d = this.getAxisMotionValue(l); let h = this.originPoint[l] + o[l]; this.constraints && this.constraints[l] && (h = KT(h, this.constraints[l], this.elastic[l])), d.set(h) } resolveConstraints() { const { dragConstraints: l, dragElastic: u } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, c = this.constraints; l && $a(l) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : l && o ? this.constraints = QT(o.layoutBox, l) : this.constraints = !1, this.elastic = FT(u), c !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && Ve(d => { this.constraints !== !1 && this.getAxisMotionValue(d) && (this.constraints[d] = PT(o.layoutBox[d], this.constraints[d])) }) } resolveRefConstraints() { const { dragConstraints: l, onMeasureDragConstraints: u } = this.getProps(); if (!l || !$a(l)) return !1; const o = l.current, { projection: c } = this.visualElement; if (!c || !c.layout) return !1; const d = tT(o, c.root, this.visualElement.getTransformPagePoint()); let h = JT(c.layout.layoutBox, d); if (u) { const g = u(Wb(h)); this.hasMutatedConstraints = !!g, g && (h = hg(g)) } return h } startAnimation(l) { const { drag: u, dragMomentum: o, dragElastic: c, dragTransition: d, dragSnapToOrigin: h, onDragTransitionEnd: g } = this.getProps(), y = this.constraints || {}, m = Ve(v => { if (!Gs(v, u, this.currentDirection)) return; let b = y && y[v] || {}; h && (b = { min: 0, max: 0 }); const x = c ? 200 : 1e6, V = c ? 40 : 1e7, w = { type: "inertia", velocity: o ? l[v] : 0, bounceStiffness: x, bounceDamping: V, timeConstant: 750, restDelta: 1, restSpeed: 10, ...d, ...b }; return this.startAxisValueAnimation(v, w) }); return Promise.all(m).then(g) } startAxisValueAnimation(l, u) { const o = this.getAxisMotionValue(l); return ic(this.visualElement, l), o.start(Gc(l, o, 0, u, this.visualElement, !1)) } stopAnimation() { Ve(l => this.getAxisMotionValue(l).stop()) } pauseAnimation() { Ve(l => this.getAxisMotionValue(l).animation?.pause()) } getAnimationState(l) { return this.getAxisMotionValue(l).animation?.state } getAxisMotionValue(l) { const u = `_drag${l.toUpperCase()}`, o = this.visualElement.getProps(), c = o[u]; return c || this.visualElement.getValue(l, (o.initial ? o.initial[l] : void 0) || 0) } snapToCursor(l) { Ve(u => { const { drag: o } = this.getProps(); if (!Gs(u, o, this.currentDirection)) return; const { projection: c } = this.visualElement, d = this.getAxisMotionValue(u); if (c && c.layout) { const { min: h, max: g } = c.layout.layoutBox[u]; d.set(l[u] - Ot(h, g, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: l, dragConstraints: u } = this.getProps(), { projection: o } = this.visualElement; if (!$a(u) || !o || !this.constraints) return; this.stopAnimation(); const c = { x: 0, y: 0 }; Ve(h => { const g = this.getAxisMotionValue(h); if (g && this.constraints !== !1) { const y = g.get(); c[h] = kT({ min: y, max: y }, this.constraints[h]) } }); const { transformTemplate: d } = this.visualElement.getProps(); this.visualElement.current.style.transform = d ? d({}, "") : "none", o.root && o.root.updateScroll(), o.updateLayout(), this.resolveConstraints(), Ve(h => { if (!Gs(h, l, null)) return; const g = this.getAxisMotionValue(h), { min: y, max: m } = this.constraints[h]; g.set(Ot(y, m, c[h])) }) } addListeners() { if (!this.visualElement.current) return; WT.set(this.visualElement, this); const l = this.visualElement.current, u = fl(l, "pointerdown", y => { const { drag: m, dragListener: v = !0 } = this.getProps(); m && v && this.start(y) }), o = () => { const { dragConstraints: y } = this.getProps(); $a(y) && y.current && (this.constraints = this.resolveRefConstraints()) }, { projection: c } = this.visualElement, d = c.addEventListener("measure", o); c && !c.layout && (c.root && c.root.updateScroll(), c.updateLayout()), Dt.read(o); const h = Sl(window, "resize", () => this.scalePositionWithinConstraints()), g = c.addEventListener("didUpdate", (({ delta: y, hasLayoutChanged: m }) => { this.isDragging && m && (Ve(v => { const b = this.getAxisMotionValue(v); b && (this.originPoint[v] += y[v].translate, b.set(b.get() + y[v].translate)) }), this.visualElement.render()) })); return () => { h(), u(), d(), g && g() } } getProps() { const l = this.visualElement.getProps(), { drag: u = !1, dragDirectionLock: o = !1, dragPropagation: c = !1, dragConstraints: d = !1, dragElastic: h = sc, dragMomentum: g = !0 } = l; return { ...l, drag: u, dragDirectionLock: o, dragPropagation: c, dragConstraints: d, dragElastic: h, dragMomentum: g } } } function Gs(i, l, u) { return (l === !0 || l === i) && (u === null || u === i) } function IT(i, l = 10) { let u = null; return Math.abs(i.y) > l ? u = "y" : Math.abs(i.x) > l && (u = "x"), u } class tA extends qn { constructor(l) { super(l), this.removeGroupControls = ze, this.removeListeners = ze, this.controls = new $T(l) } mount() { const { dragControls: l } = this.node.getProps(); l && (this.removeGroupControls = l.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || ze } unmount() { this.removeGroupControls(), this.removeListeners() } } const Bp = i => (l, u) => { i && Dt.postRender(() => i(l, u)) }; class eA extends qn { constructor() { super(...arguments), this.removePointerDownListener = ze } onPointerDown(l) { this.session = new Og(l, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Rg(this.node) }) } createPanHandlers() { const { onPanSessionStart: l, onPanStart: u, onPan: o, onPanEnd: c } = this.node.getProps(); return { onSessionStart: Bp(l), onStart: Bp(u), onMove: o, onEnd: (d, h) => { delete this.session, c && Dt.postRender(() => c(d, h)) } } } mount() { this.removePointerDownListener = fl(this.node.current, "pointerdown", l => this.onPointerDown(l)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const Qs = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function jp(i, l) { return l.max === l.min ? 0 : i / (l.max - l.min) * 100 } const ul = { correct: (i, l) => { if (!l.target) return i; if (typeof i == "string") if (it.test(i)) i = parseFloat(i); else return i; const u = jp(i, l.target.x), o = jp(i, l.target.y); return `${u}% ${o}%` } }, nA = { correct: (i, { treeScale: l, projectionDelta: u }) => { const o = i, c = Hn.parse(i); if (c.length > 5) return o; const d = Hn.createTransformer(i), h = typeof c[0] != "number" ? 1 : 0, g = u.x.scale * l.x, y = u.y.scale * l.y; c[0 + h] /= g, c[1 + h] /= y; const m = Ot(g, y, .5); return typeof c[2 + h] == "number" && (c[2 + h] /= m), typeof c[3 + h] == "number" && (c[3 + h] /= m), d(c) } }; let jr = !1; class aA extends X.Component { componentDidMount() { const { visualElement: l, layoutGroup: u, switchLayoutGroup: o, layoutId: c } = this.props, { projection: d } = l; Mb(iA), d && (u.group && u.group.add(d), o && o.register && c && o.register(d), jr && d.root.didUpdate(), d.addEventListener("animationComplete", () => { this.safeToRemove() }), d.setOptions({ ...d.options, onExitComplete: () => this.safeToRemove() })), Qs.hasEverUpdated = !0 } getSnapshotBeforeUpdate(l) { const { layoutDependency: u, visualElement: o, drag: c, isPresent: d } = this.props, { projection: h } = o; return h && (h.isPresent = d, jr = !0, c || l.layoutDependency !== u || u === void 0 || l.isPresent !== d ? h.willUpdate() : this.safeToRemove(), l.isPresent !== d && (d ? h.promote() : h.relegate() || Dt.postRender(() => { const g = h.getStack(); (!g || !g.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: l } = this.props.visualElement; l && (l.root.didUpdate(), zc.postRender(() => { !l.currentAnimation && l.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: l, layoutGroup: u, switchLayoutGroup: o } = this.props, { projection: c } = l; jr = !0, c && (c.scheduleCheckAfterUnmount(), u && u.group && u.group.remove(c), o && o.deregister && o.deregister(c)) } safeToRemove() { const { safeToRemove: l } = this.props; l && l() } render() { return null } } function Vg(i) { const [l, u] = $y(), o = X.useContext(rc); return k.jsx(aA, { ...i, layoutGroup: o, switchLayoutGroup: X.useContext(cg), isPresent: l, safeToRemove: u }) } const iA = { borderRadius: { ...ul, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: ul, borderTopRightRadius: ul, borderBottomLeftRadius: ul, borderBottomRightRadius: ul, boxShadow: nA }; function lA(i, l, u) { const o = ee(i) ? i : ai(i); return o.start(Gc("", o, l, u)), o.animation } const sA = (i, l) => i.depth - l.depth; class uA { constructor() { this.children = [], this.isDirty = !1 } add(l) { hc(this.children, l), this.isDirty = !0 } remove(l) { dc(this.children, l), this.isDirty = !0 } forEach(l) { this.isDirty && this.children.sort(sA), this.isDirty = !1, this.children.forEach(l) } } function oA(i, l) { const u = re.now(), o = ({ timestamp: c }) => { const d = c - u; d >= l && (Ln(o), i(d - l)) }; return Dt.setup(o, !0), () => Ln(o) } const zg = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], rA = zg.length, wp = i => typeof i == "string" ? parseFloat(i) : i, Lp = i => typeof i == "number" || it.test(i); function cA(i, l, u, o, c, d) { c ? (i.opacity = Ot(0, u.opacity ?? 1, fA(o)), i.opacityExit = Ot(l.opacity ?? 1, 0, hA(o))) : d && (i.opacity = Ot(l.opacity ?? 1, u.opacity ?? 1, o)); for (let h = 0; h < rA; h++) { const g = `border${zg[h]}Radius`; let y = Hp(l, g), m = Hp(u, g); if (y === void 0 && m === void 0) continue; y || (y = 0), m || (m = 0), y === 0 || m === 0 || Lp(y) === Lp(m) ? (i[g] = Math.max(Ot(wp(y), wp(m), o), 0), (Ke.test(m) || Ke.test(y)) && (i[g] += "%")) : i[g] = m } (l.rotate || u.rotate) && (i.rotate = Ot(l.rotate || 0, u.rotate || 0, o)) } function Hp(i, l) { return i[l] !== void 0 ? i[l] : i.borderRadius } const fA = Ng(0, .5, vy), hA = Ng(.5, .95, ze); function Ng(i, l, u) { return o => o < i ? 0 : o > l ? 1 : u(ml(i, l, o)) } function qp(i, l) { i.min = l.min, i.max = l.max } function Ce(i, l) { qp(i.x, l.x), qp(i.y, l.y) } function Yp(i, l) { i.translate = l.translate, i.scale = l.scale, i.originPoint = l.originPoint, i.origin = l.origin } function Gp(i, l, u, o, c) { return i -= l, i = $s(i, 1 / u, o), c !== void 0 && (i = $s(i, 1 / c, o)), i } function dA(i, l = 0, u = 1, o = .5, c, d = i, h = i) { if (Ke.test(l) && (l = parseFloat(l), l = Ot(h.min, h.max, l / 100) - h.min), typeof l != "number") return; let g = Ot(d.min, d.max, o); i === d && (g -= l), i.min = Gp(i.min, l, u, g, c), i.max = Gp(i.max, l, u, g, c) } function Xp(i, l, [u, o, c], d, h) { dA(i, l[u], l[o], l[c], l.scale, d, h) } const mA = ["x", "scaleX", "originX"], pA = ["y", "scaleY", "originY"]; function Zp(i, l, u, o) { Xp(i.x, l, mA, u ? u.x : void 0, o ? o.x : void 0), Xp(i.y, l, pA, u ? u.y : void 0, o ? o.y : void 0) } function Kp(i) { return i.translate === 0 && i.scale === 1 } function Ug(i) { return Kp(i.x) && Kp(i.y) } function Qp(i, l) { return i.min === l.min && i.max === l.max } function yA(i, l) { return Qp(i.x, l.x) && Qp(i.y, l.y) } function Jp(i, l) { return Math.round(i.min) === Math.round(l.min) && Math.round(i.max) === Math.round(l.max) } function _g(i, l) { return Jp(i.x, l.x) && Jp(i.y, l.y) } function kp(i) { return ae(i.x) / ae(i.y) } function Pp(i, l) { return i.translate === l.translate && i.scale === l.scale && i.originPoint === l.originPoint } class gA { constructor() { this.members = [] } add(l) { hc(this.members, l), l.scheduleRender() } remove(l) { if (dc(this.members, l), l === this.prevLead && (this.prevLead = void 0), l === this.lead) { const u = this.members[this.members.length - 1]; u && this.promote(u) } } relegate(l) { const u = this.members.findIndex(c => l === c); if (u === 0) return !1; let o; for (let c = u; c >= 0; c--) { const d = this.members[c]; if (d.isPresent !== !1) { o = d; break } } return o ? (this.promote(o), !0) : !1 } promote(l, u) { const o = this.lead; if (l !== o && (this.prevLead = o, this.lead = l, l.show(), o)) { o.instance && o.scheduleRender(), l.scheduleRender(), l.resumeFrom = o, u && (l.resumeFrom.preserveOpacity = !0), o.snapshot && (l.snapshot = o.snapshot, l.snapshot.latestValues = o.animationValues || o.latestValues), l.root && l.root.isUpdating && (l.isLayoutDirty = !0); const { crossfade: c } = l.options; c === !1 && o.hide() } } exitAnimationComplete() { this.members.forEach(l => { const { options: u, resumingFrom: o } = l; u.onExitComplete && u.onExitComplete(), o && o.options.onExitComplete && o.options.onExitComplete() }) } scheduleRender() { this.members.forEach(l => { l.instance && l.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function vA(i, l, u) { let o = ""; const c = i.x.translate / l.x, d = i.y.translate / l.y, h = u?.z || 0; if ((c || d || h) && (o = `translate3d(${c}px, ${d}px, ${h}px) `), (l.x !== 1 || l.y !== 1) && (o += `scale(${1 / l.x}, ${1 / l.y}) `), u) { const { transformPerspective: m, rotate: v, rotateX: b, rotateY: x, skewX: V, skewY: w } = u; m && (o = `perspective(${m}px) ${o}`), v && (o += `rotate(${v}deg) `), b && (o += `rotateX(${b}deg) `), x && (o += `rotateY(${x}deg) `), V && (o += `skewX(${V}deg) `), w && (o += `skewY(${w}deg) `) } const g = i.x.scale * l.x, y = i.y.scale * l.y; return (g !== 1 || y !== 1) && (o += `scale(${g}, ${y})`), o || "none" } const wr = ["", "X", "Y", "Z"], SA = 1e3; let bA = 0; function Lr(i, l, u, o) { const { latestValues: c } = l; c[i] && (u[i] = c[i], l.setStaticValue(i, 0), o && (o[i] = 0)) } function Bg(i) { if (i.hasCheckedOptimisedAppear = !0, i.root === i) return; const { visualElement: l } = i.options; if (!l) return; const u = bg(l); if (window.MotionHasOptimisedAnimation(u, "transform")) { const { layout: c, layoutId: d } = i.options; window.MotionCancelOptimisedAnimation(u, "transform", Dt, !(c || d)) } const { parent: o } = i; o && !o.hasCheckedOptimisedAppear && Bg(o) } function jg({ attachResizeListener: i, defaultParent: l, measureScroll: u, checkIsScrollRoot: o, resetTransform: c }) { return class { constructor(h = {}, g = l?.()) { this.id = bA++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(xA), this.nodes.forEach(RA), this.nodes.forEach(OA), this.nodes.forEach(EA) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = h, this.root = g ? g.root || g : this, this.path = g ? [...g.path, g] : [], this.parent = g, this.depth = g ? g.depth + 1 : 0; for (let y = 0; y < this.path.length; y++)this.path[y].shouldResetTransform = !0; this.root === this && (this.nodes = new uA) } addEventListener(h, g) { return this.eventHandlers.has(h) || this.eventHandlers.set(h, new yc), this.eventHandlers.get(h).add(g) } notifyListeners(h, ...g) { const y = this.eventHandlers.get(h); y && y.notify(...g) } hasListeners(h) { return this.eventHandlers.has(h) } mount(h) { if (this.instance) return; this.isSVG = Wy(h) && !cb(h), this.instance = h; const { layoutId: g, layout: y, visualElement: m } = this.options; if (m && !m.current && m.mount(h), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (y || g) && (this.isLayoutDirty = !0), i) { let v, b = 0; const x = () => this.root.updateBlockedByResize = !1; Dt.read(() => { b = window.innerWidth }), i(h, () => { const V = window.innerWidth; V !== b && (b = V, this.root.updateBlockedByResize = !0, v && v(), v = oA(x, 250), Qs.hasAnimatedSinceResize && (Qs.hasAnimatedSinceResize = !1, this.nodes.forEach($p))) }) } g && this.root.registerSharedNode(g, this), this.options.animate !== !1 && m && (g || y) && this.addEventListener("didUpdate", ({ delta: v, hasLayoutChanged: b, hasRelativeLayoutChanged: x, layout: V }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const w = this.options.transition || m.getDefaultTransition() || UA, { onLayoutAnimationStart: U, onLayoutAnimationComplete: B } = m.getProps(), q = !this.targetLayout || !_g(this.targetLayout, V), Z = !b && x; if (this.options.layoutRoot || this.resumeFrom || Z || b && (q || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const Y = { ...Cc(w, "layout"), onPlay: U, onComplete: B }; (m.shouldReduceMotion || this.options.layoutRoot) && (Y.delay = 0, Y.type = !1), this.startAnimation(Y), this.setAnimationOrigin(v, Z) } else b || $p(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = V }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const h = this.getStack(); h && h.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), Ln(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(CA), this.animationId++) } getTransformTemplate() { const { visualElement: h } = this.options; return h && h.getProps().transformTemplate } willUpdate(h = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && Bg(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let v = 0; v < this.path.length; v++) { const b = this.path[v]; b.shouldResetTransform = !0, b.updateScroll("snapshot"), b.options.layoutRoot && b.willUpdate(!1) } const { layoutId: g, layout: y } = this.options; if (g === void 0 && !y) return; const m = this.getTransformTemplate(); this.prevTransformTemplateValue = m ? m(this.latestValues, "") : void 0, this.updateSnapshot(), h && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Fp); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(Wp); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(DA), this.nodes.forEach(TA), this.nodes.forEach(AA)) : this.nodes.forEach(Wp), this.clearAllSnapshots(); const g = re.now(); Wt.delta = cn(0, 1e3 / 60, g - Wt.timestamp), Wt.timestamp = g, Wt.isProcessing = !0, Dr.update.process(Wt), Dr.preRender.process(Wt), Dr.render.process(Wt), Wt.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, zc.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(MA), this.sharedNodes.forEach(VA) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Dt.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Dt.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !ae(this.snapshot.measuredBox.x) && !ae(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let y = 0; y < this.path.length; y++)this.path[y].updateScroll(); const h = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Bt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: g } = this.options; g && g.notify("LayoutMeasure", this.layout.layoutBox, h ? h.layoutBox : void 0) } updateScroll(h = "measure") { let g = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === h && (g = !1), g && this.instance) { const y = o(this.instance); this.scroll = { animationId: this.root.animationId, phase: h, isRoot: y, offset: u(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : y } } } resetTransform() { if (!c) return; const h = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, g = this.projectionDelta && !Ug(this.projectionDelta), y = this.getTransformTemplate(), m = y ? y(this.latestValues, "") : void 0, v = m !== this.prevTransformTemplateValue; h && this.instance && (g || sa(this.latestValues) || v) && (c(this.instance, m), this.shouldResetTransform = !1, this.scheduleRender()) } measure(h = !0) { const g = this.measurePageBox(); let y = this.removeElementScroll(g); return h && (y = this.removeTransform(y)), _A(y), { animationId: this.root.animationId, measuredBox: g, layoutBox: y, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: h } = this.options; if (!h) return Bt(); const g = h.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(BA))) { const { scroll: m } = this.root; m && (Ia(g.x, m.offset.x), Ia(g.y, m.offset.y)) } return g } removeElementScroll(h) { const g = Bt(); if (Ce(g, h), this.scroll?.wasRoot) return g; for (let y = 0; y < this.path.length; y++) { const m = this.path[y], { scroll: v, options: b } = m; m !== this.root && v && b.layoutScroll && (v.wasRoot && Ce(g, h), Ia(g.x, v.offset.x), Ia(g.y, v.offset.y)) } return g } applyTransform(h, g = !1) { const y = Bt(); Ce(y, h); for (let m = 0; m < this.path.length; m++) { const v = this.path[m]; !g && v.options.layoutScroll && v.scroll && v !== v.root && ti(y, { x: -v.scroll.offset.x, y: -v.scroll.offset.y }), sa(v.latestValues) && ti(y, v.latestValues) } return sa(this.latestValues) && ti(y, this.latestValues), y } removeTransform(h) { const g = Bt(); Ce(g, h); for (let y = 0; y < this.path.length; y++) { const m = this.path[y]; if (!m.instance || !sa(m.latestValues)) continue; tc(m.latestValues) && m.updateSnapshot(); const v = Bt(), b = m.measurePageBox(); Ce(v, b), Zp(g, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, v) } return sa(this.latestValues) && Zp(g, this.latestValues), g } setTargetDelta(h) { this.targetDelta = h, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(h) { this.options = { ...this.options, ...h, crossfade: h.crossfade !== void 0 ? h.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Wt.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(h = !1) { const g = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = g.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = g.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = g.isSharedProjectionDirty); const y = !!this.resumingFrom || this !== g; if (!(h || y && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: v, layoutId: b } = this.options; if (!(!this.layout || !(v || b))) { if (this.resolvedRelativeTargetAt = Wt.timestamp, !this.targetDelta && !this.relativeTarget) { const x = this.getClosestProjectingParent(); x && x.layout && this.animationProgress !== 1 ? (this.relativeParent = x, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Bt(), this.relativeTargetOrigin = Bt(), dl(this.relativeTargetOrigin, this.layout.layoutBox, x.layout.layoutBox), Ce(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Bt(), this.targetWithTransforms = Bt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), YT(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Ce(this.target, this.layout.layoutBox), mg(this.target, this.targetDelta)) : Ce(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) { this.attemptToResolveRelativeTarget = !1; const x = this.getClosestProjectingParent(); x && !!x.resumingFrom == !!this.resumingFrom && !x.options.layoutScroll && x.target && this.animationProgress !== 1 ? (this.relativeParent = x, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Bt(), this.relativeTargetOrigin = Bt(), dl(this.relativeTargetOrigin, this.target, x.target), Ce(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } } } getClosestProjectingParent() { if (!(!this.parent || tc(this.parent.latestValues) || dg(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { const h = this.getLead(), g = !!this.resumingFrom || this !== h; let y = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (y = !1), g && (this.isSharedProjectionDirty || this.isTransformDirty) && (y = !1), this.resolvedRelativeTargetAt === Wt.timestamp && (y = !1), y) return; const { layout: m, layoutId: v } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(m || v)) return; Ce(this.layoutCorrected, this.layout.layoutBox); const b = this.treeScale.x, x = this.treeScale.y; Ib(this.layoutCorrected, this.treeScale, this.path, g), h.layout && !h.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (h.target = h.layout.layoutBox, h.targetWithTransforms = Bt()); const { target: V } = h; if (!V) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Yp(this.prevProjectionDelta.x, this.projectionDelta.x), Yp(this.prevProjectionDelta.y, this.projectionDelta.y)), hl(this.projectionDelta, this.layoutCorrected, V, this.latestValues), (this.treeScale.x !== b || this.treeScale.y !== x || !Pp(this.projectionDelta.x, this.prevProjectionDelta.x) || !Pp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", V)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(h = !0) { if (this.options.visualElement?.scheduleRender(), h) { const g = this.getStack(); g && g.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = ei(), this.projectionDelta = ei(), this.projectionDeltaWithTransform = ei() } setAnimationOrigin(h, g = !1) { const y = this.snapshot, m = y ? y.latestValues : {}, v = { ...this.latestValues }, b = ei(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !g; const x = Bt(), V = y ? y.source : void 0, w = this.layout ? this.layout.source : void 0, U = V !== w, B = this.getStack(), q = !B || B.members.length <= 1, Z = !!(U && !q && this.options.crossfade === !0 && !this.path.some(NA)); this.animationProgress = 0; let Y; this.mixTargetDelta = et => { const H = et / 1e3; Ip(b.x, h.x, H), Ip(b.y, h.y, H), this.setTargetDelta(b), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (dl(x, this.layout.layoutBox, this.relativeParent.layout.layoutBox), zA(this.relativeTarget, this.relativeTargetOrigin, x, H), Y && yA(this.relativeTarget, Y) && (this.isProjectionDirty = !1), Y || (Y = Bt()), Ce(Y, this.relativeTarget)), U && (this.animationValues = v, cA(v, m, this.latestValues, H, Z, q)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = H }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(h) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (Ln(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Dt.update(() => { Qs.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = ai(0)), this.currentAnimation = lA(this.motionValue, [0, 1e3], { ...h, velocity: 0, isSync: !0, onUpdate: g => { this.mixTargetDelta(g), h.onUpdate && h.onUpdate(g) }, onStop: () => { }, onComplete: () => { h.onComplete && h.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const h = this.getStack(); h && h.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(SA), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const h = this.getLead(); let { targetWithTransforms: g, target: y, layout: m, latestValues: v } = h; if (!(!g || !y || !m)) { if (this !== h && this.layout && m && wg(this.options.animationType, this.layout.layoutBox, m.layoutBox)) { y = this.target || Bt(); const b = ae(this.layout.layoutBox.x); y.x.min = h.target.x.min, y.x.max = y.x.min + b; const x = ae(this.layout.layoutBox.y); y.y.min = h.target.y.min, y.y.max = y.y.min + x } Ce(g, y), ti(g, v), hl(this.projectionDeltaWithTransform, this.layoutCorrected, g, v) } } registerSharedNode(h, g) { this.sharedNodes.has(h) || this.sharedNodes.set(h, new gA), this.sharedNodes.get(h).add(g); const m = g.options.initialPromotionConfig; g.promote({ transition: m ? m.transition : void 0, preserveFollowOpacity: m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(g) : void 0 }) } isLead() { const h = this.getStack(); return h ? h.lead === this : !0 } getLead() { const { layoutId: h } = this.options; return h ? this.getStack()?.lead || this : this } getPrevLead() { const { layoutId: h } = this.options; return h ? this.getStack()?.prevLead : void 0 } getStack() { const { layoutId: h } = this.options; if (h) return this.root.sharedNodes.get(h) } promote({ needsReset: h, transition: g, preserveFollowOpacity: y } = {}) { const m = this.getStack(); m && m.promote(this, y), h && (this.projectionDelta = void 0, this.needsReset = !0), g && this.setOptions({ transition: g }) } relegate() { const h = this.getStack(); return h ? h.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: h } = this.options; if (!h) return; let g = !1; const { latestValues: y } = h; if ((y.z || y.rotate || y.rotateX || y.rotateY || y.rotateZ || y.skewX || y.skewY) && (g = !0), !g) return; const m = {}; y.z && Lr("z", h, m, this.animationValues); for (let v = 0; v < wr.length; v++)Lr(`rotate${wr[v]}`, h, m, this.animationValues), Lr(`skew${wr[v]}`, h, m, this.animationValues); h.render(); for (const v in m) h.setStaticValue(v, m[v]), this.animationValues && (this.animationValues[v] = m[v]); h.scheduleRender() } applyProjectionStyles(h, g) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { h.visibility = "hidden"; return } const y = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, h.visibility = "", h.opacity = "", h.pointerEvents = Ks(g?.pointerEvents) || "", h.transform = y ? y(this.latestValues, "") : "none"; return } const m = this.getLead(); if (!this.projectionDelta || !this.layout || !m.target) { this.options.layoutId && (h.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, h.pointerEvents = Ks(g?.pointerEvents) || ""), this.hasProjected && !sa(this.latestValues) && (h.transform = y ? y({}, "") : "none", this.hasProjected = !1); return } h.visibility = ""; const v = m.animationValues || m.latestValues; this.applyTransformsToTarget(); let b = vA(this.projectionDeltaWithTransform, this.treeScale, v); y && (b = y(v, b)), h.transform = b; const { x, y: V } = this.projectionDelta; h.transformOrigin = `${x.origin * 100}% ${V.origin * 100}% 0`, m.animationValues ? h.opacity = m === this ? v.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : v.opacityExit : h.opacity = m === this ? v.opacity !== void 0 ? v.opacity : "" : v.opacityExit !== void 0 ? v.opacityExit : 0; for (const w in vl) { if (v[w] === void 0) continue; const { correct: U, applyTo: B, isCSSVariable: q } = vl[w], Z = b === "none" ? v[w] : U(v[w], m); if (B) { const Y = B.length; for (let et = 0; et < Y; et++)h[B[et]] = Z } else q ? this.options.visualElement.renderState.vars[w] = Z : h[w] = Z } this.options.layoutId && (h.pointerEvents = m === this ? Ks(g?.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(h => h.currentAnimation?.stop()), this.root.nodes.forEach(Fp), this.root.sharedNodes.clear() } } } function TA(i) { i.updateLayout() } function AA(i) { const l = i.resumeFrom?.snapshot || i.snapshot; if (i.isLead() && i.layout && l && i.hasListeners("didUpdate")) { const { layoutBox: u, measuredBox: o } = i.layout, { animationType: c } = i.options, d = l.source !== i.layout.source; c === "size" ? Ve(v => { const b = d ? l.measuredBox[v] : l.layoutBox[v], x = ae(b); b.min = u[v].min, b.max = b.min + x }) : wg(c, l.layoutBox, u) && Ve(v => { const b = d ? l.measuredBox[v] : l.layoutBox[v], x = ae(u[v]); b.max = b.min + x, i.relativeTarget && !i.currentAnimation && (i.isProjectionDirty = !0, i.relativeTarget[v].max = i.relativeTarget[v].min + x) }); const h = ei(); hl(h, u, l.layoutBox); const g = ei(); d ? hl(g, i.applyTransform(o, !0), l.measuredBox) : hl(g, u, l.layoutBox); const y = !Ug(h); let m = !1; if (!i.resumeFrom) { const v = i.getClosestProjectingParent(); if (v && !v.resumeFrom) { const { snapshot: b, layout: x } = v; if (b && x) { const V = Bt(); dl(V, l.layoutBox, b.layoutBox); const w = Bt(); dl(w, u, x.layoutBox), _g(V, w) || (m = !0), v.options.layoutRoot && (i.relativeTarget = w, i.relativeTargetOrigin = V, i.relativeParent = v) } } } i.notifyListeners("didUpdate", { layout: u, snapshot: l, delta: g, layoutDelta: h, hasLayoutChanged: y, hasRelativeLayoutChanged: m }) } else if (i.isLead()) { const { onExitComplete: u } = i.options; u && u() } i.options.transition = void 0 } function xA(i) { i.parent && (i.isProjecting() || (i.isProjectionDirty = i.parent.isProjectionDirty), i.isSharedProjectionDirty || (i.isSharedProjectionDirty = !!(i.isProjectionDirty || i.parent.isProjectionDirty || i.parent.isSharedProjectionDirty)), i.isTransformDirty || (i.isTransformDirty = i.parent.isTransformDirty)) } function EA(i) { i.isProjectionDirty = i.isSharedProjectionDirty = i.isTransformDirty = !1 } function MA(i) { i.clearSnapshot() } function Fp(i) { i.clearMeasurements() } function Wp(i) { i.isLayoutDirty = !1 } function DA(i) { const { visualElement: l } = i.options; l && l.getProps().onBeforeLayoutMeasure && l.notify("BeforeLayoutMeasure"), i.resetTransform() } function $p(i) { i.finishAnimation(), i.targetDelta = i.relativeTarget = i.target = void 0, i.isProjectionDirty = !0 } function RA(i) { i.resolveTargetDelta() } function OA(i) { i.calcProjection() } function CA(i) { i.resetSkewAndRotation() } function VA(i) { i.removeLeadSnapshot() } function Ip(i, l, u) { i.translate = Ot(l.translate, 0, u), i.scale = Ot(l.scale, 1, u), i.origin = l.origin, i.originPoint = l.originPoint } function ty(i, l, u, o) { i.min = Ot(l.min, u.min, o), i.max = Ot(l.max, u.max, o) } function zA(i, l, u, o) { ty(i.x, l.x, u.x, o), ty(i.y, l.y, u.y, o) } function NA(i) { return i.animationValues && i.animationValues.opacityExit !== void 0 } const UA = { duration: .45, ease: [.4, 0, .1, 1] }, ey = i => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(i), ny = ey("applewebkit/") && !ey("chrome/") ? Math.round : ze; function ay(i) { i.min = ny(i.min), i.max = ny(i.max) } function _A(i) { ay(i.x), ay(i.y) } function wg(i, l, u) { return i === "position" || i === "preserve-aspect" && !qT(kp(l), kp(u), .2) } function BA(i) { return i !== i.root && i.scroll?.wasRoot } const jA = jg({ attachResizeListener: (i, l) => Sl(i, "resize", l), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Hr = { current: void 0 }, Lg = jg({ measureScroll: i => ({ x: i.scrollLeft, y: i.scrollTop }), defaultParent: () => { if (!Hr.current) { const i = new jA({}); i.mount(window), i.setOptions({ layoutScroll: !0 }), Hr.current = i } return Hr.current }, resetTransform: (i, l) => { i.style.transform = l !== void 0 ? l : "none" }, checkIsScrollRoot: i => window.getComputedStyle(i).position === "fixed" }), wA = { pan: { Feature: eA }, drag: { Feature: tA, ProjectionNode: Lg, MeasureLayout: Vg } }; function iy(i, l, u) { const { props: o } = i; i.animationState && o.whileHover && i.animationState.setActive("whileHover", u === "Start"); const c = "onHover" + u, d = o[c]; d && Dt.postRender(() => d(l, xl(l))) } class LA extends qn { mount() { const { current: l } = this.node; l && (this.unmount = lb(l, (u, o) => (iy(this.node, o, "Start"), c => iy(this.node, c, "End")))) } unmount() { } } class HA extends qn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let l = !1; try { l = this.node.current.matches(":focus-visible") } catch { l = !0 } !l || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = bl(Sl(this.node.current, "focus", () => this.onFocus()), Sl(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function ly(i, l, u) { const { props: o } = i; if (i.current instanceof HTMLButtonElement && i.current.disabled) return; i.animationState && o.whileTap && i.animationState.setActive("whileTap", u === "Start"); const c = "onTap" + (u === "End" ? "" : u), d = o[c]; d && Dt.postRender(() => d(l, xl(l))) } class qA extends qn { mount() { const { current: l } = this.node; l && (this.unmount = rb(l, (u, o) => (ly(this.node, o, "Start"), (c, { success: d }) => ly(this.node, c, d ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const uc = new WeakMap, qr = new WeakMap, YA = i => { const l = uc.get(i.target); l && l(i) }, GA = i => { i.forEach(YA) }; function XA({ root: i, ...l }) { const u = i || document; qr.has(u) || qr.set(u, {}); const o = qr.get(u), c = JSON.stringify(l); return o[c] || (o[c] = new IntersectionObserver(GA, { root: i, ...l })), o[c] } function ZA(i, l, u) { const o = XA(l); return uc.set(i, u), o.observe(i), () => { uc.delete(i), o.unobserve(i) } } const KA = { some: 0, all: 1 }; class QA extends qn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: l = {} } = this.node.getProps(), { root: u, margin: o, amount: c = "some", once: d } = l, h = { root: u ? u.current : void 0, rootMargin: o, threshold: typeof c == "number" ? c : KA[c] }, g = y => { const { isIntersecting: m } = y; if (this.isInView === m || (this.isInView = m, d && !m && this.hasEnteredView)) return; m && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", m); const { onViewportEnter: v, onViewportLeave: b } = this.node.getProps(), x = m ? v : b; x && x(y) }; return ZA(this.node.current, h, g) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: l, prevProps: u } = this.node;["amount", "margin", "root"].some(JA(l, u)) && this.startObserver() } unmount() { } } function JA({ viewport: i = {} }, { viewport: l = {} } = {}) { return u => i[u] !== l[u] } const kA = { inView: { Feature: QA }, tap: { Feature: qA }, focus: { Feature: HA }, hover: { Feature: LA } }, PA = { layout: { ProjectionNode: Lg, MeasureLayout: Vg } }, FA = { ..._T, ...kA, ...wA, ...PA }, rn = Fb(FA, rT), au = typeof window.GetParentResourceName == "function", sy = au ? window.GetParentResourceName() : null, WA = async (i, l) => !au || !sy ? Promise.reject(new Error("fetchNui unavailable in this environment")) : await (await fetch(`https://${sy}/${i}`, { method: "POST", headers: { "Content-Type": "application/json; charset=UTF-8" }, body: JSON.stringify(l || {}) })).json(), Js = {}; au && window.addEventListener("message", i => { const l = i.data; if (!l || !l.eventName) return; const u = Js[l.eventName]; u && u.forEach(o => o(l.payload)) }); const Fa = { fetch: (i, l) => WA(i, l), message: (i, l) => { au && (Js[i] || (Js[i] = []), Js[i].push(l)) } }, $A = (i, l) => { let u, o, c; if (i.startsWith("#")) { const y = i.replace("#", ""); u = parseInt(y.substring(0, 2), 16), o = parseInt(y.substring(2, 4), 16), c = parseInt(y.substring(4, 6), 16) } else if (i.startsWith("rgb")) { const y = i.match(/\d+/g); if (!y) throw new Error("Invalid RGB color");[u, o, c] = y.map(Number) } else throw new Error("Unsupported color format. Use hex (#RRGGBB) or rgb(r,g,b)."); const d = Math.max(0, Math.floor(u * (1 - l))), h = Math.max(0, Math.floor(o * (1 - l))), g = Math.max(0, Math.floor(c * (1 - l))); return `#${d.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}` }; function IA() { const [i, l] = X.useState(!1), [u, o] = X.useState([]), [c, d] = X.useState([]), [h, g] = X.useState(null), [y, m] = X.useState("rewards"), [v, b] = X.useState(1), x = U => { U !== y && (b(U === "leaderboard" ? 1 : -1), m(U)) }, V = { enter: U => ({ x: U > 0 ? 100 : -100, opacity: 0 }), center: { x: 0, opacity: 1, transition: { duration: .1 } }, exit: U => ({ x: U > 0 ? -100 : 100, opacity: 0, transition: { duration: .1 } }) }, w = U => { if (h) { if (h.coins < U.price) { Fa.fetch("exoticrp/menu/notify", { type: "error", message: "Nie masz wystarczajco monet, aby odebra ten produkt." }); return } g({ ...h, coins: h.coins - U.price }), o(B => B.map(q => q.id === U.id ? { ...q, status: "claimed" } : q)), Fa.fetch("exoticrp/menu/claim", { productId: U.id }).then(() => { }).catch(() => { }) } }; return X.useEffect(() => { Fa.message("exoticrp/request/leaderboard", B => { d(B.leaderboard) }), Fa.message("exoticrp/request/config", B => { o(B.products) }), Fa.message("exoticrp/menu/open", B => { l(B.open), g(B.profile) }); const U = B => { B.key === "Escape" && (l(!1), Fa.fetch("exoticrp/menu/close", { closedBy: "ESC" }).then(() => { }).catch(() => { })) }; return window.addEventListener("keydown", U), () => { window.removeEventListener("keydown", U) } }, []), k.jsx(dp, { children: i && k.jsxs(rn.div, { initial: { x: -500, opacity: 0 }, animate: { x: 0, opacity: 1 }, exit: { x: -500, opacity: 0 }, transition: { type: "spring", stiffness: 800, damping: 50 }, className: "w-[550px] h-screen bg-black/90 p-4 text-white flex flex-col gap-8 items-center justify-start overflow-hidden", children: [k.jsxs("div", { className: "w-full flex items-center justify-between", children: [k.jsxs("div", { className: "flex flex-col items-start", children: [k.jsx("span", { className: "font-bold text-xl", children: "Sklep witeczny za czas" }), k.jsx("span", { className: "text-xs text-white/50", children: "Odbieraj nagrody i si nimi ciesz!" })] }), k.jsxs("div", { className: "flex items-center gap-3", children: [k.jsxs("div", { className: "flex flex-col items-end gap-1", children: [k.jsx("span", { className: "font-bold", children: h?.username }), k.jsxs("div", { className: "flex items-center justify-center gap-2", children: [k.jsxs("span", { className: "text-xs px-3 py-1 rounded-md bg-white/15 border border-white/15 flex items-center justify-center gap-1 font-bold text-white", children: [k.jsx("i", { className: "fa-solid fa-user" }), " #1"] }), k.jsxs("span", { className: "text-xs px-3 py-1 bg-[#FF8800] rounded-md border border-white/15 flex items-center justify-center gap-1 font-bold", children: [k.jsx("i", { className: "fa-solid fa-coin" }), " ", h?.coins] })] })] }), k.jsx("img", { className: "w-14 h-14 rounded-md border border-[#FF8800]", src: h?.avatar })] })] }), k.jsx("div", { className: "w-full h-0.5 bg-white/5" }), k.jsx("div", { className: "flex items-center justify-between gap-2 w-full", children: k.jsx("div", { className: "flex items-center justify-start gap-4 relative", children: ["rewards", "leaderboard"].map(U => k.jsxs("button", { onClick: () => x(U), className: `relative px-4 py-2 text-xs font-bold transition-colors duration-300 ${y === U ? "text-[#FF8800]" : "text-white/50 hover:text-white"}`, children: [U === "rewards" ? "NAGRODY" : "TOPKA", y === U && k.jsxs(k.Fragment, { children: [k.jsx(rn.div, { layoutId: "activeTabIndicator", className: "absolute bottom-0 left-0 right-0 h-[2px] bg-[#FF8800]", transition: { type: "spring", stiffness: 300, damping: 20 } }), k.jsx(rn.div, { layoutId: "activeTabGradient", className: "absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-[#FF8800]/50 to-transparent z-5", transition: { type: "spring", stiffness: 300, damping: 20 } })] })] }, U)) }) }), k.jsx("div", { className: "relative w-full flex-1", children: k.jsx(dp, { mode: "wait", custom: v, children: y === "rewards" ? k.jsx(rn.div, { variants: V, initial: "enter", animate: "center", exit: "exit", custom: v, className: "absolute inset-0 w-full grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto no-scroll", style: { maskImage: "linear-gradient(to top, transparent, black 10%)", WebkitMaskImage: "linear-gradient(to top, transparent, black 10%)" }, children: u.map(U => { const B = U.status === "claimed"; return k.jsxs("div", { className: "w-[162px] h-[202px] flex flex-col gap-2 items-center justify-center", children: [k.jsxs(rn.div, { layout: !0, initial: !1, animate: { backgroundColor: B ? "rgba(255,136,0,0.15)" : "rgba(0,0,0,0.15)", borderColor: B ? "rgba(255,136,0,0.3)" : "rgba(255,255,255,0.15)" }, transition: { duration: .4 }, className: "relative w-full h-full flex items-center justify-center rounded-xl overflow-hidden border", children: [B && k.jsx("div", { className: "bg-[#FF8800] h-20 w-20 absolute blur-[50px]" }), k.jsx("img", { className: "absolute w-24 h-24 rounded-md z-10", src: U.image || "https://via.placeholder.com/150" }), k.jsxs("div", { className: "absolute w-full flex justify-between top-0 p-2", children: [k.jsx(rn.span, { layout: !0, initial: !1, animate: { backgroundColor: B ? "rgba(255,136,0,0.15)" : "rgba(0,0,0,0.15)", borderColor: B ? "rgba(255,136,0,0.15)" : "rgba(255,255,255,0.15)" }, transition: { duration: .4 }, className: "px-2 py-0.5 rounded-lg z-20 font-bold text-sm border", children: U.count || 1 }), k.jsxs(rn.span, { layout: !0, initial: !1, animate: { backgroundColor: B ? "rgba(255,136,0,0.15)" : "rgba(0,0,0,0.15)", borderColor: B ? "rgba(255,136,0,0.15)" : "rgba(255,255,255,0.15)" }, transition: { duration: .4 }, className: "px-2 py-0.5 rounded-lg z-20 font-bold text-sm flex items-center justify-center gap-1 border", children: [k.jsx("i", { className: "fa-solid fa-coin" }), U.price || 0] })] }), k.jsx("div", { className: "absolute w-full flex justify-center bottom-0 p-2 z-20", children: k.jsx("span", { className: "z-20 font-bold text-xs", children: U.name || "Unknown Item" }) })] }), k.jsx(rn.div, { layout: !0, initial: !1, animate: { backgroundColor: B ? "rgba(255,136,0,0.15)" : "rgba(0,0,0,0.15)", borderColor: B ? "rgba(255,136,0,0.3)" : "rgba(255,255,255,0.15)" }, transition: { duration: .4 }, className: "relative w-full h-14 flex items-center justify-center rounded-xl text-white overflow-hidden border", children: B ? k.jsx("span", { className: "z-10 font-semibold", children: "Odebrane!" }) : k.jsxs("button", { onClick: () => w(U), className: "z-10 font-semibold w-full h-full bg-black/50 hover:bg-black/70 rounded-xl flex items-center justify-center", children: ["Odbierz (", U.price, " ", k.jsx("i", { className: "fa-solid fa-coin" }), ")"] }) })] }, U.id) }) }, "rewards") : k.jsx(rn.div, { variants: V, initial: "enter", animate: "center", exit: "exit", custom: v, className: "absolute inset-0 w-full flex flex-col gap-2 overflow-y-auto", children: c.map((U, B) => k.jsxs("div", { className: "w-full bg-black/15 rounded-xl p-4 flex items-center justify-between", style: { background: B === 0 ? $A("#3B9EFF", .8) : "rgba(0,0,0,0.15)", border: B === 0 ? "1px solid rgba(255,136,0,0.15)" : "none" }, children: [k.jsxs("div", { className: "flex items-center gap-4", children: [k.jsxs("span", { className: "text-2xl font-bold", style: { color: B === 0 ? "#3B9EFF" : "white" }, children: ["#", B + 1] }), k.jsx("span", { className: "font-bold", children: U.name })] }), k.jsxs("span", { className: "px-3 py-1 bg-[#FF8800] rounded-md border border-white/15 flex items-center justify-center gap-1 font-bold", children: [k.jsx("i", { className: "fa-solid fa-coin" }), " ", U.coins] })] }, U.id)) }, "leaderboard") }) })] }, "MAIN") }) } y1.createRoot(document.getElementById("root")).render(k.jsx(X.StrictMode, { children: k.jsx(IA, {}) }));
